{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#useful-math-functions","title":"useful-math-functions","text":"<p><code>useful-math-functions</code> is a collection of useful mathematical functions with a focus on:</p> <ol> <li>ease of use - the functions are designed to be as easy to use as possible</li> <li>pure python - the functions are written in much python as possible and    only use external libraries when necessary</li> <li>documentation - the functions are documented in code itself with:</li> <li>Examples</li> <li>Equations</li> <li>References</li> <li>Links to external resources</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>The package can be installed via pip:</p> Bash<pre><code>pip install useful-math-functions\n</code></pre> <p>and for Visualizations:</p> Bash<pre><code># matplotlib\npip install useful-math-functions[matplotlib]\n\n# plotly\npip install useful-math-functions[plotly]\n\n# all visualizations\npip install useful-math-functions[all]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The package can be imported like any other python package:</p> Python<pre><code>from umf.core.create import OptBench\nres = OptBench([\"DeJongN5Function\"], dim=3)\nres.plot_type_3d = \"plot_surface\"\nres.plot()\nres.save_as_image()\n</code></pre> <p></p> <p>To use the newly added functions:</p> Python<pre><code>from umf.functions.optimization.special import HimmelblauFunction\nimport numpy as np\n\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x, y)\nZ = HimmelblauFunction(X, Y).__eval__\n\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(111, projection=\"3d\")\nax.plot_surface(X, Y, Z, cmap=\"viridis\")\nplt.savefig(\"HimmelblauFunction.png\", dpi=300, transparent=True)\n</code></pre> Python<pre><code>from umf.functions.optimization.valley_shaped import Rosenbrock2DFunction\nimport numpy as np\n\nx = np.linspace(-2, 2, 100)\ny = np.linspace(-1, 3, 100)\nX, Y = np.meshgrid(x, y)\nZ = RosenbrockFunction(X, Y).__eval__\n\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(111, projection=\"3d\")\nax.plot_surface(X, Y, Z, cmap=\"viridis\")\nplt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome. For major changes, please open an issue first to discuss what you would like to change.</p>"},{"location":"#license","title":"License","text":"<p>The project is licensed under the MIT license.</p>"},{"location":"docs/","title":"Further Reading","text":""},{"location":"docs/#links","title":"Links","text":"<ul> <li>N-D Test Functions M \u2014 AMPGO 0.1.0 documentation. (n.d.). Infinity77.net.   from infinity77.net/global_optimization/test_functions_nd_M.html</li> <li>Optimization Test Functions and Datasets. (2013). Simon Fraser University,   from www.sfu.ca/~ssurjano/optimization.html</li> </ul>"},{"location":"docs/#books","title":"Books","text":"<ul> <li>Glaeser, G., &amp; Polthier, K. (2010). Bilder Der Mathematik (2<sup>nd</sup> ed.).   Spektrum Akademischer Verlag.</li> <li>Prosperetti, A. (2011). Advanced Mathematics for Applications. Cambridge   University Press.</li> <li>William H. Press, Teukolsky, S. A., Vetterling, W. T., &amp; Flannery, B. P.   (2007). Numerical recipes 3<sup>rd</sup> edition: The art of scientific computing (3<sup>rd</sup>   ed.). Cambridge University Press.</li> </ul>"},{"location":"home/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"home/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"home/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"home/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"home/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"home/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at Anselm.Hahn@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"home/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"home/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"home/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"home/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"home/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"home/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at www.contributor-covenant.org/faq. Translations are available at www.contributor-covenant.org/translations.</p>"},{"location":"home/contributing/","title":"Contribute Guideline","text":"<p>Thank you for considering contributing to <code>useful-math-functions</code>! We welcome contributions from anyone, whether you are an experienced developer or just getting started with open source.</p>"},{"location":"home/contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please take a moment to review the following resources:</p> <ul> <li>Code of Conduct</li> <li>Contributing Guidelines</li> <li>Issue Tracker</li> <li>Pull Requests</li> </ul>"},{"location":"home/contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are many ways you can contribute to <code>useful-math-functions</code>, including:</p> <ul> <li>Reporting bugs and issues</li> <li>Suggesting new features and improvements</li> <li>Writing documentation</li> <li>Fixing bugs and issues</li> <li>Implementing new features and improvements</li> <li>Reviewing code and pull requests</li> </ul> <p>If you are new to open source or to <code>useful-math-functions</code>, we recommend starting with a small contribution, such as fixing a typo or adding a new test case. This will help you get familiar with the project and the contribution process.</p>"},{"location":"home/contributing/#reporting-bugs-and-issues","title":"Reporting Bugs and Issues","text":"<p>If you encounter a bug or issue with <code>useful-math-functions</code>, please report it on the Issue Tracker. Before you report an issue, please check if it has already been reported by searching the existing issues.</p> <p>When reporting an issue, please include as much detail as possible, such as:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the issue</li> <li>Steps to reproduce the issue</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Screenshots or error messages (if applicable)</li> </ul>"},{"location":"home/contributing/#suggesting-new-features-and-improvements","title":"Suggesting New Features and Improvements","text":"<p>If you have an idea for a new feature or improvement for <code>useful-math-functions</code>, please suggest it on the Issue Tracker. Before you suggest a new feature or improvement, please check if it has already been suggested by searching the existing issues.</p> <p>When suggesting a new feature or improvement, please include as much detail as possible, such as:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature or improvement</li> <li>Use cases or examples of how the feature or improvement would be used</li> <li>Any potential drawbacks or limitations</li> </ul>"},{"location":"home/contributing/#writing-documentation","title":"Writing Documentation","text":"<p>If you would like to contribute to the documentation for <code>useful-math-functions</code>, please submit a pull request with your changes. Before you submit a pull request, please make sure your changes are consistent with the existing documentation style and format.</p>"},{"location":"home/contributing/#fixing-bugs-and-issues","title":"Fixing Bugs and Issues","text":"<p>If you would like to fix a bug or issue with <code>useful-math-functions</code>, please follow these steps:</p> <ol> <li>Assign the issue to yourself on the    Issue Tracker.</li> <li>Fork the repository and create a new branch for your changes.</li> <li>Make your changes and write tests to ensure they work as expected.</li> <li>Submit a pull request with your changes.</li> </ol> <p>When submitting a pull request, please include a clear and descriptive title, a detailed description of your changes, and any relevant screenshots or error messages.</p>"},{"location":"home/contributing/#implementing-new-features-and-improvements","title":"Implementing New Features and Improvements","text":"<p>If you would like to implement a new feature or improvement for <code>useful-math-functions</code>, please follow these steps:</p> <ol> <li>Create a new issue on the    Issue Tracker to    discuss your idea.</li> <li>Once your idea has been approved, fork the repository and create a new branch    for your changes.</li> <li>Make your changes and write tests to ensure they work as expected.</li> <li>Submit a pull request with your changes.</li> </ol> <p>When submitting a pull request, please include a clear and descriptive title, a detailed description of your changes, and any relevant screenshots or error messages.</p>"},{"location":"home/contributing/#reviewing-code-and-pull-requests","title":"Reviewing Code and Pull Requests","text":"<p>If you would like to review code or pull requests for <code>useful-math-functions</code>, please follow these guidelines:</p> <ul> <li>Be respectful and constructive in your feedback.</li> <li>Focus on the code and the problem, not the person.</li> <li>Provide specific and actionable feedback.</li> <li>Be open to feedback and willing to make changes.</li> </ul>"},{"location":"home/contributing/#conclusion","title":"Conclusion","text":"<p>We appreciate your interest in contributing to <code>useful-math-functions</code>! If you have any questions or need help getting started, please don't hesitate to reach out to us on the Issue Tracker.</p>"},{"location":"home/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2023 Anselm Hahn</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"modules/api/chaotic_systems/","title":"Modules","text":"<p>Chaotic Oscillators functions.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.ChuaSCircuit","title":"<code>ChuaSCircuit</code>","text":"<p>               Bases: <code>OscillatorsFunc3D</code></p> <p>Chua's Circuit differential equation.</p> <p>Chua's circuit is a simple physical system that exhibits chaotic behavior. It consists of a set of nonlinear differential equations that describe the evolution of the system's state over time. The behavior of the system is influenced by its nonlinear components and the values of its circuit elements.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import ChuaSCircuit\n&gt;&gt;&gt; circuit = ChuaSCircuit(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y, z = circuit.to_position\n&gt;&gt;&gt; t = circuit.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], marker=\"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     ax.set_title(f\"Current Time: {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('ChuaSCircuit.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>Chua's Circuit differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= \\alpha \\left( y - x - m_0 x + 0.5 \\left( \\lvert x + 1 \\rvert - \\lvert x - 1 \\rvert \\right) \\right), \\\\ \\dot{y} &amp;= x - y + z, \\\\ \\dot{z} &amp;= -\\beta y. \\end{align*} \\] <p>with \\(\\alpha\\) as a parameter related to the system's linear components, \\(\\beta\\) as a parameter related to the system's damping factor, and \\(m_0\\) as a parameter that determines the slope of the piecewise-linear function within the interval \\(([-1, 1])\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>alpha</code> <code>float</code> <p>The alpha parameter of Chua's circuit. Defaults to 15.6.</p> <code>15.6</code> <code>beta</code> <code>float</code> <p>The beta parameter of Chua's circuit. Defaults to 28.0.</p> <code>28.0</code> <code>m0</code> <code>float</code> <p>The m0 parameter of Chua's circuit. Defaults to -1.143.</p> <code>-1.143</code> <code>m1</code> <code>float</code> <p>The m1 parameter of Chua's circuit. Defaults to -0.714.</p> <code>-0.714</code> <code>R</code> <code>float</code> <p>The resistance of Chua's circuit. Defaults to 220.0.</p> <code>220.0</code> <code>C1</code> <code>float</code> <p>The capacitance of Chua's circuit. Defaults to 1.0e-6.</p> <code>1e-06</code> <code>C2</code> <code>float</code> <p>The capacitance of Chua's circuit. Defaults to 1.0e-6.</p> <code>1e-06</code> <code>L</code> <code>float</code> <p>The inductance of Chua's circuit. Defaults to 1.0e-3.</p> <code>0.001</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of Chua's circuit. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class ChuaSCircuit(OscillatorsFunc3D):\n    r\"\"\"Chua's Circuit differential equation.\n\n    Chua's circuit is a simple physical system that exhibits chaotic behavior. It\n    consists of a set of nonlinear differential equations that describe the evolution\n    of the system's state over time. The behavior of the system is influenced by its\n    nonlinear components and the values of its circuit elements.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import ChuaSCircuit\n        &gt;&gt;&gt; circuit = ChuaSCircuit(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y, z = circuit.to_position\n        &gt;&gt;&gt; t = circuit.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], marker=\"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     ax.set_title(f\"Current Time: {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('ChuaSCircuit.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        Chua's Circuit differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= \\alpha \\left( y - x - m_0 x + 0.5 \\left( \\lvert x + 1 \\rvert -\n        \\lvert x - 1 \\rvert \\right) \\right), \\\\\n        \\dot{y} &amp;= x - y + z, \\\\\n        \\dot{z} &amp;= -\\beta y.\n        \\end{align*}\n        $$\n\n        with $\\alpha$ as a parameter related to the system's linear components, $\\beta$\n        as a parameter related to the system's damping factor, and $m_0$ as a parameter\n        that determines the slope of the piecewise-linear function within the interval\n        $([-1, 1])$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        alpha (float, optional): The alpha parameter of Chua's circuit. Defaults to\n            15.6.\n        beta (float, optional): The beta parameter of Chua's circuit. Defaults to 28.0.\n        m0 (float, optional): The m0 parameter of Chua's circuit. Defaults to -1.143.\n        m1 (float, optional): The m1 parameter of Chua's circuit. Defaults to -0.714.\n        R (float, optional): The resistance of Chua's circuit. Defaults to 220.0.\n        C1 (float, optional): The capacitance of Chua's circuit. Defaults to 1.0e-6.\n        C2 (float, optional): The capacitance of Chua's circuit. Defaults to 1.0e-6.\n        L (float, optional): The inductance of Chua's circuit. Defaults to 1.0e-3.\n        velocity (bool, optional): Whether to return the velocity of Chua's circuit.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        alpha: float = 15.6,\n        beta: float = 28.0,\n        m0: float = -1.143,\n        m1: float = -0.714,\n        R: float = 220.0,\n        C1: float = 1.0e-6,\n        C2: float = 1.0e-6,\n        L: float = 1.0e-3,\n        time_format: str = \"seconds\",\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n\n        self.alpha = alpha\n        self.beta = beta\n        self.m0 = m0\n        self.m1 = m1\n        self.R = R\n        self.C1 = C1\n        self.C2 = C2\n        self.L = L\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of Chua's circuit.\"\"\"\n        return {\n            \"alpha\": self.alpha,\n            \"beta\": self.beta,\n            \"m0\": self.m0,\n            \"m1\": self.m1,\n            \"R\": self.R,\n            \"C1\": self.C1,\n            \"C2\": self.C2,\n            \"L\": self.L,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of Chua's circuit.\"\"\"\n        return [0.1, 0.0, 0.0]  # Small perturbation from zero\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of Chua's circuit.\n\n        Args:\n            initial_state (list[float]): The initial state of Chua's circuit.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of Chua's circuit.\n        \"\"\"\n        x, y, z = initial_state\n\n        # Nonlinear function of Chua's circuit\n        h = self.m1 * x + 0.5 * (self.m0 - self.m1) * (abs(x + 1) - abs(x - 1))\n\n        # Chua's Circuit differential equations\n        x_dot = self.alpha * (y - x - h)\n        y_dot = x - y + z\n        z_dot = -self.beta * y\n        return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.ChuaSCircuit.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of Chua's circuit.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.ChuaSCircuit.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of Chua's circuit.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.ChuaSCircuit.__init__","title":"<code>__init__(*t, alpha=15.6, beta=28.0, m0=-1.143, m1=-0.714, R=220.0, C1=1e-06, C2=1e-06, L=0.001, time_format='seconds', velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    *t: UniversalArray,\n    alpha: float = 15.6,\n    beta: float = 28.0,\n    m0: float = -1.143,\n    m1: float = -0.714,\n    R: float = 220.0,\n    C1: float = 1.0e-6,\n    C2: float = 1.0e-6,\n    L: float = 1.0e-3,\n    time_format: str = \"seconds\",\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n\n    self.alpha = alpha\n    self.beta = beta\n    self.m0 = m0\n    self.m1 = m1\n    self.R = R\n    self.C1 = C1\n    self.C2 = C2\n    self.L = L\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.ChuaSCircuit.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of Chua's circuit.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of Chua's circuit.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The equation of motion of Chua's circuit.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float]:\n    \"\"\"Return the equation of motion of Chua's circuit.\n\n    Args:\n        initial_state (list[float]): The initial state of Chua's circuit.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float, float]: The equation of motion of Chua's circuit.\n    \"\"\"\n    x, y, z = initial_state\n\n    # Nonlinear function of Chua's circuit\n    h = self.m1 * x + 0.5 * (self.m0 - self.m1) * (abs(x + 1) - abs(x - 1))\n\n    # Chua's Circuit differential equations\n    x_dot = self.alpha * (y - x - h)\n    y_dot = x - y + z\n    z_dot = -self.beta * y\n    return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum","title":"<code>DoublePendulum</code>","text":"<p>               Bases: <code>OscillatorsFuncBase</code></p> <p>Double Pendulum differential equation.</p> <p>The double pendulum is a simple physical system that exhibits chaotic behavior. The double pendulum consists of two pendulums attached to each other, where the motion of the second pendulum is influenced by the motion of the first pendulum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoublePendulum\n&gt;&gt;&gt; pendulum = DoublePendulum(np.linspace(0, 10, 1000))\n&gt;&gt;&gt; x1, y1, x2, y2 = pendulum.__eval__\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x2) - 0.5, max(x2) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y2) - 0.5, max(y2) + 0.5)\n&gt;&gt;&gt; (line,) = ax.plot([], [], \"o-\", lw=2)\n&gt;&gt;&gt; def init():\n...     line.set_data([], [])\n...     return (line,)\n&gt;&gt;&gt; def update(frame):\n...     line.set_data([0, x1[frame], x2[frame]], [0, y1[frame], y2[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return (line,)\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('DoublePendulum.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The double pendulum differential equation is defined as:</p> \\[ \\begin{align*} \\dot{z_1} &amp;= \\frac{m_2 g \\sin(\\theta_2) \\cos(\\theta_1 - \\theta_2) - m_2 \\sin(\\theta_1 - \\theta_2) (l_1 z_1^2 \\cos(\\theta_1 - \\theta_2) + l_2 z_2^2) - (m_1 + m_2) g \\sin(\\theta_1)}{l_1 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\\\ \\dot{z_2} &amp;= \\frac{(m_1 + m_2) (l_1 z_1^2 \\sin(\\theta_1 - \\theta_2) - g \\sin(\\theta_2) + g \\sin(\\theta_1) \\cos(\\theta_1 - \\theta_2)) + m_2 l_2 z_2^2 \\sin(\\theta_1 - \\theta_2) \\cos(\\theta_1 - \\theta_2)}{l_2 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\end{align*} \\] <p>with \\(\\dot{\\theta_1} = z_1 \\\\\\) and \\(\\dot{\\theta_2} = z_2\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>theta1</code> <code>float</code> <p>The initial angle of the first pendulum. Defaults to pi / 2.</p> <code>pi / 2</code> <code>theta2</code> <code>float</code> <p>The initial angle of the second pendulum. Defaults to pi / 2.</p> <code>pi / 2</code> <code>z1</code> <code>float</code> <p>The initial angular velocity of the first pendulum. Defaults to 0.0.</p> <code>0.0</code> <code>z2</code> <code>float</code> <p>The initial angular velocity of the second pendulum. Defaults to 0.0.</p> <code>0.0</code> <code>m1</code> <code>float</code> <p>The mass of the first pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>m2</code> <code>float</code> <p>The mass of the second pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>l1</code> <code>float</code> <p>The length of the first pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>l2</code> <code>float</code> <p>The length of the second pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>g</code> <code>float</code> <p>The acceleration due to gravity. Defaults to 9.81.</p> <code>g</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the double pendulum. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class DoublePendulum(OscillatorsFuncBase):\n    r\"\"\"Double Pendulum differential equation.\n\n    The double pendulum is a simple physical system that exhibits chaotic behavior.\n    The double pendulum consists of two pendulums attached to each other, where the\n    motion of the second pendulum is influenced by the motion of the first pendulum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoublePendulum\n        &gt;&gt;&gt; pendulum = DoublePendulum(np.linspace(0, 10, 1000))\n        &gt;&gt;&gt; x1, y1, x2, y2 = pendulum.__eval__\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x2) - 0.5, max(x2) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y2) - 0.5, max(y2) + 0.5)\n        &gt;&gt;&gt; (line,) = ax.plot([], [], \"o-\", lw=2)\n        &gt;&gt;&gt; def init():\n        ...     line.set_data([], [])\n        ...     return (line,)\n        &gt;&gt;&gt; def update(frame):\n        ...     line.set_data([0, x1[frame], x2[frame]], [0, y1[frame], y2[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return (line,)\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('DoublePendulum.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The double pendulum differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{z_1} &amp;= \\frac{m_2 g \\sin(\\theta_2) \\cos(\\theta_1 - \\theta_2)\n        - m_2 \\sin(\\theta_1 - \\theta_2) (l_1 z_1^2 \\cos(\\theta_1 - \\theta_2)\n        + l_2 z_2^2) - (m_1 + m_2) g \\sin(\\theta_1)}{l_1 (m_1\n        + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\\\\n        \\dot{z_2} &amp;= \\frac{(m_1 + m_2) (l_1 z_1^2 \\sin(\\theta_1 - \\theta_2)\n        - g \\sin(\\theta_2) + g \\sin(\\theta_1) \\cos(\\theta_1 - \\theta_2))\n        + m_2 l_2 z_2^2 \\sin(\\theta_1 - \\theta_2) \\cos(\\theta_1\n        - \\theta_2)}{l_2 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))}\n        \\end{align*}\n        $$\n\n        with $\\dot{\\theta_1} = z_1 \\\\$ and $\\dot{\\theta_2} = z_2$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        theta1 (float, optional): The initial angle of the first pendulum. Defaults to\n            pi / 2.\n        theta2 (float, optional): The initial angle of the second pendulum. Defaults to\n            pi / 2.\n        z1 (float, optional): The initial angular velocity of the first pendulum.\n            Defaults to 0.0.\n        z2 (float, optional): The initial angular velocity of the second pendulum.\n            Defaults to 0.0.\n        m1 (float, optional): The mass of the first pendulum. Defaults to 1.0.\n        m2 (float, optional): The mass of the second pendulum. Defaults to 1.0.\n        l1 (float, optional): The length of the first pendulum. Defaults to 1.0.\n        l2 (float, optional): The length of the second pendulum. Defaults to 1.0.\n        g (float, optional): The acceleration due to gravity. Defaults to 9.81.\n        velocity (bool, optional): Whether to return the velocity of the double\n            pendulum. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        theta1: float = pi / 2,\n        theta2: float = pi / 2,\n        z1: float = 0.0,\n        z2: float = 0.0,\n        m1: float = 1.0,\n        m2: float = 1.0,\n        l1: float = 1.0,\n        l2: float = 1.0,\n        g: float = g,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(\n            *t,\n            time_format=time_format,\n            velocity=velocity,\n        )\n        self.theta1 = theta1\n        self.theta2 = theta2\n        self.z1 = z1\n        self.z2 = z2\n        self.m1 = m1\n        self.m2 = m2\n        self.l1 = l1\n        self.l2 = l2\n        self.g = g\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the double pendulum.\n\n        Returns:\n            dict[str, float]: The initial configuration of the double pendulum.\n        \"\"\"\n        return OrderedDict(\n            sorted(\n                {\n                    \"theta1\": self.theta1,\n                    \"theta2\": self.theta2,\n                    \"z1\": self.z1,\n                    \"z2\": self.z2,\n                    \"m1\": self.m1,\n                    \"m2\": self.m2,\n                    \"l1\": self.l1,\n                    \"l2\": self.l2,\n                    \"g\": self.g,\n                }.items(),\n            ),\n        )\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the double pendulum.\n\n        Returns:\n            list[float]: The initial state of the double pendulum.\n        \"\"\"\n        return [self.theta1, self.z1, self.theta2, self.z2]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return the equation of motion of the double pendulum.\n\n        Args:\n            initial_state (list[float]): The initial state of the double pendulum.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float, float]: The equation of motion of the double\n                pendulum.\n        \"\"\"\n        theta1, z1, theta2, z2 = initial_state\n        c, s = np.cos(theta1 - theta2), np.sin(theta1 - theta2)\n\n        theta1_dot = z1\n        z1_dot = (\n            (\n                self.m2 * self.g * np.sin(theta2) * c\n                - self.m2 * s * (self.l1 * z1**2 * c + self.l2 * z2**2)\n                - (self.m1 + self.m2) * self.g * np.sin(theta1)\n            )\n            / self.l1\n            / (self.m1 + self.m2 * s**2)\n        )\n        theta2_dot = z2\n        z2_dot = (\n            (\n                (self.m1 + self.m2)\n                * (\n                    self.l1 * z1**2 * s\n                    - self.g * np.sin(theta2)\n                    + self.g * np.sin(theta1) * c\n                )\n                + self.m2 * self.l2 * z2**2 * s * c\n            )\n            / self.l2\n            / (self.m1 + self.m2 * s**2)\n        )\n        return theta1_dot, z1_dot, theta2_dot, z2_dot\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the double pendulum.\n\n        Returns:\n            UniversalArrayTuple: The position of the double pendulum.\n        \"\"\"\n        y = self.solve()\n        x1 = self.l1 * np.sin(y[:, 0])\n        y1 = -self.l1 * np.cos(y[:, 0])\n        x2 = x1 + self.l2 * np.sin(y[:, 2])\n        y2 = y1 - self.l2 * np.cos(y[:, 2])\n\n        return x1, y1, x2, y2\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the double pendulum.\n\n        Returns:\n            UniversalArrayTuple: The velocity of the double pendulum.\n        \"\"\"\n        y = self.solve()\n        vx1 = self.l1 * np.sin(y[:, 1])\n        vy1 = -self.l1 * np.cos(y[:, 1])\n        vx2 = vx1 + self.l2 * np.sin(y[:, 3])\n        vy2 = vy1 - self.l2 * np.cos(y[:, 3])\n\n        return vx1, vy1, vx2, vy2\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the double pendulum.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: The initial configuration of the double pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the double pendulum.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The initial state of the double pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.to_position","title":"<code>to_position</code>  <code>property</code>","text":"<p>Return the position of the double pendulum.</p> <p>Returns:</p> Name Type Description <code>UniversalArrayTuple</code> <code>UniversalArrayTuple</code> <p>The position of the double pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.to_velocity","title":"<code>to_velocity</code>  <code>property</code>","text":"<p>Return the velocity of the double pendulum.</p> <p>Returns:</p> Name Type Description <code>UniversalArrayTuple</code> <code>UniversalArrayTuple</code> <p>The velocity of the double pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.__init__","title":"<code>__init__(*t, time_format='seconds', theta1=pi / 2, theta2=pi / 2, z1=0.0, z2=0.0, m1=1.0, m2=1.0, l1=1.0, l2=1.0, g=g, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    theta1: float = pi / 2,\n    theta2: float = pi / 2,\n    z1: float = 0.0,\n    z2: float = 0.0,\n    m1: float = 1.0,\n    m2: float = 1.0,\n    l1: float = 1.0,\n    l2: float = 1.0,\n    g: float = g,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(\n        *t,\n        time_format=time_format,\n        velocity=velocity,\n    )\n    self.theta1 = theta1\n    self.theta2 = theta2\n    self.z1 = z1\n    self.z2 = z2\n    self.m1 = m1\n    self.m2 = m2\n    self.l1 = l1\n    self.l2 = l2\n    self.g = g\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoublePendulum.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the double pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of the double pendulum.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float]</code> <p>tuple[float, float, float, float]: The equation of motion of the double pendulum.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return the equation of motion of the double pendulum.\n\n    Args:\n        initial_state (list[float]): The initial state of the double pendulum.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float, float, float]: The equation of motion of the double\n            pendulum.\n    \"\"\"\n    theta1, z1, theta2, z2 = initial_state\n    c, s = np.cos(theta1 - theta2), np.sin(theta1 - theta2)\n\n    theta1_dot = z1\n    z1_dot = (\n        (\n            self.m2 * self.g * np.sin(theta2) * c\n            - self.m2 * s * (self.l1 * z1**2 * c + self.l2 * z2**2)\n            - (self.m1 + self.m2) * self.g * np.sin(theta1)\n        )\n        / self.l1\n        / (self.m1 + self.m2 * s**2)\n    )\n    theta2_dot = z2\n    z2_dot = (\n        (\n            (self.m1 + self.m2)\n            * (\n                self.l1 * z1**2 * s\n                - self.g * np.sin(theta2)\n                + self.g * np.sin(theta1) * c\n            )\n            + self.m2 * self.l2 * z2**2 * s * c\n        )\n        / self.l2\n        / (self.m1 + self.m2 * s**2)\n    )\n    return theta1_dot, z1_dot, theta2_dot, z2_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoubleSpringMassSystem","title":"<code>DoubleSpringMassSystem</code>","text":"<p>               Bases: <code>OscillatorsFunc2D</code></p> <p>Double Spring Mass System differential equation.</p> <p>The double spring mass system is a simple physical system that consists of two masses connected by springs. The motion of the masses is influenced by the spring constants and the values of the masses. The double spring mass system exhibits oscillatory behavior, and the motion of the masses is described by a set of coupled differential equations.</p> <p>About the Double Spring Mass System</p> <p>The current implementation of the double spring mass system is partially incorrect, because it allows that \\(m_2\\) can skip over \\(m_1\\).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoubleSpringMassSystem\n&gt;&gt;&gt; pendulum = DoubleSpringMassSystem(np.linspace(0, 100, 500))\n&gt;&gt;&gt; x1, x2 = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.set_ylim( min(x2) - 0.5, 0)\n&gt;&gt;&gt; _ = ax.set_xticks([])\n&gt;&gt;&gt; _ = ax.set_xticklabels([])\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Z\")\n&gt;&gt;&gt; (mass1,) = ax.plot([], [], \"ro\", lw=2)\n&gt;&gt;&gt; (mass2,) = ax.plot([], [], \"bo\", lw=2)\n&gt;&gt;&gt; (spring1,) = ax.plot([], [], \"k-\", lw=2)\n&gt;&gt;&gt; (spring2,) = ax.plot([], [], \"k-\", lw=2)\n&gt;&gt;&gt; def init():\n...     mass1.set_data([], [])\n...     mass2.set_data([], [])\n...     spring1.set_data([], [])\n...     spring2.set_data([], [])\n...     return mass1, mass2, spring1, spring2\n&gt;&gt;&gt; def update(frame):\n...     mass1.set_data([0], [x1[frame]])\n...     mass2.set_data([0], [x2[frame]])\n...     spring1.set_data([0, 0], [0, x1[frame]])\n...     spring2.set_data([0, 0], [x1[frame], x2[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return mass1, mass2, spring1, spring2\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('DoubleSpringMassSystem.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The double spring mass system differential equation is defined as:</p> \\[ \\begin{align*} \\ddot{x_1} &amp;= -\\frac{k_1}{m_1} x_1 - \\frac{k_2}{m_1} (x_1 - x_2) - g, \\\\ \\ddot{x_2} &amp;= -\\frac{k_2}{m_2} (x_2 - x_1) - g. \\end{align*} \\] <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>m1</code> <code>float</code> <p>The mass of the first spring. Defaults to 1.0.</p> <code>1.0</code> <code>m2</code> <code>float</code> <p>The mass of the second spring. Defaults to 1.0.</p> <code>1.0</code> <code>k1</code> <code>float</code> <p>The spring constant of the first spring. Defaults to 1.0.</p> <code>1.0</code> <code>k2</code> <code>float</code> <p>The spring constant of the second spring. Defaults to 1.0.</p> <code>1.0</code> <code>z1</code> <code>float</code> <p>The initial velocity of the first spring. Defaults to 0.0.</p> <code>0.0</code> <code>z2</code> <code>float</code> <p>The initial velocity of the second spring. Defaults to 1.0.</p> <code>-1.0</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the double spring mass system. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class DoubleSpringMassSystem(OscillatorsFunc2D):\n    r\"\"\"Double Spring Mass System differential equation.\n\n    The double spring mass system is a simple physical system that consists of two\n    masses connected by springs. The motion of the masses is influenced by the spring\n    constants and the values of the masses. The double spring mass system exhibits\n    oscillatory behavior, and the motion of the masses is described by a set of coupled\n    differential equations.\n\n    !!! warning \"About the Double Spring Mass System\"\n\n        The current implementation of the double spring mass system is partially\n        incorrect, because it allows that $m_2$ can skip over $m_1$.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoubleSpringMassSystem\n        &gt;&gt;&gt; pendulum = DoubleSpringMassSystem(np.linspace(0, 100, 500))\n        &gt;&gt;&gt; x1, x2 = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.set_ylim( min(x2) - 0.5, 0)\n        &gt;&gt;&gt; _ = ax.set_xticks([])\n        &gt;&gt;&gt; _ = ax.set_xticklabels([])\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Z\")\n        &gt;&gt;&gt; (mass1,) = ax.plot([], [], \"ro\", lw=2)\n        &gt;&gt;&gt; (mass2,) = ax.plot([], [], \"bo\", lw=2)\n        &gt;&gt;&gt; (spring1,) = ax.plot([], [], \"k-\", lw=2)\n        &gt;&gt;&gt; (spring2,) = ax.plot([], [], \"k-\", lw=2)\n        &gt;&gt;&gt; def init():\n        ...     mass1.set_data([], [])\n        ...     mass2.set_data([], [])\n        ...     spring1.set_data([], [])\n        ...     spring2.set_data([], [])\n        ...     return mass1, mass2, spring1, spring2\n        &gt;&gt;&gt; def update(frame):\n        ...     mass1.set_data([0], [x1[frame]])\n        ...     mass2.set_data([0], [x2[frame]])\n        ...     spring1.set_data([0, 0], [0, x1[frame]])\n        ...     spring2.set_data([0, 0], [x1[frame], x2[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return mass1, mass2, spring1, spring2\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('DoubleSpringMassSystem.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The double spring mass system differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\ddot{x_1} &amp;= -\\frac{k_1}{m_1} x_1 - \\frac{k_2}{m_1} (x_1 - x_2) - g, \\\\\n        \\ddot{x_2} &amp;= -\\frac{k_2}{m_2} (x_2 - x_1) - g.\n        \\end{align*}\n        $$\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        m1 (float, optional): The mass of the first spring. Defaults to 1.0.\n        m2 (float, optional): The mass of the second spring. Defaults to 1.0.\n        k1 (float, optional): The spring constant of the first spring. Defaults to 1.0.\n        k2 (float, optional): The spring constant of the second spring. Defaults to 1.0.\n        z1 (float, optional): The initial velocity of the first spring. Defaults to 0.0.\n        z2 (float, optional): The initial velocity of the second spring.\n            Defaults to 1.0.\n        velocity (bool, optional): Whether to return the velocity of the double\n            spring mass system. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        m1: float = 1.0,\n        m2: float = 1.0,\n        k1: float = 1.0,\n        k2: float = 1.0,\n        z1: float = 0.0,\n        z2: float = -1.0,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.m1 = m1\n        self.m2 = m2\n        self.k1 = k1\n        self.k2 = k2\n        self.z1 = z1\n        self.z2 = z2\n        self.g = g\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the double spring mass system.\"\"\"\n        return {\n            \"m1\": self.m1,\n            \"m2\": self.m2,\n            \"k1\": self.k1,\n            \"k2\": self.k2,\n            \"z1\": self.z1,\n            \"z2\": self.z2,\n            \"g\": self.g,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the double spring mass system.\"\"\"\n        return [self.z1, 0.0, self.z2, 0.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return the equation of motion of the double spring mass system.\"\"\"\n        x1, z1, x2, z2 = initial_state\n        x1_dot = z1\n        z1_dot = -self.k1 / self.m1 * x1 - self.k2 / self.m1 * (x1 - x2) - self.g\n        x2_dot = z2\n        z2_dot = -self.k2 / self.m2 * (x2 - x1) - self.g\n        return x1_dot, z1_dot, x2_dot, z2_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoubleSpringMassSystem.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the double spring mass system.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoubleSpringMassSystem.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the double spring mass system.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoubleSpringMassSystem.__init__","title":"<code>__init__(*t, time_format='seconds', m1=1.0, m2=1.0, k1=1.0, k2=1.0, z1=0.0, z2=-1.0, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    m1: float = 1.0,\n    m2: float = 1.0,\n    k1: float = 1.0,\n    k2: float = 1.0,\n    z1: float = 0.0,\n    z2: float = -1.0,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n    self.m1 = m1\n    self.m2 = m2\n    self.k1 = k1\n    self.k2 = k2\n    self.z1 = z1\n    self.z2 = z2\n    self.g = g\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DoubleSpringMassSystem.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the double spring mass system.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return the equation of motion of the double spring mass system.\"\"\"\n    x1, z1, x2, z2 = initial_state\n    x1_dot = z1\n    z1_dot = -self.k1 / self.m1 * x1 - self.k2 / self.m1 * (x1 - x2) - self.g\n    x2_dot = z2\n    z2_dot = -self.k2 / self.m2 * (x2 - x1) - self.g\n    return x1_dot, z1_dot, x2_dot, z2_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator","title":"<code>DuffingOscillator</code>","text":"<p>               Bases: <code>OscillatorsFunc2D</code></p> <p>Duffing Oscillator differential equation.</p> <p>The Duffing oscillator is a simple physical system that exhibits chaotic behavior. The Duffing oscillator consists of a mass attached to a spring and a damper. The motion of the mass is influenced by the spring constant, the damping coefficient, and the nonlinearity of the system. The Duffing oscillator exhibits chaotic behavior when the nonlinearity of the system is increased.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import DuffingOscillator\n&gt;&gt;&gt; pendulum = DuffingOscillator(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; (line,) = ax.plot([], [], lw=1, alpha=0.6)\n&gt;&gt;&gt; (dots,) = ax.plot([], [], \"ro\", markersize=2)\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     dots.set_data([], [])\n...     _ = ax.set_title(\"\")\n...     return line, dots\n&gt;&gt;&gt; def update(frame: int) -&gt; Tuple[Line2D, Line2D]:\n...     line.set_data(x[:frame], y[:frame])\n...     dots.set_data(x[:frame], y[:frame])\n...     ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, dots\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('DuffingOscillator.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Duffing oscillator differential equation is defined as:</p> \\[ \\begin{align*} \\ddot{x} + \\delta \\dot{x} + \\alpha x + \\beta x^3 &amp;= \\gamma \\cos(\\omega t), \\\\ \\dot{x} &amp;= y. \\end{align*} \\] Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class DuffingOscillator(OscillatorsFunc2D):\n    r\"\"\"Duffing Oscillator differential equation.\n\n    The Duffing oscillator is a simple physical system that exhibits chaotic behavior.\n    The Duffing oscillator consists of a mass attached to\n    a spring and a damper. The motion of the mass is influenced by the spring constant,\n    the damping coefficient, and the nonlinearity of the system. The Duffing oscillator\n    exhibits chaotic behavior when the nonlinearity of the system is increased.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import DuffingOscillator\n        &gt;&gt;&gt; pendulum = DuffingOscillator(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; (line,) = ax.plot([], [], lw=1, alpha=0.6)\n        &gt;&gt;&gt; (dots,) = ax.plot([], [], \"ro\", markersize=2)\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     dots.set_data([], [])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, dots\n        &gt;&gt;&gt; def update(frame: int) -&gt; Tuple[Line2D, Line2D]:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     dots.set_data(x[:frame], y[:frame])\n        ...     ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, dots\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('DuffingOscillator.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Duffing oscillator differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\ddot{x} + \\delta \\dot{x} + \\alpha x + \\beta x^3 &amp;= \\gamma \\cos(\\omega t), \\\\\n        \\dot{x} &amp;= y.\n        \\end{align*}\n        $$\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        alpha (float, optional): The alpha parameter of the Duffing oscillator.\n            Defaults to -1.0.\n        beta (float, optional): The beta parameter of the Duffing oscillator.\n            Defaults to 1.0.\n        delta (float, optional): The delta parameter of the Duffing oscillator.\n            Defaults to 0.2.\n        gamma (float, optional): The gamma parameter of the Duffing oscillator.\n            Defaults to 0.3.\n        omega (float, optional): The omega parameter of the Duffing oscillator.\n            Defaults to 1.2.\n        velocity (bool, optional): Whether to return the velocity of the Duffing\n            oscillator. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        alpha: float = -1.0,\n        beta: float = 1.0,\n        delta: float = 0.2,\n        gamma: float = 0.3,\n        omega: float = 1.2,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.alpha = alpha\n        self.beta = beta\n        self.delta = delta\n        self.gamma = gamma\n        self.omega = omega\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Duffing oscillator.\"\"\"\n        return {\n            \"alpha\": self.alpha,\n            \"beta\": self.beta,\n            \"delta\": self.delta,\n            \"gamma\": self.gamma,\n            \"omega\": self.omega,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Duffing oscillator.\"\"\"\n        return [0.0, 1.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,\n    ) -&gt; tuple[float, float]:\n        \"\"\"Return the equation of motion of the Duffing oscillator.\n\n        Args:\n            initial_state (list[float]): The initial state of the Duffing oscillator.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float]: The equation of motion of the Duffing oscillator.\n        \"\"\"\n        x, y = initial_state\n        x_dot = y\n        y_dot = (\n            self.gamma * np.cos(self.omega * t)\n            - self.alpha * x\n            - self.beta * x**3\n            - self.delta * y\n        )\n        return x_dot, y_dot\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the Duffing oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 0], y[:, 1]\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the Duffing oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 2], y[:, 3]\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the Duffing oscillator.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the Duffing oscillator.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.to_position","title":"<code>to_position</code>  <code>property</code>","text":"<p>Return the position of the Duffing oscillator.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.to_velocity","title":"<code>to_velocity</code>  <code>property</code>","text":"<p>Return the velocity of the Duffing oscillator.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.__init__","title":"<code>__init__(*t, time_format='seconds', alpha=-1.0, beta=1.0, delta=0.2, gamma=0.3, omega=1.2, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    alpha: float = -1.0,\n    beta: float = 1.0,\n    delta: float = 0.2,\n    gamma: float = 0.3,\n    omega: float = 1.2,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n    self.alpha = alpha\n    self.beta = beta\n    self.delta = delta\n    self.gamma = gamma\n    self.omega = omega\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.DuffingOscillator.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the Duffing oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of the Duffing oscillator.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: The equation of motion of the Duffing oscillator.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,\n) -&gt; tuple[float, float]:\n    \"\"\"Return the equation of motion of the Duffing oscillator.\n\n    Args:\n        initial_state (list[float]): The initial state of the Duffing oscillator.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float]: The equation of motion of the Duffing oscillator.\n    \"\"\"\n    x, y = initial_state\n    x_dot = y\n    y_dot = (\n        self.gamma * np.cos(self.omega * t)\n        - self.alpha * x\n        - self.beta * x**3\n        - self.delta * y\n    )\n    return x_dot, y_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.LorenzAttractor","title":"<code>LorenzAttractor</code>","text":"<p>               Bases: <code>OscillatorsFunc3D</code></p> <p>Lorenz Attractor differential equation.</p> <p>The Lorenz attractor is a set of differential equations that exhibit chaotic behavior. The Lorenz attractor consists of three coupled differential equations that describe the motion of a system in a simplified model of atmospheric convection.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import LorenzAttractor\n&gt;&gt;&gt; pendulum = LorenzAttractor(np.linspace(0, 20, 1000))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     _ = ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('LorenzAttractor.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Lorenz attractor differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= \\sigma (y - x), \\\\ \\dot{y} &amp;= x (\\rho - z) - y, \\\\ \\dot{z} &amp;= x y - \\beta z. \\end{align*} \\] <p>with the parameters of the system are as follows: $ sigma$ is the Prandtl number, which describes the ratio of momentum diffusivity to thermal diffusivity, while  rho $ is the Rayleigh number, which describes the difference in temperature between the top and bottom of the fluid layer. Finally, the $ beta $ is a geometric factor related to the physical dimensions of the system.</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>rho</code> <code>float</code> <p>The rho parameter of the Lorenz attractor. Defaults to 28.0.</p> <code>28.0</code> <code>sigma</code> <code>float</code> <p>The sigma parameter of the Lorenz attractor. Defaults to 10.0.</p> <code>10.0</code> <code>beta</code> <code>float</code> <p>The beta parameter of the Lorenz attractor. Defaults to 8/3.</p> <code>8 / 3</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the Lorenz attractor. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class LorenzAttractor(OscillatorsFunc3D):\n    r\"\"\"Lorenz Attractor differential equation.\n\n    The Lorenz attractor is a set of differential equations that exhibit chaotic\n    behavior. The Lorenz attractor consists of three coupled differential\n    equations that describe the motion of a system in a simplified model of atmospheric\n    convection.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import LorenzAttractor\n        &gt;&gt;&gt; pendulum = LorenzAttractor(np.linspace(0, 20, 1000))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('LorenzAttractor.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Lorenz attractor differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= \\sigma (y - x), \\\\\n        \\dot{y} &amp;= x (\\rho - z) - y, \\\\\n        \\dot{z} &amp;= x y - \\beta z.\n        \\end{align*}\n        $$\n\n        with the parameters of the system are as follows: $ \\sigma$ is the Prandtl\n        number, which describes the ratio of momentum diffusivity to thermal\n        diffusivity, while  \\rho $ is the Rayleigh number, which describes\n        the difference in temperature between the top and bottom of the fluid layer.\n        Finally, the $ \\beta $ is a geometric factor related to the physical dimensions\n        of the system.\n\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        rho (float, optional): The rho parameter of the Lorenz attractor. Defaults to\n            28.0.\n        sigma (float, optional): The sigma parameter of the Lorenz attractor. Defaults\n            to 10.0.\n        beta (float, optional): The beta parameter of the Lorenz attractor. Defaults to\n            8/3.\n        velocity (bool, optional): Whether to return the velocity of the Lorenz\n            attractor. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        rho: float = 28.0,\n        sigma: float = 10.0,\n        beta: float = 8 / 3,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.rho = rho\n        self.sigma = sigma\n        self.beta = beta\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Lorenz attractor.\"\"\"\n        return {\"rho\": self.rho, \"sigma\": self.sigma, \"beta\": self.beta}\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Lorenz attractor.\"\"\"\n        return [1.0, 1.0, 1.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of the Lorenz attractor.\n\n        Args:\n            initial_state (list[float]): The initial state of the Lorenz attractor.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of the Lorenz attractor.\n        \"\"\"\n        x, y, z = initial_state\n        x_dot = self.sigma * (y - x)\n        y_dot = x * (self.rho - z) - y\n        z_dot = x * y - self.beta * z\n        return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.LorenzAttractor.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the Lorenz attractor.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.LorenzAttractor.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the Lorenz attractor.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.LorenzAttractor.__init__","title":"<code>__init__(*t, time_format='seconds', rho=28.0, sigma=10.0, beta=8 / 3, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    rho: float = 28.0,\n    sigma: float = 10.0,\n    beta: float = 8 / 3,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n    self.rho = rho\n    self.sigma = sigma\n    self.beta = beta\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.LorenzAttractor.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the Lorenz attractor.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of the Lorenz attractor.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The equation of motion of the Lorenz attractor.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float]:\n    \"\"\"Return the equation of motion of the Lorenz attractor.\n\n    Args:\n        initial_state (list[float]): The initial state of the Lorenz attractor.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float, float]: The equation of motion of the Lorenz attractor.\n    \"\"\"\n    x, y, z = initial_state\n    x_dot = self.sigma * (y - x)\n    y_dot = x * (self.rho - z) - y\n    z_dot = x * y - self.beta * z\n    return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum","title":"<code>MagneticPendulum</code>","text":"<p>               Bases: <code>OscillatorsFuncBase</code></p> <p>Magnetic Pendulum differential equation.</p> <p>The magnetic pendulum is an intriguing physical system that exhibits chaotic behavior when subjected to magnetic fields. It consists of a pendulum bob influenced by the magnetic fields of several surrounding magnets. The motion of the pendulum bob is affected by these magnetic fields, and the chaotic behavior is further enhanced by the presence of magnets with both north and south poles.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import MagneticPendulum\n&gt;&gt;&gt; pendulum = MagneticPendulum(np.linspace(0, 2.5, 500))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; magnet_x, magnet_y, _ = zip(*pendulum.magnets, strict=True)\n&gt;&gt;&gt; _ = ax.scatter(magnet_x, magnet_y, marker=\"x\")\n&gt;&gt;&gt; scat = ax.scatter([], [], cmap=\"viridis\", s=10)\n&gt;&gt;&gt; (line,) = ax.plot([], [], linestyle=\"dashed\", color=\"grey\", alpha=0.6)\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; def init():\n...     scat.set_offsets([])\n...     line.set_data([], [])\n...     return scat, line\n&gt;&gt;&gt; def update(frame):\n...     start = max(0, frame - 50)\n...     scat.set_offsets(np.c_[x[start:frame], y[start:frame]])\n...     line.set_data(x[:frame], y[:frame])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return scat, line\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=len(t), interval=10, blit=True)\n&gt;&gt;&gt; ani.save('MagneticPendulum.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The magnetic pendulum differential equation is defined as:</p> \\[ \\begin{align*} \\frac{d\\omega_\\theta}{dt} &amp;= -\\frac{g}{l} \\sin(\\theta) + \\frac{1}{m \\cdot l} \\left( f_{mx} \\cos(\\theta) \\cos(\\phi) + f_{my} \\cos(\\theta) \\sin(\\phi) + f_{mz} \\sin(\\theta) \\right), \\\\ \\frac{d\\omega_\\phi}{dt} &amp;= \\frac{1}{m \\cdot l \\sin(\\theta)} \\left( f_{mx} \\sin(\\phi) - f_{my} \\cos(\\phi) \\right). \\end{align*} \\] <p>with \\(\\frac{d\\theta}{dt} = \\omega_\\theta\\) and \\(\\frac{d\\phi}{dt} = \\omega_\\phi\\), while components of the magnetic force \\(((f_{mx}, f_{my}, f_{mz}))\\) are calculated as follows:</p> \\[ \\begin{align*} f_{mx} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (x - x_i)}{d_i^3}, \\\\ f_{my} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (y - y_i)}{d_i^3}, \\\\ f_{mz} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot z}{d_i^3}, \\end{align*} \\] <p>with \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2 + z^2}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>l</code> <code>float</code> <p>The length of the pendulum. Defaults to 2.</p> <code>2</code> <code>m</code> <code>float</code> <p>The mass of the pendulum. Defaults to 0.5.</p> <code>0.5</code> <code>x0</code> <code>float</code> <p>The initi`al x-coordinate of the pendulum bob. Defaults to 0.5.</p> <code>0.5</code> <code>y0</code> <code>float</code> <p>The initial y-coordinate of the pendulum bob. Defaults to 0.5.</p> <code>0.5</code> <code>theta</code> <code>float</code> <p>The initial angle theta of the pendulum. Defaults to pi/4.</p> <code>pi / 4</code> <code>phi</code> <code>float</code> <p>The initial angle phi of the pendulum. Defaults to pi/2.</p> <code>pi / 2</code> <code>magnetic_constant</code> <code>float</code> <p>The magnetic constant. Defaults to 1.0e10.</p> <code>10000000000.0</code> <code>magnets</code> <code>list[tuple[float, float, int]]</code> <p>A list of magnets, each defined by a tuple of (x, y, pole). Defaults to None.</p> <code>None</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the magnetic pendulum. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class MagneticPendulum(OscillatorsFuncBase):\n    r\"\"\"Magnetic Pendulum differential equation.\n\n    The magnetic pendulum is an intriguing physical system that exhibits chaotic\n    behavior when subjected to magnetic fields. It consists of a pendulum bob influenced\n    by the magnetic fields of several surrounding magnets. The motion of the pendulum\n    bob is affected by these magnetic fields, and the chaotic behavior is further\n    enhanced by the presence of magnets with both north and south poles.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import MagneticPendulum\n        &gt;&gt;&gt; pendulum = MagneticPendulum(np.linspace(0, 2.5, 500))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; magnet_x, magnet_y, _ = zip(*pendulum.magnets, strict=True)\n        &gt;&gt;&gt; _ = ax.scatter(magnet_x, magnet_y, marker=\"x\")\n        &gt;&gt;&gt; scat = ax.scatter([], [], cmap=\"viridis\", s=10)\n        &gt;&gt;&gt; (line,) = ax.plot([], [], linestyle=\"dashed\", color=\"grey\", alpha=0.6)\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; def init():\n        ...     scat.set_offsets([])\n        ...     line.set_data([], [])\n        ...     return scat, line\n        &gt;&gt;&gt; def update(frame):\n        ...     start = max(0, frame - 50)\n        ...     scat.set_offsets(np.c_[x[start:frame], y[start:frame]])\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return scat, line\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=len(t), interval=10, blit=True)\n        &gt;&gt;&gt; ani.save('MagneticPendulum.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The magnetic pendulum differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\frac{d\\omega_\\theta}{dt} &amp;= -\\frac{g}{l} \\sin(\\theta) + \\frac{1}{m \\cdot l}\n        \\left( f_{mx} \\cos(\\theta) \\cos(\\phi) + f_{my} \\cos(\\theta) \\sin(\\phi)\n        + f_{mz} \\sin(\\theta) \\right), \\\\\n        \\frac{d\\omega_\\phi}{dt} &amp;= \\frac{1}{m \\cdot l \\sin(\\theta)} \\left( f_{mx}\n        \\sin(\\phi) - f_{my} \\cos(\\phi) \\right).\n        \\end{align*}\n        $$\n\n        with $\\frac{d\\theta}{dt} = \\omega_\\theta$ and\n        $\\frac{d\\phi}{dt} = \\omega_\\phi$, while components of the magnetic force\n        $((f_{mx}, f_{my}, f_{mz}))$ are calculated as follows:\n\n        $$\n        \\begin{align*}\n        f_{mx} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (x - x_i)}{d_i^3}, \\\\\n        f_{my} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (y - y_i)}{d_i^3}, \\\\\n        f_{mz} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot z}{d_i^3},\n        \\end{align*}\n        $$\n\n        with $d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2 + z^2}$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        l (float, optional): The length of the pendulum. Defaults to 2.\n        m (float, optional): The mass of the pendulum. Defaults to 0.5.\n        x0 (float, optional): The initi`al x-coordinate of the pendulum bob. Defaults\n            to 0.5.\n        y0 (float, optional): The initial y-coordinate of the pendulum bob. Defaults\n            to 0.5.\n        theta (float, optional): The initial angle theta of the pendulum. Defaults to\n            pi/4.\n        phi (float, optional): The initial angle phi of the pendulum. Defaults to pi/2.\n        magnetic_constant (float, optional): The magnetic constant. Defaults to 1.0e10.\n        magnets (list[tuple[float, float, int]], optional): A list of magnets, each\n            defined by a tuple of (x, y, pole). Defaults to None.\n        velocity (bool, optional): Whether to return the velocity of the magnetic\n            pendulum. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        l: float = 2,  # noqa: E741\n        m: float = 0.5,\n        x0: float = 0.5,\n        y0: float = 0.5,\n        theta: float = pi / 4,\n        phi: float = pi / 2,\n        magnetic_constant: float = 1.0e10,\n        magnets: list[tuple[float, float, int]] | None = None,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.l = l\n        self.m = m\n        self.x0 = x0\n        self.y0 = y0\n        self.theta = theta\n        self.phi = phi\n        self.magnetic_constant = magnetic_constant\n        self.magnets: list[tuple[float, float, int]] = (\n            magnets\n            if magnets is not None\n            else [\n                (1.0, 1.0, +1),\n                (-1.0, 1.0, +1),\n                (-1.0, -1.0, +1),\n                (1.0, -1.0, +1),\n                (0.5, 0.5, -1),\n                (-0.5, 0.5, -1),\n                (-0.5, -0.5, -1),\n                (0.5, -0.5, -1),\n            ]\n        )\n\n    @property\n    def __initial_configuration__(\n        self,\n    ) -&gt; dict[str, float | list[tuple[float, float, int]]]:\n        \"\"\"Return the initial configuration of the pendulum.\"\"\"\n        return {\n            \"l\": self.l,\n            \"m\": self.m,\n            \"x0\": self.x0,\n            \"y0\": self.y0,\n            \"theta\": self.theta,\n            \"phi\": self.phi,\n            \"magnetic_constant\": self.magnetic_constant,\n            \"magnets\": self.magnets,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the pendulum.\"\"\"\n        return [self.theta, self.phi, self.x0, self.y0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return the equation of motion of the magnetic pendulum.\n\n        Args:\n            initial_state (list[float]): The initial state of the magnetic pendulum.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float, float]: The equation of motion of the magnetic\n                pendulum.\n        \"\"\"\n        theta, phi, omega_theta, omega_phi = initial_state\n        x = self.l * np.sin(theta) * np.cos(phi)\n        y = self.l * np.sin(theta) * np.sin(phi)\n        z = -self.l * np.cos(theta)\n        f_mx, f_my, f_mz = self.magnetic_force(x, y, z)\n\n        dtheta_dt = omega_theta\n        dphi_dt = omega_phi\n        domega_theta_dt = -(g / self.l) * np.sin(theta) + (\n            f_mx * np.cos(theta) * np.cos(phi)\n            + f_my * np.cos(theta) * np.sin(phi)\n            + f_mz * np.sin(theta)\n        ) / (self.m * self.l)\n        domega_phi_dt = (f_mx * np.sin(phi) - f_my * np.cos(phi)) / (\n            self.m * self.l * np.sin(theta)\n        )\n\n        return dtheta_dt, dphi_dt, domega_theta_dt, domega_phi_dt\n\n    def magnetic_force(\n        self,\n        x: UniversalArray,\n        y: UniversalArray,\n        z: UniversalArray,\n    ) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the magnetic force on the pendulum bob.\n\n        Args:\n            x (UniversalArray): The x-coordinate of the pendulum bob.\n            y (UniversalArray): The y-coordinate of the pendulum bob.\n            z (UniversalArray): The z-coordinate of the pendulum bob.\n\n        Returns:\n            UniversalArrayTuple: The magnetic force on the pendulum bob.\n        \"\"\"\n        f_mx, f_my, f_mz = 0.0, 0.0, 0.0\n        for x_m, y_m, pole in self.magnets:\n            d = np.sqrt((x - x_m) ** 2 + (y - y_m) ** 2 + z**2)\n            if d != 0:\n                force_magnitude = self.magnetic_constant * mu_0 * pole / d**2\n                f_mx += force_magnitude * (x - x_m) / d\n                f_my += force_magnitude * (y - y_m) / d\n                f_mz += force_magnitude * z / d\n        return f_mx, f_my, f_mz\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the 3D position of the pendulum bob.\"\"\"\n        y = self.solve()\n        x1 = self.l * np.sin(y[:, 0]) * np.cos(y[:, 1])\n        y1 = self.l * np.sin(y[:, 0]) * np.sin(y[:, 1])\n        z1 = -self.l * np.cos(y[:, 0])\n        return x1, y1, z1\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the 3D velocity of the pendulum bob.\"\"\"\n        y = self.solve()\n        vx = self.l * y[:, 2] * np.cos(y[:, 0]) * np.cos(y[:, 1])\n        vy = self.l * y[:, 2] * np.sin(y[:, 0]) * np.sin(y[:, 1])\n        vz = self.l * y[:, 2] * np.sin(y[:, 0])\n        return vx, vy, vz\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the pendulum.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.to_position","title":"<code>to_position</code>  <code>property</code>","text":"<p>Compute the 3D position of the pendulum bob.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.to_velocity","title":"<code>to_velocity</code>  <code>property</code>","text":"<p>Compute the 3D velocity of the pendulum bob.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.__init__","title":"<code>__init__(*t, time_format='seconds', l=2, m=0.5, x0=0.5, y0=0.5, theta=pi / 4, phi=pi / 2, magnetic_constant=10000000000.0, magnets=None, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    l: float = 2,  # noqa: E741\n    m: float = 0.5,\n    x0: float = 0.5,\n    y0: float = 0.5,\n    theta: float = pi / 4,\n    phi: float = pi / 2,\n    magnetic_constant: float = 1.0e10,\n    magnets: list[tuple[float, float, int]] | None = None,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n    self.l = l\n    self.m = m\n    self.x0 = x0\n    self.y0 = y0\n    self.theta = theta\n    self.phi = phi\n    self.magnetic_constant = magnetic_constant\n    self.magnets: list[tuple[float, float, int]] = (\n        magnets\n        if magnets is not None\n        else [\n            (1.0, 1.0, +1),\n            (-1.0, 1.0, +1),\n            (-1.0, -1.0, +1),\n            (1.0, -1.0, +1),\n            (0.5, 0.5, -1),\n            (-0.5, 0.5, -1),\n            (-0.5, -0.5, -1),\n            (0.5, -0.5, -1),\n        ]\n    )\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the magnetic pendulum.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of the magnetic pendulum.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float]</code> <p>tuple[float, float, float, float]: The equation of motion of the magnetic pendulum.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float, float]:\n    \"\"\"Return the equation of motion of the magnetic pendulum.\n\n    Args:\n        initial_state (list[float]): The initial state of the magnetic pendulum.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float, float, float]: The equation of motion of the magnetic\n            pendulum.\n    \"\"\"\n    theta, phi, omega_theta, omega_phi = initial_state\n    x = self.l * np.sin(theta) * np.cos(phi)\n    y = self.l * np.sin(theta) * np.sin(phi)\n    z = -self.l * np.cos(theta)\n    f_mx, f_my, f_mz = self.magnetic_force(x, y, z)\n\n    dtheta_dt = omega_theta\n    dphi_dt = omega_phi\n    domega_theta_dt = -(g / self.l) * np.sin(theta) + (\n        f_mx * np.cos(theta) * np.cos(phi)\n        + f_my * np.cos(theta) * np.sin(phi)\n        + f_mz * np.sin(theta)\n    ) / (self.m * self.l)\n    domega_phi_dt = (f_mx * np.sin(phi) - f_my * np.cos(phi)) / (\n        self.m * self.l * np.sin(theta)\n    )\n\n    return dtheta_dt, dphi_dt, domega_theta_dt, domega_phi_dt\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.MagneticPendulum.magnetic_force","title":"<code>magnetic_force(x, y, z)</code>","text":"<p>Compute the magnetic force on the pendulum bob.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The x-coordinate of the pendulum bob.</p> required <code>y</code> <code>UniversalArray</code> <p>The y-coordinate of the pendulum bob.</p> required <code>z</code> <code>UniversalArray</code> <p>The z-coordinate of the pendulum bob.</p> required <p>Returns:</p> Name Type Description <code>UniversalArrayTuple</code> <code>UniversalArrayTuple</code> <p>The magnetic force on the pendulum bob.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def magnetic_force(\n    self,\n    x: UniversalArray,\n    y: UniversalArray,\n    z: UniversalArray,\n) -&gt; UniversalArrayTuple:\n    \"\"\"Compute the magnetic force on the pendulum bob.\n\n    Args:\n        x (UniversalArray): The x-coordinate of the pendulum bob.\n        y (UniversalArray): The y-coordinate of the pendulum bob.\n        z (UniversalArray): The z-coordinate of the pendulum bob.\n\n    Returns:\n        UniversalArrayTuple: The magnetic force on the pendulum bob.\n    \"\"\"\n    f_mx, f_my, f_mz = 0.0, 0.0, 0.0\n    for x_m, y_m, pole in self.magnets:\n        d = np.sqrt((x - x_m) ** 2 + (y - y_m) ** 2 + z**2)\n        if d != 0:\n            force_magnitude = self.magnetic_constant * mu_0 * pole / d**2\n            f_mx += force_magnitude * (x - x_m) / d\n            f_my += force_magnitude * (y - y_m) / d\n            f_mz += force_magnitude * z / d\n    return f_mx, f_my, f_mz\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.RoesslerAttractor","title":"<code>RoesslerAttractor</code>","text":"<p>               Bases: <code>OscillatorsFunc3D</code></p> <p>Roessler Attractor differential equation.</p> <p>The Roessler attractor is a set of differential equations that exhibit chaotic behavior. The Roessler attractor consists of three coupled differential equations that describe the motion of a system in a simplified model of atmospheric convection.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import RoesslerAttractor\n&gt;&gt;&gt; pendulum = RoesslerAttractor(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     _ = ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('RoesslerAttractor.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Roessler attractor differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= -y - z, \\\\ \\dot{y} &amp;= x + a y, \\\\ \\dot{z} &amp;= b + z (x - c). \\end{align*} \\] Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class RoesslerAttractor(OscillatorsFunc3D):\n    r\"\"\"Roessler Attractor differential equation.\n\n    The Roessler attractor is a set of differential equations that exhibit chaotic\n    behavior. The Roessler attractor consists of three coupled differential equations\n    that describe the motion of a system in a simplified model of atmospheric\n    convection.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import RoesslerAttractor\n        &gt;&gt;&gt; pendulum = RoesslerAttractor(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('RoesslerAttractor.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Roessler attractor differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= -y - z, \\\\\n        \\dot{y} &amp;= x + a y, \\\\\n        \\dot{z} &amp;= b + z (x - c).\n        \\end{align*}\n        $$\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        a (float, optional): The a parameter of the Roessler attractor. Defaults to 0.2.\n        b (float, optional): The b parameter of the Roessler attractor. Defaults to 0.2.\n        c (float, optional): The c parameter of the Roessler attractor. Defaults to 5.7.\n        velocity (bool, optional): Whether to return the velocity of the Roessler\n            attractor. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        a: float = 0.2,\n        b: float = 0.2,\n        c: float = 5.7,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Roessler attractor.\"\"\"\n        return {\"a\": self.a, \"b\": self.b, \"c\": self.c}\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Roessler attractor.\"\"\"\n        return [0.1, 0.0, 0.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of the Roessler attractor.\n\n        Args:\n            initial_state (list[float]): The initial state of the Roessler attractor.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of the Roessler\n                attractor.\n        \"\"\"\n        x, y, z = initial_state\n        x_dot = -y - z\n        y_dot = x + self.a * y\n        z_dot = self.b + z * (x - self.c)\n        return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.RoesslerAttractor.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>property</code>","text":"<p>Return the initial configuration of the Roessler attractor.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.RoesslerAttractor.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Return the initial state of the Roessler attractor.</p>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.RoesslerAttractor.__init__","title":"<code>__init__(*t, time_format='seconds', a=0.2, b=0.2, c=5.7, velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def __init__(\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    a: float = 0.2,\n    b: float = 0.2,\n    c: float = 5.7,\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*t, time_format=time_format, velocity=velocity)\n    self.a = a\n    self.b = b\n    self.c = c\n</code></pre>"},{"location":"modules/api/chaotic_systems/#umf.functions.chaotic.oscillators.RoesslerAttractor.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>","text":"<p>Return the equation of motion of the Roessler attractor.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>list[float]</code> <p>The initial state of the Roessler attractor.</p> required <code>t</code> <code>UniversalArray</code> <p>The time array.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: The equation of motion of the Roessler attractor.</p> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>def equation_of_motion(\n    self,\n    initial_state: list[float],\n    t: UniversalArray,  # noqa: ARG002\n) -&gt; tuple[float, float, float]:\n    \"\"\"Return the equation of motion of the Roessler attractor.\n\n    Args:\n        initial_state (list[float]): The initial state of the Roessler attractor.\n        t (UniversalArray): The time array.\n\n    Returns:\n        tuple[float, float, float]: The equation of motion of the Roessler\n            attractor.\n    \"\"\"\n    x, y, z = initial_state\n    x_dot = -y - z\n    y_dot = x + self.a * y\n    z_dot = self.b + z * (x - self.c)\n    return x_dot, y_dot, z_dot\n</code></pre>"},{"location":"modules/api/data_generation/","title":"Modules","text":"<p>Create math function and plot it.</p>"},{"location":"modules/api/data_generation/#umf.core.create.Borg","title":"<code>Borg</code>","text":"<p>Borg class for functions.</p> <p>About Borg</p> <p>This class is used to create shared states for math functions. It uses the Borg design pattern to ensure that all instances of a math function share the same state. The shared state is stored in the <code>shared_state</code> dictionary, while the shared result and plot are stored in the <code>shared_result</code> and <code>shared_plot</code> dictionaries, respectively.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class Borg:\n    \"\"\"Borg class for functions.\n\n    !!! info \"About Borg\"\n\n        This class is used to create shared states for math functions. It uses the\n        Borg design pattern to ensure that all instances of a math function share the\n        same state. The shared state is stored in the `shared_state` dictionary, while\n        the shared result and plot are stored in the `shared_result` and `shared_plot`\n        dictionaries, respectively.\n    \"\"\"\n\n    shared_state: ClassVar[dict[str, Any]] = {}\n    shared_result: ClassVar[dict[str, Any]] = {}\n    shared_plot: ClassVar[dict[str, Any]] = {}\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize shared states of math function.\"\"\"\n        self.__dict__ = self.shared_state\n\n    def auto_cleanup(self) -&gt; None:\n        \"\"\"Auto clean up shared states of math function.\"\"\"\n        Borg.shared_state = {} if Borg.shared_state else Borg.shared_state\n        Borg.shared_result = {} if Borg.shared_result else Borg.shared_result\n        Borg.shared_plot = {} if Borg.shared_plot else Borg.shared_plot\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.Borg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize shared states of math function.\"\"\"\n    self.__dict__ = self.shared_state\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.Borg.auto_cleanup","title":"<code>auto_cleanup()</code>","text":"<p>Auto clean up shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def auto_cleanup(self) -&gt; None:\n    \"\"\"Auto clean up shared states of math function.\"\"\"\n    Borg.shared_state = {} if Borg.shared_state else Borg.shared_state\n    Borg.shared_result = {} if Borg.shared_result else Borg.shared_result\n    Borg.shared_plot = {} if Borg.shared_plot else Borg.shared_plot\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg","title":"<code>FunctionBorg</code>","text":"<p>               Bases: <code>Borg</code></p> <p>A class that initializes shared states of math functions.</p> <p>Attributes: _x (UniversalArray): Arguments to be passed to the math function. func_name (list[str] | str): Name of the math function(s) to be called. func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments to be     passed to the math function(s), by default None. shared_state (dict[str, Any]): Shared states of math function.</p> <p>Methods: init(*x: UniversalArray, func_name: list[str] | str, func_args: list[dict[str, Any]] | dict[str, Any] | None = None) -&gt; None:     Initializes shared states of math functions. initialize_borg() -&gt; None:     Initialize shared states of math function. return_borg() -&gt; dict[str, Any]:     Return shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class FunctionBorg(Borg):\n    \"\"\"A class that initializes shared states of math functions.\n\n    Attributes:\n    _x (UniversalArray): Arguments to be passed to the math function.\n    func_name (list[str] | str): Name of the math function(s) to be called.\n    func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments to be\n        passed to the math function(s), by default None.\n    shared_state (dict[str, Any]): Shared states of math function.\n\n    Methods:\n    __init__(*x: UniversalArray, func_name: list[str] | str, func_args: list[dict[str,\n    Any]] | dict[str, Any] | None = None) -&gt; None:\n        Initializes shared states of math functions.\n    initialize_borg() -&gt; None:\n        Initialize shared states of math function.\n    return_borg() -&gt; dict[str, Any]:\n        Return shared states of math function.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        func_name: list[str] | str,\n        func_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes shared states of math functions.\n\n        Args:\n        *x: UniversalArray\n            Arguments to be passed to the math function.\n        func_name: list[str] | str\n            Name of the math function(s) to be called.\n        func_args: list[dict[str, Any]] | dict[str, Any] | None, optional\n            Arguments to be passed to the math function(s), by default None.\n        \"\"\"\n        super().__init__()\n\n        self._x: tuple[UniversalArray, ...] = x\n        func_args = func_args or [{} for _ in range(len(func_name))]\n        self.func_args = [func_args] if isinstance(func_args, dict) else func_args\n        self.func_name = [func_name] if isinstance(func_name, str) else func_name\n        self.initialize_borg()\n\n    def initialize_borg(self) -&gt; None:\n        \"\"\"Initialize shared states of math function.\"\"\"\n        for name, args in zip(self.func_name, self.func_args, strict=True):\n            try:\n                func: Callable[[Any], Any] = getattr(core, name)\n            except AttributeError as exc:\n                msg = f\"Unknown function '{name}'\"\n                raise AttributeError(msg) from exc\n            try:\n                self.shared_state[name] = func(*self._x, **args)()\n            except TypeError as exc:\n                msg = f\"Function '{name}' has invalid arguments\"\n                raise TypeError(msg) from exc\n\n    @property\n    def return_borg(self) -&gt; dict[str, Any]:\n        \"\"\"Return shared states of math function.\"\"\"\n        return self.shared_state\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.return_borg","title":"<code>return_borg</code>  <code>property</code>","text":"<p>Return shared states of math function.</p>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.__init__","title":"<code>__init__(*x, func_name, func_args=None)</code>","text":"<p>Initializes shared states of math functions.</p> <p>*x: UniversalArray     Arguments to be passed to the math function. func_name: list[str] | str     Name of the math function(s) to be called. func_args: list[dict[str, Any]] | dict[str, Any] | None, optional     Arguments to be passed to the math function(s), by default None.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    func_name: list[str] | str,\n    func_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Initializes shared states of math functions.\n\n    Args:\n    *x: UniversalArray\n        Arguments to be passed to the math function.\n    func_name: list[str] | str\n        Name of the math function(s) to be called.\n    func_args: list[dict[str, Any]] | dict[str, Any] | None, optional\n        Arguments to be passed to the math function(s), by default None.\n    \"\"\"\n    super().__init__()\n\n    self._x: tuple[UniversalArray, ...] = x\n    func_args = func_args or [{} for _ in range(len(func_name))]\n    self.func_args = [func_args] if isinstance(func_args, dict) else func_args\n    self.func_name = [func_name] if isinstance(func_name, str) else func_name\n    self.initialize_borg()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.initialize_borg","title":"<code>initialize_borg()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def initialize_borg(self) -&gt; None:\n    \"\"\"Initialize shared states of math function.\"\"\"\n    for name, args in zip(self.func_name, self.func_args, strict=True):\n        try:\n            func: Callable[[Any], Any] = getattr(core, name)\n        except AttributeError as exc:\n            msg = f\"Unknown function '{name}'\"\n            raise AttributeError(msg) from exc\n        try:\n            self.shared_state[name] = func(*self._x, **args)()\n        except TypeError as exc:\n            msg = f\"Function '{name}' has invalid arguments\"\n            raise TypeError(msg) from exc\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench","title":"<code>OptBench</code>","text":"<p>               Bases: <code>FunctionBorg</code>, <code>PlotBorg</code>, <code>SaveBorg</code></p> <p>A class for optimizing and benchmarking mathematical functions.</p> <p>About OptBench</p> <p>This class inherits from the <code>FunctionBorg</code>, <code>PlotBorg</code>, and <code>SaveBorg</code> classes, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # 3D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n&gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n&gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # 2D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench(\n...     [\n...         \"CrystalBallDistribution\",\n...         \"PseudoVoigtDistribution\",\n...         \"AsymmetricRamanLineshape\",\n...     ],\n...     [\n...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n...     ],\n...     start=-10,\n...     stop=10,\n...     step_size=0.1,\n...     dim=2,\n... )\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>list[str] | str</code> <p>Name of the function(s) to optimize and benchmark.</p> required <code>func_args</code> <code>list[dict[str, Any]] | dict[str, Any] | None</code> <p>Arguments  for the function(s). Defaults to None.</p> <code>None</code> <code>start</code> <code>float</code> <p>Start value of the range. Defaults to -5.0.</p> <code>-5.0</code> <code>stop</code> <code>float</code> <p>Stop value of the range. Defaults to 5.0.</p> <code>5.0</code> <code>step_size</code> <code>float | int</code> <p>Step value of the range or number of maximum  steps. Defaults to 0.1.</p> <code>0.1</code> <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either  'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>ValueError</code> <p>Number of dimensions must be greater than 1.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of dimensions.</p> <code>shared_result</code> <code>dict</code> <p>Dictionary containing arrays for plotting and saving.</p> <p>Methods:</p> Name Description <code>initializeshared_result</code> <p>Make arrays for plotting, saving and add them to share result.</p> <code>create_range</code> <p>float, stop: float,</p> <code>step_size</code> <p>float, dim: int = 2, mode: str = \"arange\")</p> <code>-&gt; list[UniversalArray] | MeshArray</code> <p>Create range of values for each dimension.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class OptBench(FunctionBorg, PlotBorg, SaveBorg):\n    \"\"\"A class for optimizing and benchmarking mathematical functions.\n\n    !!! info \"About OptBench\"\n\n        This class inherits from the `FunctionBorg`, `PlotBorg`, and `SaveBorg` classes,\n        which allows it to share state across multiple instances. It defines various\n        properties and methods for managing settings related to plotting, such as the\n        size and resolution of the plot, the axis labels, the color scheme, and the\n        plot style (either Matplotlib or Plotly). It also defines a `plot` method that\n        plots the shared states of a math function using either Matplotlib or Plotly,\n        depending on the value of the `_plot_style` attribute.\n\n    Examples:\n        &gt;&gt;&gt; # 3D examples\n        &gt;&gt;&gt; from umf.core.create import OptBench\n        &gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n        &gt;&gt;&gt; res.show = False\n        &gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n        &gt;&gt;&gt; res.plot_style = \"matplot\"\n        &gt;&gt;&gt; res.plot()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n        &gt;&gt;&gt; # As plotly\n        &gt;&gt;&gt; res.plot_style = \"plotly\"\n        &gt;&gt;&gt; res.plot()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n        &gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n        &gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n\n        &gt;&gt;&gt; # 2D examples\n        &gt;&gt;&gt; from umf.core.create import OptBench\n        &gt;&gt;&gt; res = OptBench(\n        ...     [\n        ...         \"CrystalBallDistribution\",\n        ...         \"PseudoVoigtDistribution\",\n        ...         \"AsymmetricRamanLineshape\",\n        ...     ],\n        ...     [\n        ...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n        ...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n        ...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n        ...     ],\n        ...     start=-10,\n        ...     stop=10,\n        ...     step_size=0.1,\n        ...     dim=2,\n        ... )\n        &gt;&gt;&gt; res.show = False\n        &gt;&gt;&gt; res.plot_style = \"matplot\"\n        &gt;&gt;&gt; res.plot_series()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n        &gt;&gt;&gt; # As plotly\n        &gt;&gt;&gt; res.plot_style = \"plotly\"\n        &gt;&gt;&gt; res.plot_series()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n\n    Args:\n        func_name (list[str] | str): Name of the function(s) to optimize and benchmark.\n        func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments\n             for the function(s). Defaults to None.\n        start (float, optional): Start value of the range. Defaults to -5.0.\n        stop (float, optional): Stop value of the range. Defaults to 5.0.\n        step_size (float | int, optional): Step value of the range or number of maximum\n             steps. Defaults to 0.1.\n        dim (int, optional): Number of dimensions. Defaults to 2.\n        mode (str, optional): Mode for creating the range of values. Must be either\n             'arange' or 'linspace'. Defaults to \"arange\".\n\n    Raises:\n        ValueError: Mode must be either 'arange' or 'linspace'.\n        ValueError: Number of dimensions must be greater than 1.\n\n    Attributes:\n        dim (int): Number of dimensions.\n        shared_result (dict): Dictionary containing arrays for plotting and saving.\n\n    Methods:\n        initializeshared_result(self) -&gt; None:\n            Make arrays for plotting, saving and add them to share result.\n        create_range(start: float, stop: float,\n        step_size: float, dim: int = 2, mode: str = \"arange\")\n        -&gt; list[UniversalArray] | MeshArray:\n            Create range of values for each dimension.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        func_name: list[str] | str,\n        func_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n        start: float = -5.0,\n        stop: float = 5.0,\n        step_size: float = 0.1,\n        dim: int = 2,\n        mode: str = \"arange\",\n    ) -&gt; None:\n        \"\"\"Initialize shared states of math functions.\"\"\"\n        self.auto_cleanup()\n        super().__init__(\n            *self.create_range(\n                start=start,\n                stop=stop,\n                step_size=step_size,\n                dim=dim,\n                mode=mode,\n            ),\n            func_name=func_name,\n            func_args=func_args,\n        )\n        self.initializeshared_result()\n        super(PlotBorg, self).__init__()\n        super(SaveBorg, self).__init__()\n        self.dim = dim\n\n    def initializeshared_result(self) -&gt; None:\n        \"\"\"Make arrays for plotting, saving and add them to share result.\"\"\"\n        for name in self.func_name:\n            self.shared_result[name] = np.asarray(\n                [*self.shared_state[name].x, self.shared_state[name].result],\n                dtype=np.float64,\n            )\n\n    @staticmethod\n    def create_range(\n        start: float,\n        stop: float,\n        step_size: float,\n        dim: int = 2,\n        mode: str = \"arange\",\n    ) -&gt; list[UniversalArray] | MeshArray:\n        \"\"\"Create range of values for each dimension.\n\n        Args:\n            start (float): Start value of range.\n            stop (float): Stop value of range.\n            step_size (float): Step value of range or number of maximum steps.\n            dim (int, optional): Number of dimensions. Defaults to 2.\n            mode (str, optional): Mode for creating the range of values. Must be either\n                'arange' or 'linspace'. Defaults to \"arange\".\n\n        Raises:\n            ValueError: Mode must be either 'arange' or 'linspace'.\n            TooSmallDimensionError: Number of dimensions must be greater than 1.\n\n        Returns:\n            list[UniversalArray] | MeshArray: Range of values for each dimension. In\n                case of 2 dimensions, a 1D array is returned. In case of more than 2\n                dimensions, a meshgrid is returned.\n        \"\"\"\n        if mode not in {\"arange\", \"linspace\"}:\n            msg = \"Mode must be either 'arange' or 'linspace'\"\n            raise ValueError(msg)\n\n        if dim &lt; __2d__:\n            raise TooLowDimensionError(min_dimension=__2d__, current_dimension=dim)\n\n        if dim == __2d__:\n            return [getattr(np, mode)(start, stop, step_size, dtype=np.float64)]\n\n        return np.meshgrid(\n            *[\n                getattr(np, mode)(start, stop, step_size, dtype=np.float64)\n                for _ in range(dim - 1)\n            ],\n        )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.__init__","title":"<code>__init__(func_name, func_args=None, start=-5.0, stop=5.0, step_size=0.1, dim=2, mode='arange')</code>","text":"<p>Initialize shared states of math functions.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\n    self,\n    func_name: list[str] | str,\n    func_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n    start: float = -5.0,\n    stop: float = 5.0,\n    step_size: float = 0.1,\n    dim: int = 2,\n    mode: str = \"arange\",\n) -&gt; None:\n    \"\"\"Initialize shared states of math functions.\"\"\"\n    self.auto_cleanup()\n    super().__init__(\n        *self.create_range(\n            start=start,\n            stop=stop,\n            step_size=step_size,\n            dim=dim,\n            mode=mode,\n        ),\n        func_name=func_name,\n        func_args=func_args,\n    )\n    self.initializeshared_result()\n    super(PlotBorg, self).__init__()\n    super(SaveBorg, self).__init__()\n    self.dim = dim\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.create_range","title":"<code>create_range(start, stop, step_size, dim=2, mode='arange')</code>  <code>staticmethod</code>","text":"<p>Create range of values for each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start value of range.</p> required <code>stop</code> <code>float</code> <p>Stop value of range.</p> required <code>step_size</code> <code>float</code> <p>Step value of range or number of maximum steps.</p> required <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either 'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>TooSmallDimensionError</code> <p>Number of dimensions must be greater than 1.</p> <p>Returns:</p> Type Description <code>list[UniversalArray] | MeshArray</code> <p>list[UniversalArray] | MeshArray: Range of values for each dimension. In case of 2 dimensions, a 1D array is returned. In case of more than 2 dimensions, a meshgrid is returned.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef create_range(\n    start: float,\n    stop: float,\n    step_size: float,\n    dim: int = 2,\n    mode: str = \"arange\",\n) -&gt; list[UniversalArray] | MeshArray:\n    \"\"\"Create range of values for each dimension.\n\n    Args:\n        start (float): Start value of range.\n        stop (float): Stop value of range.\n        step_size (float): Step value of range or number of maximum steps.\n        dim (int, optional): Number of dimensions. Defaults to 2.\n        mode (str, optional): Mode for creating the range of values. Must be either\n            'arange' or 'linspace'. Defaults to \"arange\".\n\n    Raises:\n        ValueError: Mode must be either 'arange' or 'linspace'.\n        TooSmallDimensionError: Number of dimensions must be greater than 1.\n\n    Returns:\n        list[UniversalArray] | MeshArray: Range of values for each dimension. In\n            case of 2 dimensions, a 1D array is returned. In case of more than 2\n            dimensions, a meshgrid is returned.\n    \"\"\"\n    if mode not in {\"arange\", \"linspace\"}:\n        msg = \"Mode must be either 'arange' or 'linspace'\"\n        raise ValueError(msg)\n\n    if dim &lt; __2d__:\n        raise TooLowDimensionError(min_dimension=__2d__, current_dimension=dim)\n\n    if dim == __2d__:\n        return [getattr(np, mode)(start, stop, step_size, dtype=np.float64)]\n\n    return np.meshgrid(\n        *[\n            getattr(np, mode)(start, stop, step_size, dtype=np.float64)\n            for _ in range(dim - 1)\n        ],\n    )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.initializeshared_result","title":"<code>initializeshared_result()</code>","text":"<p>Make arrays for plotting, saving and add them to share result.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def initializeshared_result(self) -&gt; None:\n    \"\"\"Make arrays for plotting, saving and add them to share result.\"\"\"\n    for name in self.func_name:\n        self.shared_result[name] = np.asarray(\n            [*self.shared_state[name].x, self.shared_state[name].result],\n            dtype=np.float64,\n        )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg","title":"<code>PlotBorg</code>","text":"<p>               Bases: <code>Borg</code></p> <p>A singleton class that manages shared settings for plotting math functions.</p> <p>About PlotBorg</p> <p>This class inherits from the <code>Borg</code> class, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>The size of the plot in inches.</p> <code>dpi</code> <code>int</code> <p>The resolution of the plot in dots per inch.</p> <code>axis</code> <code>list[str] | None</code> <p>The labels for the x and y axes.</p> <code>color</code> <code>str | None</code> <p>The color scheme for the plot.</p> <code>cmap</code> <code>str</code> <p>The colormap for the plot.</p> <code>alpha</code> <code>float | None</code> <p>The transparency of the plot.</p> <code>plot_type_3d</code> <code>str</code> <p>The type of 3D plot to use (if any).</p> <code>plot_style</code> <code>str</code> <p>The style of the plot (either \"matplot\" or \"plotly\").</p> <code>show</code> <code>bool</code> <p>Whether to show the plot after it is generated.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class PlotBorg(Borg):\n    \"\"\"A singleton class that manages shared settings for plotting math functions.\n\n    !!! info \"About PlotBorg\"\n\n        This class inherits from the `Borg` class, which allows it to share state\n        across multiple instances. It defines various properties and methods for\n        managing settings related to plotting, such as the size and resolution of\n        the plot, the axis labels, the color scheme, and the plot style (either\n        Matplotlib or Plotly). It also defines a `plot` method that plots the\n        shared states of a math function using either Matplotlib or Plotly,\n        depending on the value of the `_plot_style` attribute.\n\n    Attributes:\n        size (tuple[int, int]): The size of the plot in inches.\n        dpi (int): The resolution of the plot in dots per inch.\n        axis (list[str] | None): The labels for the x and y axes.\n        color (str | None): The color scheme for the plot.\n        cmap (str): The colormap for the plot.\n        alpha (float | None): The transparency of the plot.\n        plot_type_3d (str): The type of 3D plot to use (if any).\n        plot_style (str): The style of the plot (either \"matplot\" or \"plotly\").\n        show (bool): Whether to show the plot after it is generated.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize shared settings for plotting math functions.\"\"\"\n        super().__init__()\n\n        self._dpi = GraphSettings().dpi\n        self._size = GraphSettings().size\n        self._dpi = GraphSettings().dpi\n        self._axis = GraphSettings().axis\n        self._color = GraphSettings().color\n        self._cmap = GraphSettings().cmap\n        self._alpha = GraphSettings().alpha\n        self._plot_type_3d = \"plot_3d\"\n        self._plot_style = \"matplot\"\n        self._show = True\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        \"\"\"Return the size of the plot.\"\"\"\n        return self._size\n\n    @size.setter\n    def size(self, value: tuple[int, int]) -&gt; None:\n        \"\"\"Set the size of the plot.\"\"\"\n        self._size = value\n\n    @property\n    def dpi(self) -&gt; int:\n        \"\"\"Return the resolution of the plot.\"\"\"\n        return self._dpi\n\n    @dpi.setter\n    def dpi(self, value: int) -&gt; None:\n        \"\"\"Set the resolution of the plot.\"\"\"\n        self._dpi = value\n\n    @property\n    def axis(self) -&gt; list[str] | None:\n        \"\"\"Return the labels for the x and y axes.\"\"\"\n        return self._axis\n\n    @axis.setter\n    def axis(self, value: list[str] | None) -&gt; None:\n        \"\"\"Set the labels for the x and y axes.\"\"\"\n        self._axis = value\n\n    @property\n    def color(self) -&gt; str | None:\n        \"\"\"Return the color scheme for the plot.\"\"\"\n        return self._color\n\n    @color.setter\n    def color(self, value: str | None) -&gt; None:\n        \"\"\"Set the color scheme for the plot.\"\"\"\n        self._color = value\n\n    @property\n    def cmap(self) -&gt; str:\n        \"\"\"Return the colormap for the plot.\"\"\"\n        return self._cmap\n\n    @cmap.setter\n    def cmap(self, value: str) -&gt; None:\n        \"\"\"Set the colormap for the plot.\"\"\"\n        self._cmap = value\n\n    @property\n    def alpha(self) -&gt; float | None:\n        \"\"\"Return the transparency of the plot.\"\"\"\n        return self._alpha\n\n    @alpha.setter\n    def alpha(self, value: float | None) -&gt; None:\n        \"\"\"Set the transparency of the plot.\"\"\"\n        self._alpha = value\n\n    @property\n    def plot_type_3d(self) -&gt; str:\n        \"\"\"Return the type of 3D plot to use.\"\"\"\n        return self._plot_type_3d\n\n    @plot_type_3d.setter\n    def plot_type_3d(self, value: str) -&gt; None:\n        \"\"\"Set the type of 3D plot to use.\"\"\"\n        self._plot_type_3d = value\n\n    @property\n    def plot_style(self) -&gt; str:\n        \"\"\"Return the style of the plot.\"\"\"\n        return self._plot_style\n\n    @plot_style.setter\n    def plot_style(self, value: str) -&gt; None:\n        \"\"\"Set the style of the plot.\"\"\"\n        self._plot_style = value\n\n    @property\n    def show(self) -&gt; bool:\n        \"\"\"Return whether to show the plot after it is generated.\"\"\"\n        return self._show\n\n    @show.setter\n    def show(self, value: bool) -&gt; None:\n        \"\"\"Set whether to show the plot after it is generated.\"\"\"\n        self._show = value\n\n    def plot(self, **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Plot shared states of math function.\n\n        Info \"About plot\"\n            This method plots the shared states of a math function using either\n            Matplotlib or Plotly, depending on the value of the `_plot_style`\n            attribute. The settings for the plot are determined by the values of various\n            other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n            and `_alpha`.\n\n        Args:\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\n        settings = GraphSettings(\n            size=self._size,\n            dpi=self._dpi,\n            axis=self._axis,\n            color=self._color,\n            cmap=self._cmap,\n            alpha=self._alpha,\n        )\n        for name, x in self.shared_result.items():\n            if self._plot_style == \"matplot\":\n                self.matplot(*x, title=name, settings=settings, **kwargs)\n            elif self._plot_style == \"plotly\":\n                self.plotly(*x, title=name, settings=settings, **kwargs)\n            else:\n                raise PlotAttributeError(\n                    choose=self._plot_style,\n                    modes={\"matplot\", \"plotly\"},\n                    error_type=\"style\",\n                )\n\n    def plot_series(self, **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Plot shared states of math function as series.\n\n        Info \"About plot_series\"\n            This method plots the shared states of a math function as series using\n            either Matplotlib or Plotly, depending on the value of the `_plot_style`\n            attribute. The settings for the plot are determined by the values of various\n            other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n            and `_alpha`.\n\n        Args:\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\n        settings = GraphSettings(\n            size=self._size,\n            dpi=self._dpi,\n            axis=self._axis,\n            color=self._color,\n            cmap=self._cmap,\n            alpha=self._alpha,\n        )\n\n        label = []\n        values: list[UniversalArray] = []\n        for name, x in self.shared_result.items():\n            label.append(name)\n            values.append(x)\n\n        if self._plot_style == \"matplot\":\n            plot = ClassicPlot(*values, settings=settings, **kwargs)\n            plot.plot_series(label=label)\n            if self._show:\n                plot.plot_show()\n        elif self._plot_style == \"plotly\":\n            plot = PlotlyPlot(*values, settings=settings, **kwargs)\n            plot.plot_series(label=label)\n            if self._show:\n                plot.plot_show()\n        else:\n            raise PlotAttributeError(\n                choose=self._plot_style,\n                modes={\"matplot\", \"plotly\"},\n                error_type=\"style\",\n            )\n        self.shared_plot[f\"Series_of_{'-'.join(label)}\"] = plot.plot_return\n\n    def matplot(\n        self,\n        *x: UniversalArray,\n        title: str,\n        settings: GraphSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Plot shared states of math function via matplotlib.\n\n        Args:\n            *x (UniversalArray): Arrays to plot.\n            title (str): Title of plots (used as key in shared plot).\n            settings (GraphSettings): Settings of plot via `GraphSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n                plot_contour, plot_surface, plot_dashboard.\n        \"\"\"\n        plot = ClassicPlot(*x, settings=settings, **kwargs)\n        dim = len(x)\n\n        modes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\n        if self._plot_type_3d not in modes:\n            raise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\n\n        if dim == __2d__:\n            plot.plot_2d()\n        elif dim == __3d__:\n            getattr(plot, self._plot_type_3d)()\n        else:\n            raise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\n        self.shared_plot[title] = plot.plot_return\n        if self._show:\n            plot.plot_show()\n\n    def plotly(\n        self,\n        *x: UniversalArray,\n        title: str,\n        settings: GraphSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Plot shared states of math function via plotly.\n\n        Args:\n            *x (UniversalArray): Arrays to plot.\n            title (str): Title of plots (used as key in shared plot).\n            settings (GraphSettings): Settings of plot via `GraphSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\n        plot = PlotlyPlot(*x, settings=settings, **kwargs)\n        dim = len(x)\n        modes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\n        if self._plot_type_3d not in modes:\n            raise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\n        if dim == __2d__:\n            plot.plot_2d()\n        elif dim == __3d__:\n            getattr(plot, self._plot_type_3d)()\n        else:\n            raise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\n        self.shared_plot[title] = plot.plot_return\n        if self._show:\n            plot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.alpha","title":"<code>alpha</code>  <code>property</code> <code>writable</code>","text":"<p>Return the transparency of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.axis","title":"<code>axis</code>  <code>property</code> <code>writable</code>","text":"<p>Return the labels for the x and y axes.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.cmap","title":"<code>cmap</code>  <code>property</code> <code>writable</code>","text":"<p>Return the colormap for the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.color","title":"<code>color</code>  <code>property</code> <code>writable</code>","text":"<p>Return the color scheme for the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.dpi","title":"<code>dpi</code>  <code>property</code> <code>writable</code>","text":"<p>Return the resolution of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_style","title":"<code>plot_style</code>  <code>property</code> <code>writable</code>","text":"<p>Return the style of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_type_3d","title":"<code>plot_type_3d</code>  <code>property</code> <code>writable</code>","text":"<p>Return the type of 3D plot to use.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.show","title":"<code>show</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether to show the plot after it is generated.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.size","title":"<code>size</code>  <code>property</code> <code>writable</code>","text":"<p>Return the size of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared settings for plotting math functions.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize shared settings for plotting math functions.\"\"\"\n    super().__init__()\n\n    self._dpi = GraphSettings().dpi\n    self._size = GraphSettings().size\n    self._dpi = GraphSettings().dpi\n    self._axis = GraphSettings().axis\n    self._color = GraphSettings().color\n    self._cmap = GraphSettings().cmap\n    self._alpha = GraphSettings().alpha\n    self._plot_type_3d = \"plot_3d\"\n    self._plot_style = \"matplot\"\n    self._show = True\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.matplot","title":"<code>matplot(*x, title, settings, **kwargs)</code>","text":"<p>Plot shared states of math function via matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to plot.</p> <code>()</code> <code>title</code> <code>str</code> <p>Title of plots (used as key in shared plot).</p> required <code>settings</code> <code>GraphSettings</code> <p>Settings of plot via <code>GraphSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d, plot_contour, plot_surface, plot_dashboard.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def matplot(\n    self,\n    *x: UniversalArray,\n    title: str,\n    settings: GraphSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Plot shared states of math function via matplotlib.\n\n    Args:\n        *x (UniversalArray): Arrays to plot.\n        title (str): Title of plots (used as key in shared plot).\n        settings (GraphSettings): Settings of plot via `GraphSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n            plot_contour, plot_surface, plot_dashboard.\n    \"\"\"\n    plot = ClassicPlot(*x, settings=settings, **kwargs)\n    dim = len(x)\n\n    modes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\n    if self._plot_type_3d not in modes:\n        raise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\n\n    if dim == __2d__:\n        plot.plot_2d()\n    elif dim == __3d__:\n        getattr(plot, self._plot_type_3d)()\n    else:\n        raise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\n    self.shared_plot[title] = plot.plot_return\n    if self._show:\n        plot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot shared states of math function.</p> <p>Info \"About plot\"     This method plots the shared states of a math function using either     Matplotlib or Plotly, depending on the value of the <code>_plot_style</code>     attribute. The settings for the plot are determined by the values of various     other attributes, such as <code>_size</code>, <code>_dpi</code>, <code>_axis</code>, <code>_color</code>, <code>_cmap</code>,     and <code>_alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plot(self, **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Plot shared states of math function.\n\n    Info \"About plot\"\n        This method plots the shared states of a math function using either\n        Matplotlib or Plotly, depending on the value of the `_plot_style`\n        attribute. The settings for the plot are determined by the values of various\n        other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n        and `_alpha`.\n\n    Args:\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\n    settings = GraphSettings(\n        size=self._size,\n        dpi=self._dpi,\n        axis=self._axis,\n        color=self._color,\n        cmap=self._cmap,\n        alpha=self._alpha,\n    )\n    for name, x in self.shared_result.items():\n        if self._plot_style == \"matplot\":\n            self.matplot(*x, title=name, settings=settings, **kwargs)\n        elif self._plot_style == \"plotly\":\n            self.plotly(*x, title=name, settings=settings, **kwargs)\n        else:\n            raise PlotAttributeError(\n                choose=self._plot_style,\n                modes={\"matplot\", \"plotly\"},\n                error_type=\"style\",\n            )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_series","title":"<code>plot_series(**kwargs)</code>","text":"<p>Plot shared states of math function as series.</p> <p>Info \"About plot_series\"     This method plots the shared states of a math function as series using     either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code>     attribute. The settings for the plot are determined by the values of various     other attributes, such as <code>_size</code>, <code>_dpi</code>, <code>_axis</code>, <code>_color</code>, <code>_cmap</code>,     and <code>_alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plot_series(self, **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Plot shared states of math function as series.\n\n    Info \"About plot_series\"\n        This method plots the shared states of a math function as series using\n        either Matplotlib or Plotly, depending on the value of the `_plot_style`\n        attribute. The settings for the plot are determined by the values of various\n        other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n        and `_alpha`.\n\n    Args:\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\n    settings = GraphSettings(\n        size=self._size,\n        dpi=self._dpi,\n        axis=self._axis,\n        color=self._color,\n        cmap=self._cmap,\n        alpha=self._alpha,\n    )\n\n    label = []\n    values: list[UniversalArray] = []\n    for name, x in self.shared_result.items():\n        label.append(name)\n        values.append(x)\n\n    if self._plot_style == \"matplot\":\n        plot = ClassicPlot(*values, settings=settings, **kwargs)\n        plot.plot_series(label=label)\n        if self._show:\n            plot.plot_show()\n    elif self._plot_style == \"plotly\":\n        plot = PlotlyPlot(*values, settings=settings, **kwargs)\n        plot.plot_series(label=label)\n        if self._show:\n            plot.plot_show()\n    else:\n        raise PlotAttributeError(\n            choose=self._plot_style,\n            modes={\"matplot\", \"plotly\"},\n            error_type=\"style\",\n        )\n    self.shared_plot[f\"Series_of_{'-'.join(label)}\"] = plot.plot_return\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plotly","title":"<code>plotly(*x, title, settings, **kwargs)</code>","text":"<p>Plot shared states of math function via plotly.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to plot.</p> <code>()</code> <code>title</code> <code>str</code> <p>Title of plots (used as key in shared plot).</p> required <code>settings</code> <code>GraphSettings</code> <p>Settings of plot via <code>GraphSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plotly(\n    self,\n    *x: UniversalArray,\n    title: str,\n    settings: GraphSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Plot shared states of math function via plotly.\n\n    Args:\n        *x (UniversalArray): Arrays to plot.\n        title (str): Title of plots (used as key in shared plot).\n        settings (GraphSettings): Settings of plot via `GraphSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\n    plot = PlotlyPlot(*x, settings=settings, **kwargs)\n    dim = len(x)\n    modes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\n    if self._plot_type_3d not in modes:\n        raise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\n    if dim == __2d__:\n        plot.plot_2d()\n    elif dim == __3d__:\n        getattr(plot, self._plot_type_3d)()\n    else:\n        raise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\n    self.shared_plot[title] = plot.plot_return\n    if self._show:\n        plot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg","title":"<code>SaveBorg</code>","text":"<p>               Bases: <code>Borg</code></p> <p>Class for saving shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class SaveBorg(Borg):\n    \"\"\"Class for saving shared states of math function.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize shared states of math function.\"\"\"\n        super().__init__()\n\n        self.dpi = GIFSettings().dpi\n        self._zoom_start = GIFSettings().zoom_start\n        self._zoom_stop = GIFSettings().zoom_stop\n        self._elev = GIFSettings().elev\n        self._azim = GIFSettings().azim\n        self._frames = GIFSettings().frames\n        self._interval = GIFSettings().interval\n\n    @property\n    def dpi(self) -&gt; int:\n        \"\"\"Return dpi of gif.\"\"\"\n        return self._dpi\n\n    @dpi.setter\n    def dpi(self, value: int) -&gt; None:\n        \"\"\"Set dpi of gif.\"\"\"\n        self._dpi = value\n\n    @property\n    def zoom_start(self) -&gt; float:\n        \"\"\"Return zoom in of gif.\"\"\"\n        return self._zoom_start\n\n    @zoom_start.setter\n    def zoom_start(self, value: float) -&gt; None:\n        \"\"\"Set zoom in of gif.\"\"\"\n        self._zoom_start = value\n\n    @property\n    def zoom_stop(self) -&gt; float:\n        \"\"\"Return zoom out of gif.\"\"\"\n        return self._zoom_stop\n\n    @zoom_stop.setter\n    def zoom_stop(self, value: float) -&gt; None:\n        \"\"\"Set zoom out of gif.\"\"\"\n        self._zoom_stop = value\n\n    @property\n    def elev(self) -&gt; int:\n        \"\"\"Return elevation of gif.\"\"\"\n        return self._elev\n\n    @elev.setter\n    def elev(self, value: int) -&gt; None:\n        \"\"\"Set elevation of gif.\"\"\"\n        self._elev = value\n\n    @property\n    def azim(self) -&gt; int:\n        \"\"\"Return azimuth of gif.\"\"\"\n        return self._azim\n\n    @azim.setter\n    def azim(self, value: int) -&gt; None:\n        \"\"\"Set azimuth of gif.\"\"\"\n        self._azim = value\n\n    @property\n    def frames(self) -&gt; int:\n        \"\"\"Return frames of gif.\"\"\"\n        return self._frames\n\n    @frames.setter\n    def frames(self, value: int) -&gt; None:\n        \"\"\"Set frames of gif.\"\"\"\n        self._frames = value\n\n    @property\n    def interval(self) -&gt; int:\n        \"\"\"Return interval of gif.\"\"\"\n        return self._interval\n\n    def save_as_csv(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Save shared states of math function as csv file.\n\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for numpy.savetxt.\n        \"\"\"\n        self.if_dir_not_exist(dir_name)\n        for name, values in self.shared_result.items():\n            self.to_csv(*values, fname=Path(dir_name) / f\"{name}.csv\", **kwargs)\n\n    def save_as_json(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Save shared states of math function as json file.\n\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for json.dump.\n        \"\"\"\n        self.if_dir_not_exist(dir_name)\n        for name, values in self.shared_result.items():\n            self.to_json(*values, fname=Path(dir_name) / f\"{name}.json\", **kwargs)\n\n    def save_as_pickle(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Save shared states of math function as pickle file.\n\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for numpy.savez.\n        \"\"\"\n        self.if_dir_not_exist(dir_name)\n        for name, values in self.shared_result.items():\n            self.to_pickle(*values, fname=Path(dir_name) / f\"{name}.npz\", **kwargs)\n\n    def save_as_clipboard(self) -&gt; None:\n        \"\"\"Save shared states of math function to clipboard.\"\"\"\n        raise NotImplementedError\n\n    def save_as_image(\n        self,\n        dir_name: str = \".\",\n        ffomat: str = \"png\",\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as image file.\"\"\"\n        self.if_dir_not_exist(dir_name)\n        for name, fig in self.shared_plot.items():\n            self.to_image(fig, fname=Path(dir_name) / name, fformat=ffomat, **kwargs)\n\n    def save_as_gif(\n        self,\n        *,\n        dir_name: str = \".\",\n        zoom: bool = True,\n        rotate: bool = True,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as gif file.\n\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            zoom (bool, optional): Whether to save zoom gif. Defaults to True.\n            rotate (bool, optional): Whether to save rotate gif. Defaults to True.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save.\n        \"\"\"\n        settings = GIFSettings(\n            dpi=self._dpi,\n            zoom_start=self._zoom_start,\n            zoom_stop=self._zoom_stop,\n            elev=self._elev,\n            azim=self._azim,\n            frames=self._frames,\n            interval=self._interval,\n            zoom=zoom,\n            rotate=rotate,\n        )\n        self.if_dir_not_exist(dir_name)\n        for name, fig in self.shared_plot.items():\n            self.to_gif(\n                fig,\n                fname=Path(dir_name) / f\"{name}.gif\",\n                settings=settings,\n                **kwargs,\n            )\n\n    @staticmethod\n    def if_dir_not_exist(dir_name: str) -&gt; None:\n        \"\"\"Check if directory exist, if not create it.\"\"\"\n        if not Path(dir_name).exists():\n            Path(dir_name).mkdir(parents=True, exist_ok=True)\n\n    @staticmethod\n    def to_csv(\n        *x: UniversalArray,\n        fname: Path,\n        fmt: str = \"%f\",\n        delimiter: str = \",\",\n        comments: str = \"\",\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as csv file.\n\n        Args:\n            *x (UniversalArray): Arrays to save.\n            fname (Path): Path to save file.\n            fmt (str, optional): Format of file. Defaults to '%f'.\n            delimiter (str, optional): Delimiter of file. Defaults to ','.\n            comments (str, optional): Comments of file. Defaults to ''.\n            **kwargs (Any): Additional arguments for numpy.savetxt.\n        \"\"\"\n        length = len(x)\n        np.savetxt(\n            fname,\n            np.asarray(x).T.reshape(-1, length),\n            fmt=fmt,\n            delimiter=delimiter,\n            header=delimiter.join([f\"x_{i}\" for i in range(length)]),\n            comments=comments,\n            **kwargs,\n        )\n\n    @staticmethod\n    def to_json(\n        *x: UniversalArray,\n        fname: Path,\n        mode: str = \"w+\",\n        encoding: str = \"UTF-8\",\n        indent: int = 4,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as json file.\n\n        Args:\n            *x (UniversalArray): Arrays to save.\n            mode (str, optional): Mode of file. Defaults to 'w+'.\n            encoding (str, optional): Encoding of file. Defaults to 'UTF-8'.\n            indent (int, optional): Indent of file. Defaults to 4.\n            fname (Path): Path to save file.\n            **kwargs (dict[str, Any]): Additional arguments for json.dump.\n        \"\"\"\n        with Path(fname).open(mode=mode, encoding=encoding) as f:\n            json.dump(\n                {f\"x_{i}\": x[i].tolist() for i in range(len(x))},\n                f,\n                indent=indent,\n                **kwargs,\n            )\n\n    @staticmethod\n    def to_pickle(*x: UniversalArray, fname: Path, **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Save shared states of math function as pickle file.\n\n        Args:\n            *x (UniversalArray): Arrays to save.\n            fname (Path): Path to save file.\n            **kwargs (Any): Additional arguments for numpy.savez.\n        \"\"\"\n        np.savez(fname, *x, **kwargs)\n\n    def to_clipboard(self) -&gt; None:\n        \"\"\"Save shared states of math function to clipboard.\"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def to_image(\n        fig: FigureTypePlotly | FigureTypeMatplotlib,\n        fname: Path,\n        fformat: str = \"png\",\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as image file.\n\n        Args:\n            fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n            fname (Path): Path to save file.\n            fformat (str, optional): Format of file. Defaults to 'png'.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save.\n        \"\"\"\n        plot_classes = {\n            plt.Figure: ClassicPlot,\n            go.Figure: PlotlyPlot,\n        }\n\n        plot_class = plot_classes.get(type(fig))\n        if plot_class is not None:\n            plot_class.plot_save(fig=fig, fname=fname, fformat=fformat, **kwargs)\n\n    @staticmethod\n    def to_gif(\n        fig: FigureTypePlotly | FigureTypeMatplotlib,\n        fname: Path,\n        ax_fig: plt.Figure,\n        settings: GIFSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save shared states of math function as gif file.\n\n        Notes:\n            This method is only supported for Matplotlib plots.\n\n        Args:\n            fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n            fname (Path): Path to save file.\n            ax_fig (plt.Figure): Figure to save.\n            settings (GIFSettings): Settings of gif via `GIFSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save_gif.\n        \"\"\"\n        plot_classes = {\n            plt.Figure: ClassicPlot,\n            go.Figure: PlotlyPlot,\n        }\n\n        plot_class = plot_classes.get(type(fig))\n        if plot_class is not None:\n            plot_class.plot_save_gif(\n                fig=fig,\n                ax_fig=ax_fig,\n                fname=fname,\n                settings=settings,\n                **kwargs,\n            )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.azim","title":"<code>azim</code>  <code>property</code> <code>writable</code>","text":"<p>Return azimuth of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.dpi","title":"<code>dpi</code>  <code>property</code> <code>writable</code>","text":"<p>Return dpi of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.elev","title":"<code>elev</code>  <code>property</code> <code>writable</code>","text":"<p>Return elevation of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.frames","title":"<code>frames</code>  <code>property</code> <code>writable</code>","text":"<p>Return frames of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.interval","title":"<code>interval</code>  <code>property</code>","text":"<p>Return interval of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.zoom_start","title":"<code>zoom_start</code>  <code>property</code> <code>writable</code>","text":"<p>Return zoom in of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.zoom_stop","title":"<code>zoom_stop</code>  <code>property</code> <code>writable</code>","text":"<p>Return zoom out of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize shared states of math function.\"\"\"\n    super().__init__()\n\n    self.dpi = GIFSettings().dpi\n    self._zoom_start = GIFSettings().zoom_start\n    self._zoom_stop = GIFSettings().zoom_stop\n    self._elev = GIFSettings().elev\n    self._azim = GIFSettings().azim\n    self._frames = GIFSettings().frames\n    self._interval = GIFSettings().interval\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.if_dir_not_exist","title":"<code>if_dir_not_exist(dir_name)</code>  <code>staticmethod</code>","text":"<p>Check if directory exist, if not create it.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef if_dir_not_exist(dir_name: str) -&gt; None:\n    \"\"\"Check if directory exist, if not create it.\"\"\"\n    if not Path(dir_name).exists():\n        Path(dir_name).mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_clipboard","title":"<code>save_as_clipboard()</code>","text":"<p>Save shared states of math function to clipboard.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_clipboard(self) -&gt; None:\n    \"\"\"Save shared states of math function to clipboard.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_csv","title":"<code>save_as_csv(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as csv file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savetxt.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_csv(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Save shared states of math function as csv file.\n\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for numpy.savetxt.\n    \"\"\"\n    self.if_dir_not_exist(dir_name)\n    for name, values in self.shared_result.items():\n        self.to_csv(*values, fname=Path(dir_name) / f\"{name}.csv\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_gif","title":"<code>save_as_gif(*, dir_name='.', zoom=True, rotate=True, **kwargs)</code>","text":"<p>Save shared states of math function as gif file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>zoom</code> <code>bool</code> <p>Whether to save zoom gif. Defaults to True.</p> <code>True</code> <code>rotate</code> <code>bool</code> <p>Whether to save rotate gif. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_gif(\n    self,\n    *,\n    dir_name: str = \".\",\n    zoom: bool = True,\n    rotate: bool = True,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as gif file.\n\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        zoom (bool, optional): Whether to save zoom gif. Defaults to True.\n        rotate (bool, optional): Whether to save rotate gif. Defaults to True.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save.\n    \"\"\"\n    settings = GIFSettings(\n        dpi=self._dpi,\n        zoom_start=self._zoom_start,\n        zoom_stop=self._zoom_stop,\n        elev=self._elev,\n        azim=self._azim,\n        frames=self._frames,\n        interval=self._interval,\n        zoom=zoom,\n        rotate=rotate,\n    )\n    self.if_dir_not_exist(dir_name)\n    for name, fig in self.shared_plot.items():\n        self.to_gif(\n            fig,\n            fname=Path(dir_name) / f\"{name}.gif\",\n            settings=settings,\n            **kwargs,\n        )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_image","title":"<code>save_as_image(dir_name='.', ffomat='png', **kwargs)</code>","text":"<p>Save shared states of math function as image file.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_image(\n    self,\n    dir_name: str = \".\",\n    ffomat: str = \"png\",\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as image file.\"\"\"\n    self.if_dir_not_exist(dir_name)\n    for name, fig in self.shared_plot.items():\n        self.to_image(fig, fname=Path(dir_name) / name, fformat=ffomat, **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_json","title":"<code>save_as_json(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as json file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for json.dump.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_json(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Save shared states of math function as json file.\n\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for json.dump.\n    \"\"\"\n    self.if_dir_not_exist(dir_name)\n    for name, values in self.shared_result.items():\n        self.to_json(*values, fname=Path(dir_name) / f\"{name}.json\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_pickle","title":"<code>save_as_pickle(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savez.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_pickle(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Save shared states of math function as pickle file.\n\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for numpy.savez.\n    \"\"\"\n    self.if_dir_not_exist(dir_name)\n    for name, values in self.shared_result.items():\n        self.to_pickle(*values, fname=Path(dir_name) / f\"{name}.npz\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_clipboard","title":"<code>to_clipboard()</code>","text":"<p>Save shared states of math function to clipboard.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def to_clipboard(self) -&gt; None:\n    \"\"\"Save shared states of math function to clipboard.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_csv","title":"<code>to_csv(*x, fname, fmt='%f', delimiter=',', comments='', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as csv file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>fmt</code> <code>str</code> <p>Format of file. Defaults to '%f'.</p> <code>'%f'</code> <code>delimiter</code> <code>str</code> <p>Delimiter of file. Defaults to ','.</p> <code>','</code> <code>comments</code> <code>str</code> <p>Comments of file. Defaults to ''.</p> <code>''</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savetxt.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_csv(\n    *x: UniversalArray,\n    fname: Path,\n    fmt: str = \"%f\",\n    delimiter: str = \",\",\n    comments: str = \"\",\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as csv file.\n\n    Args:\n        *x (UniversalArray): Arrays to save.\n        fname (Path): Path to save file.\n        fmt (str, optional): Format of file. Defaults to '%f'.\n        delimiter (str, optional): Delimiter of file. Defaults to ','.\n        comments (str, optional): Comments of file. Defaults to ''.\n        **kwargs (Any): Additional arguments for numpy.savetxt.\n    \"\"\"\n    length = len(x)\n    np.savetxt(\n        fname,\n        np.asarray(x).T.reshape(-1, length),\n        fmt=fmt,\n        delimiter=delimiter,\n        header=delimiter.join([f\"x_{i}\" for i in range(length)]),\n        comments=comments,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_gif","title":"<code>to_gif(fig, fname, ax_fig, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as gif file.</p> Notes <p>This method is only supported for Matplotlib plots.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>Figure to save.</p> required <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>ax_fig</code> <code>Figure</code> <p>Figure to save.</p> required <code>settings</code> <code>GIFSettings</code> <p>Settings of gif via <code>GIFSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save_gif.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_gif(\n    fig: FigureTypePlotly | FigureTypeMatplotlib,\n    fname: Path,\n    ax_fig: plt.Figure,\n    settings: GIFSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as gif file.\n\n    Notes:\n        This method is only supported for Matplotlib plots.\n\n    Args:\n        fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n        fname (Path): Path to save file.\n        ax_fig (plt.Figure): Figure to save.\n        settings (GIFSettings): Settings of gif via `GIFSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save_gif.\n    \"\"\"\n    plot_classes = {\n        plt.Figure: ClassicPlot,\n        go.Figure: PlotlyPlot,\n    }\n\n    plot_class = plot_classes.get(type(fig))\n    if plot_class is not None:\n        plot_class.plot_save_gif(\n            fig=fig,\n            ax_fig=ax_fig,\n            fname=fname,\n            settings=settings,\n            **kwargs,\n        )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_image","title":"<code>to_image(fig, fname, fformat='png', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as image file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>Figure to save.</p> required <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>fformat</code> <code>str</code> <p>Format of file. Defaults to 'png'.</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_image(\n    fig: FigureTypePlotly | FigureTypeMatplotlib,\n    fname: Path,\n    fformat: str = \"png\",\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as image file.\n\n    Args:\n        fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n        fname (Path): Path to save file.\n        fformat (str, optional): Format of file. Defaults to 'png'.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save.\n    \"\"\"\n    plot_classes = {\n        plt.Figure: ClassicPlot,\n        go.Figure: PlotlyPlot,\n    }\n\n    plot_class = plot_classes.get(type(fig))\n    if plot_class is not None:\n        plot_class.plot_save(fig=fig, fname=fname, fformat=fformat, **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_json","title":"<code>to_json(*x, fname, mode='w+', encoding='UTF-8', indent=4, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as json file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>mode</code> <code>str</code> <p>Mode of file. Defaults to 'w+'.</p> <code>'w+'</code> <code>encoding</code> <code>str</code> <p>Encoding of file. Defaults to 'UTF-8'.</p> <code>'UTF-8'</code> <code>indent</code> <code>int</code> <p>Indent of file. Defaults to 4.</p> <code>4</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for json.dump.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_json(\n    *x: UniversalArray,\n    fname: Path,\n    mode: str = \"w+\",\n    encoding: str = \"UTF-8\",\n    indent: int = 4,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save shared states of math function as json file.\n\n    Args:\n        *x (UniversalArray): Arrays to save.\n        mode (str, optional): Mode of file. Defaults to 'w+'.\n        encoding (str, optional): Encoding of file. Defaults to 'UTF-8'.\n        indent (int, optional): Indent of file. Defaults to 4.\n        fname (Path): Path to save file.\n        **kwargs (dict[str, Any]): Additional arguments for json.dump.\n    \"\"\"\n    with Path(fname).open(mode=mode, encoding=encoding) as f:\n        json.dump(\n            {f\"x_{i}\": x[i].tolist() for i in range(len(x))},\n            f,\n            indent=indent,\n            **kwargs,\n        )\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_pickle","title":"<code>to_pickle(*x, fname, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savez.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_pickle(*x: UniversalArray, fname: Path, **kwargs: dict[str, Any]) -&gt; None:\n    \"\"\"Save shared states of math function as pickle file.\n\n    Args:\n        *x (UniversalArray): Arrays to save.\n        fname (Path): Path to save file.\n        **kwargs (Any): Additional arguments for numpy.savez.\n    \"\"\"\n    np.savez(fname, *x, **kwargs)\n</code></pre>"},{"location":"modules/api/distributions/","title":"Modules","text":"<p>Continuous distributions on the interval \\([0, 2\\pi]\\).</p> <p>Continuous bounded interval distributions for the umf package.</p> <p>Continuous distributions with support for semi-infinite intervals for the umf.</p> <p>Continuous variable support distributions for the umf module.</p> <p>Continous distributions with whole line support for the umf package.</p> <p>Discrete distributions with finite support for the umf package.</p> <p>Discrete distributions with infinite support.</p> <p>Mixed discrete-continuous distributions for the for the umf package.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution","title":"<code>VonMisesDistribution</code>","text":"<p>               Bases: <code>Continuous2PiInterval</code></p> <p>von Mises distribution.</p> <p>The von Mises distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... VonMisesDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n&gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n&gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The von Mises distribution is defined as follows for probability density:</p> \\[ f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class VonMisesDistribution(Continuous2PiInterval):\n    r\"\"\"von Mises distribution.\n\n    The von Mises distribution is a continuous probability distribution on the\n    circle. It is a close approximation to the wrapped normal distribution,\n    which is the circular analogue of the normal distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... VonMisesDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n        &gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n        &gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n\n\n    Notes:\n        The von Mises distribution is defined as follows for probability density:\n\n        $$\n        f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n        $$\n\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.\n\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the von Mises distribution.\"\"\"\n        return np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n            2 * np.pi * special.i0(self.kappa)\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the von Mises distribution.\"\"\"\n\n        def _mode() -&gt; float | tuple[float, float]:\n            \"\"\"Mode of the von Mises distribution.\"\"\"\n            return self.mu\n\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=1 - special.i1(self.kappa) / special.i0(self.kappa),\n            mode=_mode(),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the von Mises distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the von Mises distribution.</p> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the von Mises distribution.\"\"\"\n    return np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n        2 * np.pi * special.i0(self.kappa)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution","title":"<code>WrappedAsymLaplaceDistribution</code>","text":"<p>               Bases: <code>Continuous2PiInterval</code></p> <p>Wrapped asymmetric Laplace distribution.</p> <p>The wrapped (asymmetric) Laplace distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... WrappedAsymLaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.5,\n... kappa=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.7,\n... kappa=0.7,\n... ).__eval__\n&gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.9,\n... kappa=0.9,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The wrapped Laplace distribution is defined as follows for probability density:</p> \\[ \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;= \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt] &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases} {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }} \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.<sup>1</sup></p> <ol> <li> <p>Wrapped asymmetric Laplace distribution. (2022, January 24). In Wikipedia. en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class WrappedAsymLaplaceDistribution(Continuous2PiInterval):\n    r\"\"\"Wrapped asymmetric Laplace distribution.\n\n    The wrapped (asymmetric) Laplace distribution is a continuous probability\n    distribution on the circle. It is a close approximation to the wrapped normal\n    distribution, which is the circular analogue of the normal distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... WrappedAsymLaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.5,\n        ... kappa=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.7,\n        ... kappa=0.7,\n        ... ).__eval__\n        &gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.9,\n        ... kappa=0.9,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The wrapped Laplace distribution is defined as follows for probability\n        density:\n\n        $$\n        \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;=\n        \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt]\n        &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases}\n        {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }}\n        \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned}\n        $$\n\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.[^1]\n\n        [^1]: Wrapped asymmetric Laplace distribution. (2022, January 24).\n            _In Wikipedia._\n            https://en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution\n\n    Args:\n        x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        lambda_: The scale parameter of the distribution.\n        kappa: The concentration of the distribution around mu.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        lambda_: float = 1,\n        kappa: float = 1,\n    ) -&gt; None:\n        r\"\"\"Initialize a wrapped Laplace distribution.\n\n        Args:\n            *x (UniversalArray): The points at which to evaluate the distribution.\n            mu (float): The mean of the distribution. Defaults to 0.\n            lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n            kappa (float): The concentration of the distribution around mu.\n                Defaults to 1.\n        \"\"\"\n        super().__init__(*x, mu=mu, kappa=kappa)\n        self.lambda_ = lambda_\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\n        part_1 = (\n            self.kappa\n            * self.lambda_\n            / (self.kappa**2 + 1)\n            * (\n                np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n                / (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n                - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n                / (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n            )\n        )\n        part_2 = (\n            self.kappa\n            * self.lambda_\n            / (self.kappa**2 + 1)\n            * (\n                np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n                / (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n                - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n                / (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n            )\n        )\n\n        # Combine the two parts\n        return np.where(self._x &gt;= self.mu, part_1, part_2)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the wrapped Laplace distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=1\n            - self.lambda_**2\n            / np.sqrt(\n                (1 / self.kappa**2 + self.lambda_**2)\n                * (self.kappa**2 + self.lambda_**2),\n            ),\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the wrapped Laplace distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.__init__","title":"<code>__init__(*x, mu=0, lambda_=1, kappa=1)</code>","text":"<p>Initialize a wrapped Laplace distribution.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    lambda_: float = 1,\n    kappa: float = 1,\n) -&gt; None:\n    r\"\"\"Initialize a wrapped Laplace distribution.\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\n    super().__init__(*x, mu=mu, kappa=kappa)\n    self.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the wrapped Laplace distribution.</p> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\n    part_1 = (\n        self.kappa\n        * self.lambda_\n        / (self.kappa**2 + 1)\n        * (\n            np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n            / (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n            - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n            / (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n        )\n    )\n    part_2 = (\n        self.kappa\n        * self.lambda_\n        / (self.kappa**2 + 1)\n        * (\n            np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n            / (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n            - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n            / (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n        )\n    )\n\n    # Combine the two parts\n    return np.where(self._x &gt;= self.mu, part_1, part_2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution","title":"<code>KumaraswamyDistribution</code>","text":"<p>               Bases: <code>ContinuousBoundedInterval</code></p> <p>Kumaraswamy distribution.</p> <p>The Kumaraswamy distribution is a continuous probability distribution with support on the interval [0, 1]. It is a generalization of the beta distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n&gt;&gt;&gt; plt.close()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"KumaraswamyDistribution-cml.png\",\n... dpi=300,\n... transparent=True\n... )\n</code></pre> Notes <p>The Kumaraswamy distribution is generally defined for the PDF as:</p> \\[ f(x; a, b) = abx^{a-1}(1-x^a)^{b-1} \\] <p>where \\(a, b &gt; 0\\) and \\(0 \\leq x \\leq 1\\). The CDF is given by:</p> \\[ F(x; a, b) = 1 - (1 - x^a)^b \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>a</code> <code>float</code> <p>The first shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>b</code> <code>float</code> <p>The second shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>class KumaraswamyDistribution(ContinuousBoundedInterval):\n    r\"\"\"Kumaraswamy distribution.\n\n    The Kumaraswamy distribution is a continuous probability distribution with\n    support on the interval [0, 1]. It is a generalization of the beta\n    distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; plt.close()\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"KumaraswamyDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True\n        ... )\n\n    Notes:\n        The Kumaraswamy distribution is generally defined for the PDF as:\n\n        $$\n        f(x; a, b) = abx^{a-1}(1-x^a)^{b-1}\n        $$\n\n        where $a, b &gt; 0$ and $0 \\leq x \\leq 1$. The CDF is given by:\n\n        $$\n        F(x; a, b) = 1 - (1 - x^a)^b\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        a (float): The first shape parameter, which must be positive. Default is 1.\n        b (float): The second shape parameter, which must be positive. Default is 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        a: float = 1,\n        b: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the Kumaraswamy distribution.\"\"\"\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotAPositiveNumberError(msg, a)\n        if b &lt;= 0:\n            msg = \"b\"\n            raise NotAPositiveNumberError(msg, b)\n        super().__init__(*x, start=0, end=1, cumulative=cumulative)\n        self.a = a\n        self.b = b\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n\n        Returns:\n            UniversalArray: The value of the probability density function of the\n                Kumaraswamy distribution.\n        \"\"\"\n        return (\n            self.a\n            * self.b\n            * self._x ** (self.a - 1)\n            * (1 - self._x**self.a) ** (self.b - 1)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n\n        Returns:\n            UniversalArray: The value of the cumulative distribution function of the\n                Kumaraswamy distribution.\n        \"\"\"  # noqa: E501\n        return 1 - (1 - self._x**self.a) ** self.b\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Calculate the summary statistics of the Kumaraswamy distribution.\n\n        Returns:\n            SummaryStatisticsAPI: The summary statistics of the Kumaraswamy\n                distribution.\n        \"\"\"\n        mode = (\n            (self.a - 1) / (self.a + self.b - 2) if self.a &gt; 1 and self.b &gt; 1 else None\n        )\n        mean = (self.b * gamma(1 + 1 / self.a) * gamma(self.a - 1)) / (\n            self.a * gamma(self.a + self.b)\n        )\n        return SummaryStatisticsAPI(\n            mean=mean,\n            mode=mode,\n            variance=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Calculate the summary statistics of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>SummaryStatisticsAPI</code> <code>SummaryStatisticsAPI</code> <p>The summary statistics of the Kumaraswamy distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.__init__","title":"<code>__init__(*x, a=1, b=1, cumulative=False)</code>","text":"<p>Initialize the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    a: float = 1,\n    b: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the Kumaraswamy distribution.\"\"\"\n    if a &lt;= 0:\n        msg = \"a\"\n        raise NotAPositiveNumberError(msg, a)\n    if b &lt;= 0:\n        msg = \"b\"\n        raise NotAPositiveNumberError(msg, b)\n    super().__init__(*x, start=0, end=1, cumulative=cumulative)\n    self.a = a\n    self.b = b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Calculate the cumulative distribution function of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the cumulative distribution function of the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n\n    Returns:\n        UniversalArray: The value of the cumulative distribution function of the\n            Kumaraswamy distribution.\n    \"\"\"  # noqa: E501\n    return 1 - (1 - self._x**self.a) ** self.b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Calculate the probability density function of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the probability density function of the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n\n    Returns:\n        UniversalArray: The value of the probability density function of the\n            Kumaraswamy distribution.\n    \"\"\"\n    return (\n        self.a\n        * self.b\n        * self._x ** (self.a - 1)\n        * (1 - self._x**self.a) ** (self.b - 1)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution","title":"<code>ChiSquaredDistribution</code>","text":"<p>               Bases: <code>SemiContinuous</code></p> <p>Chi-square distribution.</p> <p>The chi-square distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the sum of the squares of independent standard normal random variables. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The chi-square distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n... x,\n... k=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n... x,\n... k=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n... x,\n... k=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The chi-square distribution is generally defined for the PDF as:</p> \\[ f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2) \\] <p>and for the CDF as:</p> \\[ F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2) \\] <p>where \\(k\\) is the degrees of freedom.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>k</code> <code>float</code> <p>Degrees of freedom. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class ChiSquaredDistribution(SemiContinuous):\n    r\"\"\"Chi-square distribution.\n\n    The chi-square distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the sum of the squares of\n    independent standard normal random variables. It is a transformation of the normal\n    distribution, where the logarithm of the variable is normally distributed. The\n    chi-square distribution has applications in various fields, such as finance,\n    biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n        ... x,\n        ... k=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n        ... x,\n        ... k=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n        ... x,\n        ... k=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The chi-square distribution is generally defined for the PDF as:\n\n        $$\n        f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2)\n        $$\n\n        where $k$ is the degrees of freedom.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        k (float): Degrees of freedom. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        k: float = 1.0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if k &lt;= 0:\n            raise NotLargerThanZeroError(k)\n\n        super().__init__(*x, cumulative=cumulative)\n        self.k = k\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (2 ** (self.k / 2) * gamma(self.k / 2))\n            * self._x ** (self.k / 2 - 1)\n            * np.exp(-self._x / 2)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.k,\n            variance=2 * self.k,\n            mode=self.k - 2 if self.k &gt; 2 else 0,  # noqa: PLR2004\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.__init__","title":"<code>__init__(*x, k=1.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    k: float = 1.0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if k &lt;= 0:\n        raise NotLargerThanZeroError(k)\n\n    super().__init__(*x, cumulative=cumulative)\n    self.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        1\n        / (2 ** (self.k / 2) * gamma(self.k / 2))\n        * self._x ** (self.k / 2 - 1)\n        * np.exp(-self._x / 2)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution","title":"<code>DagumDistribution</code>","text":"<p>               Bases: <code>ContinuousPure</code></p> <p>Dagum distribution.</p> <p>The Dagum distribution is a continuous probability distribution that is defined on the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is characterized by its shape, scale, and shape parameters. The Dagum distribution is used in various fields, including economics, finance, and engineering, to model data that is non-negative and skewed to the right. It has a probability density function (PDF) and a cumulative distribution function (CDF) that can be used to calculate various statistical measures, such as mean, variance, and mode.</p> Notes <p>The Dagum distribution is generally defined for the PDF as:</p> \\[ f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{(p+1)/p}} \\] <p>and for the CDF as:</p> \\[ F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p} \\] <p>where \\(p\\) is the shape parameter, \\(a\\) is the scale parameter, and \\(b\\) is the shape parameter.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... DagumDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>a</code> <code>float</code> <p>Scale parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>NotLargerThanZeroError</code> <p>If p, a, or b is not larger than 0.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class DagumDistribution(ContinuousPure):\n    r\"\"\"Dagum distribution.\n\n    The Dagum distribution is a continuous probability distribution that is defined on\n    the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is\n    characterized by its shape, scale, and shape parameters. The Dagum distribution is\n    used in various fields, including economics, finance, and engineering, to model\n    data that is non-negative and skewed to the right. It has a probability density\n    function (PDF) and a cumulative distribution function (CDF) that can be used to\n    calculate various statistical measures, such as mean, variance, and mode.\n\n    Notes:\n        The Dagum distribution is generally defined for the PDF as:\n\n        $$\n        f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b}\n        x\\right)^{p}\\right]^{(p+1)/p}}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p}\n        $$\n\n        where $p$ is the shape parameter, $a$ is the scale parameter, and $b$ is the\n        shape parameter.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... DagumDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        p (float): Shape parameter. Must be greater than 0. Defaults to 1.\n        a (float): Scale parameter. Must be greater than 0. Defaults to 1.\n        b (float): Shape parameter. Must be greater than 0. Defaults to 1.\n\n    Raises:\n        NotLargerThanZeroError: If p, a, or b is not larger than 0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        p: float = 1.0,\n        a: float = 1.0,\n        b: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if p &lt;= 0:\n            msg = \"p\"\n            raise NotLargerThanZeroError(msg, p)\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotLargerThanZeroError(msg, a)\n        if b &lt;= 0:\n            msg = \"b\"\n            raise NotLargerThanZeroError(msg, b)\n        super().__init__(*x)\n        self.p = p\n        self.a = a\n        self.b = b\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.p\n            * self.a**self.p\n            / (\n                self._x ** (self.p + 1)\n                * (1 + (self.a / self.b) ** self.p * self._x**self.p)\n                ** ((self.p + 1) / self.p)\n            )\n        )\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.a\n            * gamma((self.p - 1) / self.p)\n            * gamma((self.p + 1) / self.p)\n            / gamma(self.p / self.p),\n            variance=self.a**2\n            * (\n                gamma((self.p - 2) / self.p)\n                * gamma((self.p + 1) / self.p)\n                / gamma(self.p / self.p)\n                - (\n                    self.a\n                    * gamma((self.p - 1) / self.p)\n                    * gamma((self.p + 1) / self.p)\n                    / gamma(self.p / self.p)\n                )\n                ** 2\n            ),\n            mode=self.a\n            * ((self.p / self.b) ** (1 / self.p))\n            * ((self.p - 1) / self.p) ** (1 / self.p),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.__init__","title":"<code>__init__(*x, p=1.0, a=1.0, b=1.0)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    p: float = 1.0,\n    a: float = 1.0,\n    b: float = 1.0,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if p &lt;= 0:\n        msg = \"p\"\n        raise NotLargerThanZeroError(msg, p)\n    if a &lt;= 0:\n        msg = \"a\"\n        raise NotLargerThanZeroError(msg, a)\n    if b &lt;= 0:\n        msg = \"b\"\n        raise NotLargerThanZeroError(msg, b)\n    super().__init__(*x)\n    self.p = p\n    self.a = a\n    self.b = b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        self.p\n        * self.a**self.p\n        / (\n            self._x ** (self.p + 1)\n            * (1 + (self.a / self.b) ** self.p * self._x**self.p)\n            ** ((self.p + 1) / self.p)\n        )\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution","title":"<code>LogNormalDistribution</code>","text":"<p>               Bases: <code>SemiContinuousWSigma</code></p> <p>Log-normal distribution.</p> <p>The log-normal distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The log-normal distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The log-normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class LogNormalDistribution(SemiContinuousWSigma):\n    r\"\"\"Log-normal distribution.\n\n    The log-normal distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The log-normal distribution has\n    applications in various fields, such as finance, biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The log-normal distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self._x * self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.exp(self.mu + self.sigma**2 / 2),\n            variance=(np.exp(self.sigma**2) - 1) * np.exp(2 * self.mu + self.sigma**2),\n            mode=np.exp(self.mu - self.sigma**2),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        1\n        / (self._x * self.sigma * np.sqrt(2 * np.pi))\n        * np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution","title":"<code>RayleighDistribution</code>","text":"<p>               Bases: <code>SemiContinuousWSigma</code></p> <p>Rayleigh distribution.</p> <p>The Rayleigh distribution is a continuous probability distribution that is commonly used in statistics to model the magnitude of a vector whose components are independent and identically distributed Gaussian random variables with zero mean. It is also used to describe the distribution of the magnitude of the sum of independent, identically distributed Gaussian random variables with zero mean and equal variance.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rayleigh distribution is generally defined for the PDF as:</p> \\[ f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>where \\(\\sigma\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class RayleighDistribution(SemiContinuousWSigma):\n    r\"\"\"Rayleigh distribution.\n\n    The Rayleigh distribution is a continuous probability distribution that is commonly\n    used in statistics to model the magnitude of a vector whose components are\n    independent and identically distributed Gaussian random variables with zero mean.\n    It is also used to describe the distribution of the magnitude of the sum of\n    independent, identically distributed Gaussian random variables with zero mean\n    and equal variance.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rayleigh distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n\n        where $\\sigma$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return self._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.sqrt(np.pi / 2) * self.sigma,\n            variance=(4 - np.pi) / 2 * self.sigma**2,\n            mode=self.sigma,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return self._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution","title":"<code>WeibullDistribution</code>","text":"<p>               Bases: <code>SemiContinuous</code></p> <p>Weibull distribution.</p> <p>The Weibull distribution is a continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The Weibull distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n... x,\n... lambda_=1,\n... k=0.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n... x,\n... lambda_=2,\n... k=1.0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n... x,\n... lambda_=3,\n... k=1.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Weibull distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}     \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>where \\(\\lambda\\) is the scale parameter and \\(k\\) is the shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> required <code>k</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class WeibullDistribution(SemiContinuous):\n    r\"\"\"Weibull distribution.\n\n    The Weibull distribution is a continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The Weibull distribution has\n    applications in various fields, such as finance, biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n        ... x,\n        ... lambda_=1,\n        ... k=0.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n        ... x,\n        ... lambda_=2,\n        ... k=1.0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n        ... x,\n        ... lambda_=3,\n        ... k=1.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Weibull distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}\n            \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n\n        where $\\lambda$ is the scale parameter and $k$ is the shape parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda (float): Scale parameter. Defaults to 1.\n        k (float): Shape parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        lambda_: float = 1.0,\n        k: float = 1.0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if lambda_ &lt; 0:\n            msg = \"lambda_\"\n            raise NotAPositiveNumberError(msg, lambda_)\n        if k &lt;= 0:\n            msg = \"k\"\n            raise NotLargerThanZeroError(msg, k)\n\n        super().__init__(*x, cumulative=cumulative)\n        self.lambda_ = lambda_\n        self.k = k\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.k\n            / self.lambda_\n            * (self._x / self.lambda_) ** (self.k - 1)\n            * np.exp(-((self._x / self.lambda_) ** self.k))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.lambda_ * gamma(1 + 1 / self.k),\n            variance=self.lambda_**2\n            * (gamma(1 + 2 / self.k) - gamma(1 + 1 / self.k) ** 2),\n            mode=self.lambda_ * (self.k - 1) ** (1 / self.k) if self.k &gt; 1 else 0,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.__init__","title":"<code>__init__(*x, lambda_=1.0, k=1.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    lambda_: float = 1.0,\n    k: float = 1.0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if lambda_ &lt; 0:\n        msg = \"lambda_\"\n        raise NotAPositiveNumberError(msg, lambda_)\n    if k &lt;= 0:\n        msg = \"k\"\n        raise NotLargerThanZeroError(msg, k)\n\n    super().__init__(*x, cumulative=cumulative)\n    self.lambda_ = lambda_\n    self.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        self.k\n        / self.lambda_\n        * (self._x / self.lambda_) ** (self.k - 1)\n        * np.exp(-((self._x / self.lambda_) ** self.k))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution","title":"<code>GeneralizedExtremeValueDistribution</code>","text":"<p>               Bases: <code>ContinuousMixed</code></p> <p>Generalized extreme value distribution.</p> <p>The generalized extreme value distribution is a family of continuous probability distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet and Weibull families also known as type I, II and III extreme value distributions. The generalized extreme value distribution is also sometimes referred to as the Fisher-Tippett distribution or the extreme value type I distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedExtremeValueDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized extreme value distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right] \\exp \\left[ - \\exp \\left( - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized extreme value distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0.0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedExtremeValueDistribution(ContinuousMixed):\n    r\"\"\"Generalized extreme value distribution.\n\n    The generalized extreme value distribution is a family of continuous probability\n    distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet\n    and Weibull families also known as type I, II and III extreme value distributions.\n    The generalized extreme value distribution is also sometimes referred to as the\n    Fisher-Tippett distribution or the extreme value type I distribution.\n\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedExtremeValueDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n\n    Notes:\n        The generalized extreme value distribution is defined as follows for probability\n        density function:\n\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta\n        \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma}\n        \\right) \\right] \\exp \\left[ - \\exp \\left( -\n        \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n        The generalized extreme value distribution is defined as follows for cumulative\n        distribution function:\n\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x -\n        \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right]\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        zeta (float): Shape parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    @property\n    def t_factor(self) -&gt; UniversalArray:\n        \"\"\"Factor of the t-distribution.\"\"\"\n        if self.zeta == 0:\n            return np.exp(-self._x - self.mu) / self.sigma\n        return np.exp(-((1 + self.zeta * self._x) ** (-1 / self.zeta))) / self.sigma\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\n        return self.t_factor**self.zeta * np.exp(-self.t_factor)\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\n        return np.exp(-self.t_factor)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the gen. extreme value distribution.\"\"\"\n        if self.zeta != 0 and self.zeta &lt; 1:\n            mean = self.mu + self.sigma * (gamma(1 - self.zeta) - 1) / self.zeta\n        elif self.zeta == 0:\n            mean = self.mu + self.sigma * np.euler_gamma\n        else:\n            mean = np.inf\n\n        if self.zeta != 0 and self.zeta &lt; 0.5:  # noqa: PLR2004\n            variance = (\n                self.sigma**2\n                * (gamma(1 - 2 * self.zeta) - gamma(1 - self.zeta) ** 2)\n                / self.zeta**2\n            )\n        elif self.zeta == 0:\n            variance = self.sigma**2 * np.pi**2 / 6\n        else:\n            variance = np.inf\n\n        if self.zeta != 0:\n            mode = self.mu + self.sigma * (1 - self.zeta ** (-1)) ** (-1 / self.zeta)\n        else:\n            mode = self.mu\n        return SummaryStatisticsAPI(\n            mean=mean,\n            variance=variance,\n            mode=mode,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the gen. extreme value distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.t_factor","title":"<code>t_factor</code>  <code>property</code>","text":"<p>Factor of the t-distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the gen. extreme value distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\n    return np.exp(-self.t_factor)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the gen. extreme value distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\n    return self.t_factor**self.zeta * np.exp(-self.t_factor)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution","title":"<code>GeneralizedParetoDistribution</code>","text":"<p>               Bases: <code>ContinuousMixed</code></p> <p>Generalized Pareto distribution.</p> <p>The generalized Pareto distribution is a family of continuous probability distributions that includes the exponential, Weibull, and uniform distributions. The generalized Pareto distribution is often used to model the tails of another distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized Pareto distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta - 1} &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized Pareto distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\begin{cases} 1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if } \\zeta \\neq 0 \\\\ 1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedParetoDistribution(ContinuousMixed):\n    r\"\"\"Generalized Pareto distribution.\n\n    The generalized Pareto distribution is a family of continuous probability\n    distributions that includes the exponential, Weibull, and uniform distributions.\n    The generalized Pareto distribution is often used to model the tails of another\n    distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The generalized Pareto distribution is defined as follows for probability\n        density function:\n\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta -\n        1} &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if }\n        \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n        The generalized Pareto distribution is defined as follows for cumulative\n        distribution function:\n\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if }\n        \\zeta \\neq 0 \\\\\n        1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        zeta (float): Shape parameter. Defaults to 0.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        zeta: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the generalized Pareto distribution.\"\"\"\n        if (min_x := np.min(x)) &lt; 0:\n            msg = \"*x\"\n            raise NotAPositiveNumberError(msg, number=float(min_x))\n        super().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\n        if self.zeta == 0:\n            return np.exp(-(self._x - self.mu) / self.sigma)\n        return (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n            -1 / (self.zeta + 1)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\n        if self.zeta == 0:\n            return 1 - np.exp(-(self._x - self.mu) / self.sigma)\n        return 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n            -1 / self.zeta\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the generalized Pareto distribution.\"\"\"\n        SummaryStatisticsAPI(\n            mean=self.mu + self.sigma / (1 - self.zeta) if self.zeta &lt; 1 else np.inf,\n            variance=(\n                self.sigma**2 / (1 - self.zeta) ** 2 / (1 - 2 * self.zeta)\n                if self.zeta &lt; 0.5  # noqa: PLR2004\n                else np.inf\n            ),\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the generalized Pareto distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, zeta=0, cumulative=False)</code>","text":"<p>Initialize the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    zeta: float = 0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the generalized Pareto distribution.\"\"\"\n    if (min_x := np.min(x)) &lt; 0:\n        msg = \"*x\"\n        raise NotAPositiveNumberError(msg, number=float(min_x))\n    super().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\n    if self.zeta == 0:\n        return 1 - np.exp(-(self._x - self.mu) / self.sigma)\n    return 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n        -1 / self.zeta\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\n    if self.zeta == 0:\n        return np.exp(-(self._x - self.mu) / self.sigma)\n    return (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n        -1 / (self.zeta + 1)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution","title":"<code>CauchyDistribution</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Cauchy distribution.</p> <p>The Cauchy distribution is a continuous probability distribution that has no mean or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n... x,\n... gamma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n... x,\n... gamma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n... x,\n... gamma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cauchy distribution is defined as:</p> \\[ f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 + \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]} \\] <p>where \\(x_0\\) is the location parameter and \\(\\gamma\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Cauchy distribution is:</p> \\[ F(x | x_0, \\gamma) = \\frac{1}{\\pi} \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>gamma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class CauchyDistribution(ContinuousDistributionBase):\n    r\"\"\"Cauchy distribution.\n\n    The Cauchy distribution is a continuous probability distribution that has no mean\n    or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n        ... x,\n        ... gamma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n        ... x,\n        ... gamma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n        ... x,\n        ... gamma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Cauchy distribution is defined as:\n\n        $$\n        f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 +\n        \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]}\n        $$\n\n        where $x_0$ is the location parameter and $\\gamma$ is the scale parameter.\n\n        The cumulative distribution function (CDF) of the Cauchy distribution is:\n\n        $$\n        F(x | x_0, \\gamma) = \\frac{1}{\\pi}\n        \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2}\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        gamma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        gamma: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if gamma &lt;= 0:\n            msg = \"gamma must be positive\"\n            raise ValueError(msg)\n        self.gamma = gamma\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.nan,\n            variance=np.nan,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.__init__","title":"<code>__init__(*x, mu=0, gamma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    gamma: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if gamma &lt;= 0:\n        msg = \"gamma must be positive\"\n        raise ValueError(msg)\n    self.gamma = gamma\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n    \"\"\"Return the probability density function.\"\"\"\n    return 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution","title":"<code>ExponentialDistribution</code>","text":"<p>               Bases: <code>ContinuousWLambda</code></p> <p>Exponential distribution.</p> <p>The exponential distribution is a continuous probability distribution that describes the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is a one-parameter family of curves, with the rate parameter \\(\\lambda\\) controlling the shape of the distribution. The exponential distribution is widely used in reliability theory, queueing theory, and other fields.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n... x,\n... lambda_=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n... x,\n... lambda_=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n... x,\n... lambda_=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The exponential distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda) = \\lambda e^{-\\lambda x} \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda) = 1 - e^{-\\lambda x} \\] <p>where \\(\\lambda\\) is the rate parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda_</code> <code>float</code> <p>Rate parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class ExponentialDistribution(ContinuousWLambda):\n    r\"\"\"Exponential distribution.\n\n    The exponential distribution is a continuous probability distribution that\n    describes the time between events in a Poisson process, where events occur\n    continuously and independently at a constant average rate. It is a one-parameter\n    family of curves, with the rate parameter $\\lambda$ controlling the shape of the\n    distribution. The exponential distribution is widely used in reliability theory,\n    queueing theory, and other fields.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n        ... x,\n        ... lambda_=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n        ... x,\n        ... lambda_=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n        ... x,\n        ... lambda_=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The exponential distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\lambda) = \\lambda e^{-\\lambda x}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\lambda) = 1 - e^{-\\lambda x}\n        $$\n\n        where $\\lambda$ is the rate parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda_ (float): Rate parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return self.lambda_ * np.exp(-self.lambda_ * self._x)\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-self.lambda_ * self._x)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=1 / self.lambda_,\n            variance=1 / self.lambda_**2,\n            mode=0,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 - np.exp(-self.lambda_ * self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n    \"\"\"Return the probability density function.\"\"\"\n    return self.lambda_ * np.exp(-self.lambda_ * self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution","title":"<code>GaussianDistribution</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Gaussian distribution.</p> <p>The Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GaussianDistribution(ContinuousWSigma):\n    r\"\"\"Gaussian distribution.\n\n    The Gaussian distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gaussian distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.sigma**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        1\n        / (self.sigma * np.sqrt(2 * np.pi))\n        * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution","title":"<code>GeneralizedNormalDistribution</code>","text":"<p>               Bases: <code>ContinuousWBeta</code></p> <p>Generalized normal distribution.</p> <p>The generalized normal distribution is a probability distribution that extends the normal distribution to incorporate an additional shape parameter, allowing for greater flexibility in modeling a wider range of data distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedNormalDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}   \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2} \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha}, \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma \\left(\\frac{1}{\\alpha}\\right)}\\right) \\] <p>where \\(\\alpha\\) is the shape parameter, \\(\\beta\\) is the scale parameter, and \\(\\mu\\) is the location parameter plus \\(\\Gamma\\) as the gamma function. The PDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha, \\beta &gt; 0\\). The CDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha &gt; 0\\) and rquires the unnormalized lower incomplete gamma function.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GeneralizedNormalDistribution(ContinuousWBeta):\n    r\"\"\"Generalized normal distribution.\n\n    The generalized normal distribution is a probability distribution that extends the\n    normal distribution to incorporate an additional shape parameter, allowing for\n    greater flexibility in modeling a wider range of data distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedNormalDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The generalized normal distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}\n          \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2}\n        \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha},\n        \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma\n        \\left(\\frac{1}{\\alpha}\\right)}\\right)\n        $$\n\n        where $\\alpha$ is the shape parameter, $\\beta$ is the scale parameter, and\n        $\\mu$ is the location parameter plus $\\Gamma$ as the gamma function.\n        The PDF is defined for $x \\in \\mathbb{R}$ and $\\alpha, \\beta &gt; 0$.\n        The CDF is defined for $x \\in \\mathbb{R}$ and $\\alpha &gt; 0$ and rquires the\n        unnormalized lower incomplete gamma function.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        alpha (float): Shape parameter. Defaults to 1.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        alpha: float = 1,\n        beta: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if beta &lt; 0:\n            msg = \"beta\"\n            raise NotAPositiveNumberError(msg, beta)\n        if alpha &lt;= 0:\n            msg = \"alpha\"\n            raise NotLargerThanZeroError(msg, alpha)\n\n        super().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.beta\n            / (2 * self.alpha * gamma(1.0 / self.beta))\n            * np.exp(-(np.abs((self._x - self.mu) / self.alpha) ** self.beta))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 + np.sign(self._x - self.mu) * (\n            1 / (2 * gamma(1 / self.beta))\n        ) * gammainc(\n            1 / self.beta,\n            np.abs((self._x - self.mu) / self.alpha) ** self.beta,\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.alpha**2 * gamma(3 / self.beta) / gamma(1 / self.beta),\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.__init__","title":"<code>__init__(*x, mu=0, alpha=1, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    alpha: float = 1,\n    beta: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if beta &lt; 0:\n        msg = \"beta\"\n        raise NotAPositiveNumberError(msg, beta)\n    if alpha &lt;= 0:\n        msg = \"alpha\"\n        raise NotLargerThanZeroError(msg, alpha)\n\n    super().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\n    self.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 0.5 + np.sign(self._x - self.mu) * (\n        1 / (2 * gamma(1 / self.beta))\n    ) * gammainc(\n        1 / self.beta,\n        np.abs((self._x - self.mu) / self.alpha) ** self.beta,\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        self.beta\n        / (2 * self.alpha * gamma(1.0 / self.beta))\n        * np.exp(-(np.abs((self._x - self.mu) / self.alpha) ** self.beta))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution","title":"<code>GumbelDistribution</code>","text":"<p>               Bases: <code>ContinuousWBeta</code></p> <p>Gumbel distribution.</p> <p>The Gumbel distribution is a continuous probability distribution that is used to model the distribution of the maximum (or the minimum) of a number of samples of various distributions. It is a two-parameter family of curves, with the location parameter \\(\\mu\\) controlling the location of the distribution and the scale parameter \\(\\beta\\) controlling the spread of the distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n... x,\n... mu=0,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n... x,\n... mu=5,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n... x,\n... mu=10,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gumbel distribution is defined as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}} \\] <p>where \\(\\mu\\) is the location parameter and \\(\\beta\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Gumbel distribution is:</p> \\[ F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GumbelDistribution(ContinuousWBeta):\n    r\"\"\"Gumbel distribution.\n\n    The Gumbel distribution is a continuous probability distribution that is used to\n    model the distribution of the maximum (or the minimum) of a number of samples of\n    various distributions. It is a two-parameter family of curves, with the location\n    parameter $\\mu$ controlling the location of the distribution and the scale\n    parameter $\\beta$ controlling the spread of the distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n        ... x,\n        ... mu=0,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n        ... x,\n        ... mu=5,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n        ... x,\n        ... mu=10,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gumbel distribution is defined as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta}\n        e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}}\n        $$\n\n        where $\\mu$ is the location parameter and $\\beta$ is the scale parameter.\n\n        The cumulative distribution function (CDF) of the Gumbel distribution is:\n\n        $$\n        F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}}\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / self.beta\n            * np.exp(\n                -(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n                / self.beta,\n            )\n        )\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu + self.beta * np.euler_gamma,\n            variance=(np.pi**2 / 6) * self.beta**2,\n            mode=self.mu + self.beta * np.log(np.log(3)),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        1\n        / self.beta\n        * np.exp(\n            -(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n            / self.beta,\n        )\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution","title":"<code>LaplaceDistribution</code>","text":"<p>               Bases: <code>ContinuousWBeta</code></p> <p>Laplace distribution.</p> <p>The Laplace distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Laplace distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu) \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right) \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LaplaceDistribution(ContinuousWBeta):\n    r\"\"\"Laplace distribution.\n\n    The Laplace distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Laplace distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu)\n        \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right)\n        $$\n\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return np.array(\n            0.5\n            + 0.5\n            * np.sign(self._x - self.mu)\n            * (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=2 * self.beta**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return np.array(\n        0.5\n        + 0.5\n        * np.sign(self._x - self.mu)\n        * (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution","title":"<code>LogisticDistribution</code>","text":"<p>               Bases: <code>ContinuousWBeta</code></p> <p>Logistic distribution.</p> <p>The logistic distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Logistic distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)} \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LogisticDistribution(ContinuousWBeta):\n    r\"\"\"Logistic distribution.\n\n    The logistic distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Logistic distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x -\n        \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)}\n        $$\n\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return np.array(\n            1\n            / self.beta\n            * np.exp(-(self._x - self.mu) / self.beta)\n            / (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=(np.pi**2 * self.beta**2) / 3,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    return 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return np.array(\n        1\n        / self.beta\n        * np.exp(-(self._x - self.mu) / self.beta)\n        / (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution","title":"<code>SkewGaussianDistribution</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Skew Gaussian distribution.</p> <p>The Skew Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions with skewness.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... SkewGaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=0,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=1,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=-1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Skew Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation, and \\(\\alpha\\) is the skewness.</p> <p>The CDF is not available in closed form.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Skewness. Defaults to 0.</p> <code>0</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class SkewGaussianDistribution(ContinuousWSigma):\n    r\"\"\"Skew Gaussian distribution.\n\n    The Skew Gaussian distribution is a continuous probability distribution that is\n    widely used in statistics to describe the normal distributions with skewness.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... SkewGaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=-1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Skew Gaussian distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n        \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation, and $\\alpha$ is the\n        skewness.\n\n        The CDF is not available in closed form.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        alpha (float): Skewness. Defaults to 0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        alpha: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n            * (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.sigma**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, alpha=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    alpha: float = 0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n    self.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    return (\n        1\n        / (self.sigma * np.sqrt(2 * np.pi))\n        * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n        * (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution","title":"<code>VoigtDistribution</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Voigt distribution.</p> <p>The Voigt distribution is a continuous probability distribution that is widely used in physics and spectroscopy to describe the line shape of spectral lines. It is a convolution of a Gaussian distribution and a Lorentzian distribution, and is useful for modeling the effects of both natural and instrumental broadening on spectral lines.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... VoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Voigt distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>which can be further simplified to:</p> \\[ V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}} \\] <p>with \\(\\operatorname {Re} [w(z)\\) as the real part of the Faddeeva function and \\(z\\) as:</p> \\[ z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation and \\(\\gamma\\) is the Lorentzian width.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>gamma</code> <code>float</code> <p>Lorentzian width. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class VoigtDistribution(ContinuousWSigma):\n    r\"\"\"Voigt distribution.\n\n    The Voigt distribution is a continuous probability distribution that is widely used\n    in physics and spectroscopy to describe the line shape of spectral lines. It is a\n    convolution of a Gaussian distribution and a Lorentzian distribution, and is useful\n    for modeling the effects of both natural and instrumental broadening on spectral\n    lines.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... VoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Voigt distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n\n        which can be further simplified to:\n\n        $$\n        V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}}\n        $$\n\n        with $\\operatorname {Re} [w(z)$ as the real part of the Faddeeva function and\n        $z$ as:\n\n        $$\n        z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation and $\\gamma$ is the\n        Lorentzian width.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        gamma (float): Lorentzian width. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        sigma: float = 1,\n        gamma: float = 1,\n        mu: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if sigma &lt; 0:\n            msg = \"sigma\"\n            raise NotAPositiveNumberError(msg, sigma)\n        if gamma &lt; 0:\n            msg = \"gamma\"\n            raise NotAPositiveNumberError(msg, gamma)\n\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        self.gamma = gamma\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        z = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\n        return np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=0,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.__init__","title":"<code>__init__(*x, sigma=1, gamma=1, mu=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    sigma: float = 1,\n    gamma: float = 1,\n    mu: float = 0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if sigma &lt; 0:\n        msg = \"sigma\"\n        raise NotAPositiveNumberError(msg, sigma)\n    if gamma &lt; 0:\n        msg = \"gamma\"\n        raise NotAPositiveNumberError(msg, gamma)\n\n    super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n    self.gamma = gamma\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n    z = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\n    return np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution","title":"<code>BernoulliDistribution</code>","text":"<p>               Bases: <code>DiscreteP</code></p> <p>Bernoulli distribution.</p> <p>The Bernoulli distribution is a discrete distribution with two possible outcomes, 0 and 1. It is the simplest discrete distribution. It is a special case of the binomial distribution where a single trial is conducted (n=1).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BernoulliDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bernoulli distribution is defined as follows:</p> \\[ f(x;p) = p^x (1-p)^{1-x} \\] <p>where \\(x \\in \\{0, 1\\}\\) and \\(p \\in [0, 1]\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BernoulliDistribution(DiscreteP):\n    r\"\"\"Bernoulli distribution.\n\n    The Bernoulli distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is the simplest discrete distribution. It is a\n    special case of the binomial distribution where a single trial is\n    conducted (n=1).\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BernoulliDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bernoulli distribution is defined as follows:\n\n        $$\n        f(x;p) = p^x (1-p)^{1-x}\n        $$\n\n        where $x \\in \\{0, 1\\}$ and $p \\in [0, 1]$.\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n    \"\"\"\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\n        return self.p**self._x * (self.q) ** (1 - self._x)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Bernoulli distribution.\"\"\"\n\n        def _mode() -&gt; float | tuple[float, float]:\n            \"\"\"Mode of the Bernoulli distribution.\"\"\"\n            threshold = 0.5\n            if self.p &gt; threshold:\n                return 1\n            return 0 if self.p &lt; threshold else (0, 1)\n\n        return SummaryStatisticsAPI(\n            mean=self.p,\n            variance=self.p * self.q,\n            mode=_mode(),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Bernoulli distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Bernoulli distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\n    return self.p**self._x * (self.q) ** (1 - self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution","title":"<code>BinomialDistribution</code>","text":"<p>               Bases: <code>DiscreteP</code></p> <p>Binomial distribution.</p> <p>The binomial distribution is a discrete distribution with two possible outcomes, 0 and 1. It is a generalization of the Bernoulli distribution where \\(n\\) trials are conducted.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n&gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n&gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The binomial distribution is defined as follows for probability mass function:</p> \\[ f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\).</p> <p>The binomial distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\). This expression is also known as the regularized incomplete beta function.</p> \\[ F(x;n,p) = I_{1-p}(n-k, k+1) \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> required <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BinomialDistribution(DiscreteP):\n    r\"\"\"Binomial distribution.\n\n    The binomial distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is a generalization of the Bernoulli distribution\n    where $n$ trials are conducted.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The binomial distribution is defined as follows for probability mass function:\n\n        $$\n        f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n\n        The binomial distribution is defined as follows for cumulative distribution\n        function:\n\n        $$\n        F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        This expression is also known as the regularized incomplete beta function.\n\n        $$\n        F(x;n,p) = I_{1-p}(n-k, k+1)\n        $$\n\n\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n        cumulative: If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n        \"\"\"Initialize the Binomial distribution.\"\"\"\n        super().__init__(*x, p=p, cumulative=cumulative)\n        self.n = np.full_like(self._x, self._x[-1])\n        self.k = self._x\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Binomial distribution.\"\"\"\n        return (\n            combinations(self.n, self.k) * self.p**self.k * self.q ** (self.n - self.k)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\n        return np.array(\n            [\n                np.sum(\n                    [\n                        combinations(self.n[i], k)\n                        * self.p**k\n                        * self.q ** (self.n[i] - k)\n                        for k in range(self.k[i] + 1)\n                    ],\n                )\n                for i in range(len(self._x))\n            ],\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Binomial distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.n.max() * self.p,\n            variance=self.n.max() * self.p * self.q,\n            mode=math.ceil((self.n.max() + 1) * self.p) - 1,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Binomial distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.__init__","title":"<code>__init__(*x, p, cumulative=False)</code>","text":"<p>Initialize the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n    \"\"\"Initialize the Binomial distribution.\"\"\"\n    super().__init__(*x, p=p, cumulative=cumulative)\n    self.n = np.full_like(self._x, self._x[-1])\n    self.k = self._x\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\n    return np.array(\n        [\n            np.sum(\n                [\n                    combinations(self.n[i], k)\n                    * self.p**k\n                    * self.q ** (self.n[i] - k)\n                    for k in range(self.k[i] + 1)\n                ],\n            )\n            for i in range(len(self._x))\n        ],\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Probability mass function of the Binomial distribution.\"\"\"\n    return (\n        combinations(self.n, self.k) * self.p**self.k * self.q ** (self.n - self.k)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution","title":"<code>BoltzmannDistribution</code>","text":"<p>               Bases: <code>DiscretePure</code></p> <p>Boltzmann distribution.</p> <p>The Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of energy among particles in a system at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... BoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n&gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n&gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n&gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Boltzmann distribution is defined for the probability mass function as:</p> \\[ F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right) \\] <p>where \\(p_i\\) is the probability of a system being in state \\(i\\), \\(p_j\\) is the probability of a system being in state \\(j\\), \\(\\varepsilon_i\\) is the energy of state \\(i\\), \\(\\varepsilon_j\\) is the energy of state \\(j\\), \\(k\\) is the Boltzmann constant, and \\(T\\) is the temperature.</p> Info <p>For simplicity, the exponentianal term of the Boltzmann factor \\(k\\) is simpflified from  \\(1.380649 \\times 10^{-23}\\) to 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>energy_i</code> <code>float</code> <p>The energy of state \\(i\\).</p> required <code>energy_j</code> <code>float</code> <p>The energy of state \\(j\\).</p> required <code>temperature</code> <code>float</code> <p>The temperature of the system.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class BoltzmannDistribution(DiscretePure):\n    r\"\"\"Boltzmann distribution.\n\n    The Boltzmann distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of energy among particles\n    in a system at a given temperature in statistical mechanics and thermodynamics.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... BoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n        &gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n        &gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n        &gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Boltzmann distribution is defined for the probability mass function as:\n\n        $$\n        F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac\n        {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right)\n        $$\n\n        where $p_i$ is the probability of a system being in state $i$, $p_j$ is the\n        probability of a system being in state $j$, $\\varepsilon_i$ is the energy of\n        state $i$, $\\varepsilon_j$ is the energy of state $j$, $k$ is the Boltzmann\n        constant, and $T$ is the temperature.\n\n    Info:\n        For simplicity, the exponentianal term of the Boltzmann factor $k$ is\n        simpflified from  $1.380649 \\times 10^{-23}$ to 1.\n\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        energy_i (float): The energy of state $i$.\n        energy_j (float): The energy of state $j$.\n        temperature (float): The temperature of the system.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        energy_i: float,\n        energy_j: float,\n        k: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Boltzmann distribution.\"\"\"\n        if energy_i == energy_j:\n            msg = \"'energy_i' and 'energy_j' cannot be equal.\"\n            raise ValueError(msg)\n        if energy_i &lt; 0:\n            raise NotLargerThanZeroError(\n                var_number=\"energy_i\",\n                number=energy_i,\n            )\n        if energy_j &lt; 0:\n            raise NotLargerThanZeroError(\n                var_number=\"energy_j\",\n                number=energy_j,\n            )\n        if (min_temp := float(np.min(x))) &lt;= 0:\n            raise NotLargerThanZeroError(\n                var_number=\"temperature\",\n                number=min_temp,\n            )\n        super().__init__(*x)\n        self.energy_i = energy_i\n        self.energy_j = energy_j\n        self.temperature = self._x\n        self.k = k\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\n        return np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Boltzmann distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Boltzmann distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.__init__","title":"<code>__init__(*x, energy_i, energy_j, k=1)</code>","text":"<p>Initialize the Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    energy_i: float,\n    energy_j: float,\n    k: float = 1,\n) -&gt; None:\n    \"\"\"Initialize the Boltzmann distribution.\"\"\"\n    if energy_i == energy_j:\n        msg = \"'energy_i' and 'energy_j' cannot be equal.\"\n        raise ValueError(msg)\n    if energy_i &lt; 0:\n        raise NotLargerThanZeroError(\n            var_number=\"energy_i\",\n            number=energy_i,\n        )\n    if energy_j &lt; 0:\n        raise NotLargerThanZeroError(\n            var_number=\"energy_j\",\n            number=energy_j,\n        )\n    if (min_temp := float(np.min(x))) &lt;= 0:\n        raise NotLargerThanZeroError(\n            var_number=\"temperature\",\n            number=min_temp,\n        )\n    super().__init__(*x)\n    self.energy_i = energy_i\n    self.energy_j = energy_j\n    self.temperature = self._x\n    self.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\n    return np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution","title":"<code>GausKuzminDistribution</code>","text":"<p>               Bases: <code>DiscretePure</code></p> <p>Gaus-Kuzmin distribution.</p> <p>The Gaus-Kuzmin distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaus-Kuzmin distribution is defined for the PMF as follows:</p> \\[ F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right] \\] <p>where \\(k\\) is the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>The Gaus-Kuzmin distribution is defined for the CDF as follows:</p> \\[ F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right) \\] <p>For more information about the Gaus-Kuzmin distribution, see also en.wikipedia.org/wiki/Gauss-Kuzmin_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class GausKuzminDistribution(DiscretePure):\n    r\"\"\"Gaus-Kuzmin distribution.\n\n    The Gaus-Kuzmin distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of the number of steps\n    taken by a random walker on a line before reaching a given distance from the origin.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gaus-Kuzmin distribution is defined for the PMF as\n        follows:\n\n        $$\n        F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right]\n        $$\n\n        where $k$ is the number of steps taken by a random walker on a line before\n        reaching a given distance from the origin.\n\n        The Gaus-Kuzmin distribution is defined for the CDF as follows:\n\n        $$\n        F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right)\n        $$\n\n        For more information about the Gaus-Kuzmin distribution, see also\n        &lt;https://en.wikipedia.org/wiki/Gauss-Kuzmin_distribution&gt;\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n    \"\"\"\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\n        return -np.log2(1 - 1 / (self._x + 1) ** 2)\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\n        return 1 - np.log2((self._x + 2) / (self._x + 1))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Gaus-Kuzmin distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.inf,\n            variance=np.inf,\n            mode=1,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Gaus-Kuzmin distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Gaus-Kuzmin distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\n    return 1 - np.log2((self._x + 2) / (self._x + 1))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Gaus-Kuzmin distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\n    return -np.log2(1 - 1 / (self._x + 1) ** 2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution","title":"<code>MaxwellBoltzmannDistribution</code>","text":"<p>               Bases: <code>DiscretePure</code></p> <p>Maxwell-Boltzmann distribution.</p> <p>The Maxwell-Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the speeds of particles in a gas at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n... x,\n... a=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n... x,\n... a=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n... x,\n... a=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"MaxwellBoltzmannDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The Maxwell-Boltzmann distribution is defined for the PMF as follows:</p> \\[ F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}} \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>where \\(x\\) is the speed of a particle, \\(a\\) is the most probable speed of \\(a\\), \\(\\pi\\) is the constant pi, and \\(a\\) is a parametrization.</p> <p>The Maxwell-Boltzmann distribution is defined for the CDF as follows:</p> \\[ F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right) -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>For more informtation about the Maxwell-Boltzmann distribution, see also en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>a(float)</code> <p>A parametrization for the Co-Factors of the Maxwell-Boltzmann distribution.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class MaxwellBoltzmannDistribution(DiscretePure):\n    r\"\"\"Maxwell-Boltzmann distribution.\n\n    The Maxwell-Boltzmann distribution is a discrete probability distribution with\n    discrete infinite support. It is used to describe the distribution of the speeds of\n    particles in a gas at a given temperature in statistical mechanics and\n    thermodynamics.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"MaxwellBoltzmannDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The Maxwell-Boltzmann distribution is defined for the PMF as follows:\n\n        $$\n        F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}}\n        \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n\n        where $x$ is the speed of a particle, $a$ is the most probable speed of $a$,\n        $\\pi$ is the constant pi, and $a$ is a parametrization.\n\n        The Maxwell-Boltzmann distribution is defined for the CDF as follows:\n\n        $$\n        F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right)\n        -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp\n        \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n\n        For more informtation about the Maxwell-Boltzmann distribution, see also\n        https://en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution\n\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        a(float): A parametrization for the Co-Factors of the Maxwell-Boltzmann\n            distribution.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n        \"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotAPositiveNumberError(msg, a)\n        super().__init__(*x, cumulative=cumulative)\n        self.a = a\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\n        return (\n            np.sqrt(2 / np.pi)\n            * (self._x**2 / self.a**3)\n            * np.exp(-(self._x**2) / (2 * self.a**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\n        return erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n            2 / np.pi,\n        ) * self._x / self.a * np.exp(-(self._x**2) / (2 * self.a**2))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Maxwell-Boltzmann distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=2 * np.sqrt(2 / np.pi) * self.a,\n            variance=(self.a**2 * (3 * np.pi - 8)) / (np.pi),\n            mode=np.sqrt(2) * self.a,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Maxwell-Boltzmann distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.__init__","title":"<code>__init__(*x, a, cumulative=False)</code>","text":"<p>Initialize the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n    \"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\n    if a &lt;= 0:\n        msg = \"a\"\n        raise NotAPositiveNumberError(msg, a)\n    super().__init__(*x, cumulative=cumulative)\n    self.a = a\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\n    return erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n        2 / np.pi,\n    ) * self._x / self.a * np.exp(-(self._x**2) / (2 * self.a**2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\n    return (\n        np.sqrt(2 / np.pi)\n        * (self._x**2 / self.a**3)\n        * np.exp(-(self._x**2) / (2 * self.a**2))\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape","title":"<code>AsymmetricRamanLineshape</code>","text":"<p>               Bases: <code>ContinousAsymmetricPseudo</code></p> <p>Asymmetric Raman lineshape distribution.</p> <p>The Asymmetric Raman lineshape distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for Raman spectroscopy data analysis.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... AsymmetricRamanLineshape\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Asymmetric Raman lineshape distribution is defined as follows for probability density [^1]:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma)) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\) and the damped sigmoidal term \\(p(x)\\):</p> \\[ p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right) \\] <p>[^1] Korepanov, V, I.and Sedlovets, D. M. (2018),     An asymmetric fitting function for condensed-phase Raman spectroscopy,     Analyst RSC, 2674-2679 (143)     dx.doi.org/10.1039/C8AN00710A</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class AsymmetricRamanLineshape(ContinousAsymmetricPseudo):\n    r\"\"\"Asymmetric Raman lineshape distribution.\n\n    The Asymmetric Raman lineshape distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for Raman spectroscopy data analysis.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... AsymmetricRamanLineshape\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Asymmetric Raman lineshape distribution is defined as follows for\n        probability density [^1]:\n\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot\n        p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma))\n        $$\n\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$ and the\n        damped sigmoidal term $p(x)$:\n\n        $$\n        p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot\n        \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right)\n        $$\n\n        [^1] Korepanov, V, I.and Sedlovets, D. M. (2018),\n            An asymmetric fitting function for condensed-phase Raman spectroscopy,\n            Analyst RSC, 2674-2679 (143)\n            http://dx.doi.org/10.1039/C8AN00710A\n\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\n        p = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n            -((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n        )\n        return (1 - self.eta) * GaussianDistribution(\n            self._x * p,\n            mu=self.mu,\n            sigma=self.sigma,\n        ).probability_density_function() + self.eta * LorentzianDistribution(\n            self._x * p,\n            mu=self.mu,\n            gamma=self.sigma,\n        ).probability_density_function()\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Asym. Raman lineshape distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Asym. Raman lineshape distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Asym. Raman lineshape distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\n    p = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n        -((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n    )\n    return (1 - self.eta) * GaussianDistribution(\n        self._x * p,\n        mu=self.mu,\n        sigma=self.sigma,\n    ).probability_density_function() + self.eta * LorentzianDistribution(\n        self._x * p,\n        mu=self.mu,\n        gamma=self.sigma,\n    ).probability_density_function()\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution","title":"<code>CrystalBallDistribution</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Crystal Ball distribution.</p> <p>The Crystal Ball distribution, which is sometimes also called the Crystal Ball function, is a continuous but asymmetric probability distribution on the real line.[^1] This type of function is often used in physics to model the invariant mass of a particle or system of particles, especially when there is a known background contribution.[^2]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... CrystalBallDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n&gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n&gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Crystal Ball distribution is defined as follows for probability density</p> \\[ f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{ \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }} \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha \\end{cases}} \\] <p>with:</p> \\[ A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right| \\] \\[ N={\\frac  {1}{\\sigma (C+D)}} \\] \\[ C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}} \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf} \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right) \\] <p>See also: www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/ crystalball.html</p> <p>About the Normalization</p> <p>The normalization constant \\(N\\) might be not correct implemented because for the zero-division case \\(n=1\\) the normalization constant \\(N\\) is set to one to achieve a optical match with the reference figures of <sup>1</sup>.</p> <ol> <li> <p>Crystal Ball function. (2020, November 27). In Wikipedia. en.wikipedia.org/wiki/Crystal_Ball_function \u21a9</p> </li> <li> <p>Tomasz Skwarnicki, A study of the radiative CASCADE transitions between _ the Upsilon-Prime and Upsilon resonances_, PHD-Thesis, DESY-F31-86-02, Apr. 1986\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the Gaussian region.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the Gaussian region.</p> <code>1</code> <code>n</code> <code>float</code> <p>The power of the power-law region.</p> <code>1</code> <code>alpha</code> <code>float</code> <p>: The location of the transition between the Gaussian and power-law regions.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class CrystalBallDistribution(ContinuousWSigma):\n    r\"\"\"Crystal Ball distribution.\n\n    The Crystal Ball distribution, which is sometimes also called the Crystal\n    Ball function, is a continuous but asymmetric probability distribution on the real\n    line.[^1] This type of function is often used in physics to model the invariant\n    mass of a particle or system of particles, especially when there is a known\n    background contribution.[^2]\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... CrystalBallDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n        &gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n        &gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n\n\n    Notes:\n        The Crystal Ball distribution is defined as follows for probability density\n        [^2]:\n\n        $$\n        f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp\n        \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{\n        \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot\n        \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }}\n        \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha\n        \\end{cases}}\n        $$\n\n        with:\n\n        $$\n        A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp\n        \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n\n        $$\n        B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right|\n        $$\n\n        $$\n        N={\\frac  {1}{\\sigma (C+D)}}\n        $$\n\n        $$\n        C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}}\n        \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n\n        $$\n        D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf}\n        \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right)\n        $$\n\n        See also: https://www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/\n        crystalball.html\n\n        !!! warning \"About the Normalization\"\n            The normalization constant $N$ might be not correct implemented because\n            for the zero-division case $n=1$ the normalization constant $N$ is set to\n            one to achieve a optical match with the reference figures of [^2].\n\n        [^1]: Tomasz Skwarnicki, _A study of the radiative CASCADE transitions between_\n            _ the Upsilon-Prime and Upsilon resonances_, **PHD-Thesis**, DESY-F31-86-02,\n            Apr. 1986\n        [^2]: Crystal Ball function. (2020, November 27). _In Wikipedia._\n            https://en.wikipedia.org/wiki/Crystal_Ball_function\n\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the Gaussian region.\n        sigma (float): The standard deviation of the Gaussian region.\n        n (float): The power of the power-law region.\n        alpha (float):: The location of the transition between the Gaussian and\n            power-law regions.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        n: float = 1,\n        alpha: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Crystal Ball distribution.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma)\n\n        if n &lt;= 0:\n            raise NotLargerThanZeroError(number=n)\n\n        if alpha &lt; 0:\n            raise NotLargerThanZeroError(number=alpha)\n\n        self.n = n\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n        _a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n            -(self.alpha**2) / 2,\n        )\n        _b = self.n / abs(self.alpha) - abs(self.alpha)\n        if self.n == 1:\n            _n = self.n\n        else:\n            _c = self.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n            _d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n            _n = 1 / (self.sigma * (_c + _d))\n        return np.where(\n            (self._x - self.mu) / self.sigma &gt; -self.alpha,\n            _n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n            _n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Crystal Ball distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Crystal Ball distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, n=1, alpha=1)</code>","text":"<p>Initialize the Crystal Ball distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    n: float = 1,\n    alpha: float = 1,\n) -&gt; None:\n    \"\"\"Initialize the Crystal Ball distribution.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma)\n\n    if n &lt;= 0:\n        raise NotLargerThanZeroError(number=n)\n\n    if alpha &lt; 0:\n        raise NotLargerThanZeroError(number=alpha)\n\n    self.n = n\n    self.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Crystal Ball distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n    _a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n        -(self.alpha**2) / 2,\n    )\n    _b = self.n / abs(self.alpha) - abs(self.alpha)\n    if self.n == 1:\n        _n = self.n\n    else:\n        _c = self.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n        _d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n        _n = 1 / (self.sigma * (_c + _d))\n    return np.where(\n        (self._x - self.mu) / self.sigma &gt; -self.alpha,\n        _n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n        _n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution","title":"<code>ModifiedDoniachSunjicDistribution</code>","text":"<p>               Bases: <code>ContinousAsymmetricPseudo</code></p> <p>Doniach-Sunjic distribution.</p> <p>The Doniach-Sunjic distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for XPS/AES data analysis. See also: www.casaxps.com</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... ModifiedDoniachSunjicDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"ModifiedDoniachSunjicDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Warning <p>The Doniach-Sunjic distribution as defined for casaxps is not the same as used in the current implementation. In the current implementation, the damping factor is included into the lorentzian model.</p> Notes <p>The Doniach-Sunjic distribution is defined as follows for probability density:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma)) \\] <p>with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal is defined as:</p> \\[ p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\ 0 &amp; \\text{if } x \\geq \\mu \\end{cases} \\] <p>and the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: www.casaxps.com/help_manual/line_shapes.htm</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class ModifiedDoniachSunjicDistribution(ContinousAsymmetricPseudo):\n    r\"\"\"Doniach-Sunjic distribution.\n\n    The Doniach-Sunjic distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for XPS/AES data analysis. See also:\n    http://www.casaxps.com\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... ModifiedDoniachSunjicDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"ModifiedDoniachSunjicDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Warning:\n        The Doniach-Sunjic distribution as defined for **casaxps** is not the same as\n        used in the current implementation. In the current implementation, the damping\n        factor is included into the lorentzian model.\n\n    Notes:\n        The Doniach-Sunjic distribution is defined as follows for probability density:\n\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma))\n        $$\n\n        with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal\n        is defined as:\n\n        $$\n        p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot\n        \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\\n        0 &amp; \\text{if } x \\geq \\mu \\end{cases}\n        $$\n\n        and the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: http://www.casaxps.com/help_manual/line_shapes.htm\n\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\n        p = np.where(\n            self._x &lt; self.mu,\n            np.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n            0,\n        )\n        return (1 - self.eta) * GaussianDistribution(\n            self._x,\n            mu=self.mu,\n            sigma=self.sigma,\n        ).probability_density_function() + self.eta * LorentzianDistribution(\n            self._x * p,\n            mu=self.mu,\n            gamma=self.sigma,\n        ).probability_density_function()\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Doniach-Sunjic distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Doniach-Sunjic distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Doniach-Sunjic distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\n    p = np.where(\n        self._x &lt; self.mu,\n        np.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n        0,\n    )\n    return (1 - self.eta) * GaussianDistribution(\n        self._x,\n        mu=self.mu,\n        sigma=self.sigma,\n    ).probability_density_function() + self.eta * LorentzianDistribution(\n        self._x * p,\n        mu=self.mu,\n        gamma=self.sigma,\n    ).probability_density_function()\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution","title":"<code>PearsonVIIDistribution</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Pearson VII distribution.</p> <p>The Pearson VII distribution is a continuous probability distribution on the real line. It is a generalization of the Student's t-distribution and the Cauchy distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PearsonVIIDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n&gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n&gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n&gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n&gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n&gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pearson VII distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)} {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+ \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}} \\] <p><sup>1</sup> Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.     Journal of Applied Crystalography, 31(3), 474-476.     doi.org/10.1107/S0021889897011047</p> <p>See also: en.wikipedia.org/wiki/Pearson_distribution and www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>p</code> <code>float</code> <p>The shape parameter of the distribution.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PearsonVIIDistribution(ContinuousWSigma):\n    r\"\"\"Pearson VII distribution.\n\n    The Pearson VII distribution is a continuous probability distribution on the real\n    line. It is a generalization of the Student's t-distribution and the Cauchy\n    distribution. This function becomes popular for X-ray diffraction data analysis.[^1]\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PearsonVIIDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n        &gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n        &gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n        &gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n        &gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n        &gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Pearson VII distribution is defined as follows for probability density\n        [^1]:\n\n        $$\n        f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)}\n        {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+\n        \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}}\n        $$\n\n        [^1] Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.\n            Journal of Applied Crystalography, 31(3), 474-476.\n            https://doi.org/10.1107/S0021889897011047\n\n        See also: https://en.wikipedia.org/wiki/Pearson_distribution and\n        https://www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution.\n        sigma (float): The standard deviation of the distribution.\n        p (float): The shape parameter of the distribution.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        p: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Pearson VII distribution.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma)\n        self.p = p\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Pearson VII distribution.\"\"\"\n        return (\n            gammaln(self.p / 2)\n            / (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n            * (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Pearson VII distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Pearson VII distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, p=1)</code>","text":"<p>Initialize the Pearson VII distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    p: float = 1,\n) -&gt; None:\n    \"\"\"Initialize the Pearson VII distribution.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma)\n    self.p = p\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Pearson VII distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the Pearson VII distribution.\"\"\"\n    return (\n        gammaln(self.p / 2)\n        / (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n        * (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n    )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution","title":"<code>PseudoVoigtDistribution</code>","text":"<p>               Bases: <code>ContinousPseudo</code></p> <p>Pseudo-Voigt distribution.</p> <p>The Pseudo-Voigt distribution is a continuous probability distribution on the real line. It is a convolution of a Gaussian distribution and a Lorentzian distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PseudoVoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.1).__eval__\n&gt;&gt;&gt; y_2 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.2).__eval__\n&gt;&gt;&gt; y_3 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.3).__eval__\n&gt;&gt;&gt; y_4 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.4).__eval__\n&gt;&gt;&gt; y_5 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.5).__eval__\n&gt;&gt;&gt; y_6 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.6).__eval__\n&gt;&gt;&gt; y_7 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.7).__eval__\n&gt;&gt;&gt; y_8 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.8).__eval__\n&gt;&gt;&gt; y_9 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$f=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$f=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$f=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$f=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$f=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$f=0.6$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_7, label=r\"$f=0.7$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_8, label=r\"$f=0.8$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_9, label=r\"$f=0.9$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PseudoVoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pseudo-Voigt distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,\\eta)=(1 - \\eta) \\cdot \\frac {1}{\\sigma {\\sqrt {2\\pi }}}\\exp \\left(-{\\frac {(x-\\mu )^{2}}{2\\sigma^{2}}} \\right)+\\eta \\cdot {\\frac {1}{\\pi }}\\left( {\\frac {\\sigma }{(\\frac{\\sigma}{2})^{2}+(x-\\mu )^{2}}}\\right) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: en.wikipedia.org/wiki/Voigt_profile</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PseudoVoigtDistribution(ContinousPseudo):\n    r\"\"\"Pseudo-Voigt distribution.\n\n    The Pseudo-Voigt distribution is a continuous probability distribution on the real\n    line. It is a convolution of a Gaussian distribution and a Lorentzian distribution.\n    This function becomes popular for X-ray diffraction data analysis.[^1]\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PseudoVoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.1).__eval__\n        &gt;&gt;&gt; y_2 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.2).__eval__\n        &gt;&gt;&gt; y_3 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.3).__eval__\n        &gt;&gt;&gt; y_4 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.4).__eval__\n        &gt;&gt;&gt; y_5 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.5).__eval__\n        &gt;&gt;&gt; y_6 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.6).__eval__\n        &gt;&gt;&gt; y_7 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.7).__eval__\n        &gt;&gt;&gt; y_8 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.8).__eval__\n        &gt;&gt;&gt; y_9 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$f=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$f=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$f=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$f=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$f=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$f=0.6$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_7, label=r\"$f=0.7$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_8, label=r\"$f=0.8$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_9, label=r\"$f=0.9$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PseudoVoigtDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Pseudo-Voigt distribution is defined as follows for probability density\n\n        $$\n        f(x;\\mu ,\\sigma ,\\eta)=(1 - \\eta) \\cdot \\frac {1}{\\sigma\n        {\\sqrt {2\\pi }}}\\exp \\left(-{\\frac {(x-\\mu )^{2}}{2\\sigma^{2}}}\n        \\right)+\\eta \\cdot {\\frac {1}{\\pi }}\\left(\n        {\\frac {\\sigma }{(\\frac{\\sigma}{2})^{2}+(x-\\mu )^{2}}}\\right)\n        $$\n\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: https://en.wikipedia.org/wiki/Voigt_profile\n\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Pseudo-Voigt distribution.\"\"\"\n        return (1 - self.eta) * GaussianDistribution(\n            self._x,\n            mu=self.mu,\n            sigma=self.sigma,\n        ).probability_density_function() + self.eta * LorentzianDistribution(\n            self._x,\n            mu=self.mu,\n            gamma=self.sigma,\n        ).probability_density_function()\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Pseudo-Voigt distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution.__summary__","title":"<code>__summary__</code>  <code>property</code>","text":"<p>Summary statistics of the Pseudo-Voigt distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Pseudo-Voigt distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Probability density function of the Pseudo-Voigt distribution.\"\"\"\n    return (1 - self.eta) * GaussianDistribution(\n        self._x,\n        mu=self.mu,\n        sigma=self.sigma,\n    ).probability_density_function() + self.eta * LorentzianDistribution(\n        self._x,\n        mu=self.mu,\n        gamma=self.sigma,\n    ).probability_density_function()\n</code></pre>"},{"location":"modules/api/hyperbolic/","title":"Modules","text":"<p>Hyperbolic angle function for the UMF package.</p> <p>Hyperbolic area function for the UMF package.</p> <p>Hyperbolic distance function for the UMF package.</p> <p>Hyperbolic geodesic function for the UMF package.</p> <p>Hyperbolic isometry function for the UMF package.</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.angle.AngleFunction","title":"<code>AngleFunction</code>","text":"<p>               Bases: <code>HyperbolicFunction</code></p> <p>Compute the angle between two vectors in the hyperbolic plane.</p> <p>The hyperbolic angle function computes the angle between two vectors in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n&gt;&gt;&gt; vector1 = np.array([1, 0])\n&gt;&gt;&gt; vector2 = np.array([0, 1])\n&gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n&gt;&gt;&gt; haf.result\narray(1.57079633)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n&gt;&gt;&gt; vector1 = np.array([1, 0])\n&gt;&gt;&gt; vector2 = np.array([0, 1])\n&gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n&gt;&gt;&gt; angle = haf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.quiver(\n...     0, 0, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1,\n...     color='r', label='Vector 1'\n... )\n&gt;&gt;&gt; _ = ax.quiver(\n...     0, 0, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1,\n...     color='b', label='Vector 2'\n... )\n&gt;&gt;&gt; _ = ax.set_xlim(-1.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-1.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; _ = plt.title(f'Angle: {angle:.2f} radians')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"AngleFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The angle between two vectors \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ \\theta = \\cos^{-1}\\left(\\frac{x_1 x_2 + y_1 y_2}{\\sqrt{x_1^2 + y_1^2} \\sqrt{x_2^2 + y_2^2}}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_angle</p> <p>Parameters:</p> Name Type Description Default <code>*vectors</code> <code>UniversalArray</code> <p>The coordinates of the two vectors in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/angle.py</code> Python<pre><code>class AngleFunction(HyperbolicFunction):\n    r\"\"\"Compute the angle between two vectors in the hyperbolic plane.\n\n    The hyperbolic angle function computes the angle between two vectors in the\n    hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n        &gt;&gt;&gt; vector1 = np.array([1, 0])\n        &gt;&gt;&gt; vector2 = np.array([0, 1])\n        &gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n        &gt;&gt;&gt; haf.result\n        array(1.57079633)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n        &gt;&gt;&gt; vector1 = np.array([1, 0])\n        &gt;&gt;&gt; vector2 = np.array([0, 1])\n        &gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n        &gt;&gt;&gt; angle = haf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.quiver(\n        ...     0, 0, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='r', label='Vector 1'\n        ... )\n        &gt;&gt;&gt; _ = ax.quiver(\n        ...     0, 0, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='b', label='Vector 2'\n        ... )\n        &gt;&gt;&gt; _ = ax.set_xlim(-1.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-1.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; _ = plt.title(f'Angle: {angle:.2f} radians')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"AngleFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The angle between two vectors $(x_1, y_1)$ and $(x_2, y_2)$ in the hyperbolic\n        plane is given by:\n\n        $$\n        \\theta = \\cos^{-1}\\left(\\frac{x_1 x_2 + y_1 y_2}{\\sqrt{x_1^2 + y_1^2}\n        \\sqrt{x_2^2 + y_2^2}}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_angle\n\n    Args:\n        *vectors (UniversalArray): The coordinates of the two vectors in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *vectors: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic angle function.\"\"\"\n        super().__init__(*vectors)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Compute the angle between two vectors in the hyperbolic plane.\n\n        Returns:\n            float: The angle between the two vectors in radians.\n        \"\"\"\n        x1, y1 = self._x[0]\n        x2, y2 = self._x[1]\n        dot_product = x1 * x2 + y1 * y2\n        norm1 = np.sqrt(x1**2 + y1**2)\n        norm2 = np.sqrt(x2**2 + y2**2)\n        return np.arccos(dot_product / (norm1 * norm2))\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.angle.AngleFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Compute the angle between two vectors in the hyperbolic plane.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The angle between the two vectors in radians.</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.angle.AngleFunction.__init__","title":"<code>__init__(*vectors)</code>","text":"<p>Initialize the hyperbolic angle function.</p> Source code in <code>umf/functions/hyperbolic/angle.py</code> Python<pre><code>def __init__(self, *vectors: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic angle function.\"\"\"\n    super().__init__(*vectors)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.area.AreaFunction","title":"<code>AreaFunction</code>","text":"<p>               Bases: <code>HyperbolicFunction</code></p> <p>Calculate the area of a polygon in the hyperbolic plane.</p> <p>The hyperbolic area function calculates the area of a polygon in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n&gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n&gt;&gt;&gt; haf = AreaFunction(*vertices)()\n&gt;&gt;&gt; haf.result\narray(0.5)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n&gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n&gt;&gt;&gt; haf = AreaFunction(*vertices)()\n&gt;&gt;&gt; area = haf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; polygon = plt.Polygon(vertices, closed=True, fill=None, edgecolor='r')\n&gt;&gt;&gt; _ = ax.add_patch(polygon)\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Area: {area:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"AreaFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The area of a polygon in the hyperbolic plane is given by:</p> \\[ A = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right| \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_area</p> <p>Parameters:</p> Name Type Description Default <code>*vertices</code> <code>UniversalArray</code> <p>The coordinates of the vertices of the polygon in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/area.py</code> Python<pre><code>class AreaFunction(HyperbolicFunction):\n    r\"\"\"Calculate the area of a polygon in the hyperbolic plane.\n\n    The hyperbolic area function calculates the area of a polygon in the hyperbolic\n    plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n        &gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n        &gt;&gt;&gt; haf = AreaFunction(*vertices)()\n        &gt;&gt;&gt; haf.result\n        array(0.5)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n        &gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n        &gt;&gt;&gt; haf = AreaFunction(*vertices)()\n        &gt;&gt;&gt; area = haf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; polygon = plt.Polygon(vertices, closed=True, fill=None, edgecolor='r')\n        &gt;&gt;&gt; _ = ax.add_patch(polygon)\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Area: {area:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"AreaFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The area of a polygon in the hyperbolic plane is given by:\n\n        $$\n        A = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_area\n\n    Args:\n        *vertices (UniversalArray): The coordinates of the vertices of the polygon in\n            the hyperbolic plane.\n    \"\"\"\n\n    def __init__(self, *vertices: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic area function.\"\"\"\n        super().__init__(*vertices)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Calculate the area of a polygon in the hyperbolic plane.\n\n        Returns:\n            float: The area of the polygon in the hyperbolic plane.\n        \"\"\"\n        n = len(self._x)\n        area = 0.0\n        for i in range(n):\n            x1, y1 = self._x[i]\n            x2, y2 = self._x[(i + 1) % n]\n            area += x1 * y2 - x2 * y1\n        return 0.5 * np.abs(area)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.area.AreaFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the area of a polygon in the hyperbolic plane.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The area of the polygon in the hyperbolic plane.</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.area.AreaFunction.__init__","title":"<code>__init__(*vertices)</code>","text":"<p>Initialize the hyperbolic area function.</p> Source code in <code>umf/functions/hyperbolic/area.py</code> Python<pre><code>def __init__(self, *vertices: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic area function.\"\"\"\n    super().__init__(*vertices)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.distance.DistanceFunction","title":"<code>DistanceFunction</code>","text":"<p>               Bases: <code>HyperbolicFunction</code></p> <p>Calculate the hyperbolic distance between two points in the hyperbolic plane.</p> <p>The hyperbolic distance function calculates the distance between two points in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n&gt;&gt;&gt; hdf.result\narray(2.89838887)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n&gt;&gt;&gt; distance = hdf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"DistanceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The hyperbolic distance between two points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_distance</p> <p>Parameters:</p> Name Type Description Default <code>*points</code> <code>UniversalArray</code> <p>The coordinates of the two points in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/distance.py</code> Python<pre><code>class DistanceFunction(HyperbolicFunction):\n    r\"\"\"Calculate the hyperbolic distance between two points in the hyperbolic plane.\n\n    The hyperbolic distance function calculates the distance between two points in the\n    hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n        &gt;&gt;&gt; hdf.result\n        array(2.89838887)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n        &gt;&gt;&gt; distance = hdf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"DistanceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The hyperbolic distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ in the\n        hyperbolic plane is given by:\n\n        $$\n        d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_distance\n\n    Args:\n        *points (UniversalArray): The coordinates of the two points in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *points: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic distance function.\"\"\"\n        super().__init__(*points)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Calculate the hyperbolic distance between two points in the hyperbolic plane.\n\n        Returns:\n            float: The hyperbolic distance between the two points.\n        \"\"\"\n        x1, y1 = self._x[0].astype(np.float64)\n        x2, y2 = self._x[1].astype(np.float64)\n        return np.asarray(\n            np.arccosh(1 + ((x2 - x1) ** 2 + (y2 - y1) ** 2) / (2 * y1 * y2))\n        )\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.distance.DistanceFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the hyperbolic distance between two points in the hyperbolic plane.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The hyperbolic distance between the two points.</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.distance.DistanceFunction.__init__","title":"<code>__init__(*points)</code>","text":"<p>Initialize the hyperbolic distance function.</p> Source code in <code>umf/functions/hyperbolic/distance.py</code> Python<pre><code>def __init__(self, *points: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic distance function.\"\"\"\n    super().__init__(*points)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.geodesic.GeodesicFunction","title":"<code>GeodesicFunction</code>","text":"<p>               Bases: <code>HyperbolicFunction</code></p> <p>Determine the shortest path between two points in the hyperbolic plane.</p> <p>The hyperbolic geodesic function determines the shortest path between two points in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n&gt;&gt;&gt; hgf.result\narray(2.89838887)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n&gt;&gt;&gt; distance = hgf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"GeodesicFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The hyperbolic geodesic between two points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_geodesic</p> <p>Parameters:</p> Name Type Description Default <code>*points</code> <code>UniversalArray</code> <p>The coordinates of the two points in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/geodesic.py</code> Python<pre><code>class GeodesicFunction(HyperbolicFunction):\n    r\"\"\"Determine the shortest path between two points in the hyperbolic plane.\n\n    The hyperbolic geodesic function determines the shortest path between two points\n    in the hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n        &gt;&gt;&gt; hgf.result\n        array(2.89838887)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n        &gt;&gt;&gt; distance = hgf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"GeodesicFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The hyperbolic geodesic between two points $(x_1, y_1)$ and $(x_2, y_2)$ in the\n        hyperbolic plane is given by:\n\n        $$\n        d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_geodesic\n\n    Args:\n        *points (UniversalArray): The coordinates of the two points in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *points: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic geodesic function.\"\"\"\n        super().__init__(*points)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Determine the shortest path between two points in the hyperbolic plane.\n\n        Returns:\n            float: The length of the geodesic between the two points.\n        \"\"\"\n        x1, y1 = self._x[0]\n        x2, y2 = self._x[1]\n        return np.arccosh(1 + ((x2 - x1) ** 2 + (y2 - y1) ** 2) / (2 * y1 * y2))\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.geodesic.GeodesicFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Determine the shortest path between two points in the hyperbolic plane.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The length of the geodesic between the two points.</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.geodesic.GeodesicFunction.__init__","title":"<code>__init__(*points)</code>","text":"<p>Initialize the hyperbolic geodesic function.</p> Source code in <code>umf/functions/hyperbolic/geodesic.py</code> Python<pre><code>def __init__(self, *points: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic geodesic function.\"\"\"\n    super().__init__(*points)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.isometry.IsometryFunction","title":"<code>IsometryFunction</code>","text":"<p>               Bases: <code>HyperbolicFunction</code></p> <p>Apply an isometry transformation to a point in the hyperbolic plane.</p> <p>The hyperbolic isometry function applies isometries (transformations that preserve distances) in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n&gt;&gt;&gt; point = np.array([1, 1], dtype=float)\n&gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]], dtype=float)\n&gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n&gt;&gt;&gt; hif.result\narray([2., 2.])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n&gt;&gt;&gt; point = np.array([1, 1])\n&gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]])\n&gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n&gt;&gt;&gt; transformed_point = hif.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _  = ax.quiver(\n...     0, 0, point[0], point[1], angles='xy', scale_units='xy', scale=1,\n...     color='r', label='Original Point'\n... )\n&gt;&gt;&gt; _  = ax.quiver(\n...     0, 0, transformed_point[0], transformed_point[1], angles='xy',\n...     scale_units='xy', scale=1, color='b', label='Transformed Point'\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; _  = ax.set_xlim(-1.5, 2.5)\n&gt;&gt;&gt; _  = ax.set_ylim(-1.5, 2.5)\n&gt;&gt;&gt; ax.set_aspect('equal')\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; _  = plt.title('Hyperbolic Isometry Transformation')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"IsometryFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>An isometry transformation in the hyperbolic plane is represented by a 2x2 matrix. The transformation is applied to a point \\((x, y)\\) in the hyperbolic plane to obtain a new point \\((x', y')\\).</p> <p>Reference: en.wikipedia.org/wiki/Isometry</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>UniversalArray</code> <p>The point (x, y) to be transformed and the 2x2 isometry matrix.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/isometry.py</code> Python<pre><code>class IsometryFunction(HyperbolicFunction):\n    r\"\"\"Apply an isometry transformation to a point in the hyperbolic plane.\n\n    The hyperbolic isometry function applies isometries (transformations that preserve\n    distances) in the hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n        &gt;&gt;&gt; point = np.array([1, 1], dtype=float)\n        &gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]], dtype=float)\n        &gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n        &gt;&gt;&gt; hif.result\n        array([2., 2.])\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n        &gt;&gt;&gt; point = np.array([1, 1])\n        &gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]])\n        &gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n        &gt;&gt;&gt; transformed_point = hif.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _  = ax.quiver(\n        ...     0, 0, point[0], point[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='r', label='Original Point'\n        ... )\n        &gt;&gt;&gt; _  = ax.quiver(\n        ...     0, 0, transformed_point[0], transformed_point[1], angles='xy',\n        ...     scale_units='xy', scale=1, color='b', label='Transformed Point'\n        ... )\n\n        &gt;&gt;&gt; _  = ax.set_xlim(-1.5, 2.5)\n        &gt;&gt;&gt; _  = ax.set_ylim(-1.5, 2.5)\n        &gt;&gt;&gt; ax.set_aspect('equal')\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; _  = plt.title('Hyperbolic Isometry Transformation')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"IsometryFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        An isometry transformation in the hyperbolic plane is represented by a 2x2\n        matrix. The transformation is applied to a point $(x, y)$ in the hyperbolic\n        plane to obtain a new point $(x', y')$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Isometry\n\n    Args:\n        *args (UniversalArray): The point (x, y) to be transformed and the 2x2 isometry\n            matrix.\n    \"\"\"\n\n    def __init__(self, *args: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic isometry function.\"\"\"\n        super().__init__(*args)\n\n    @property\n    def __eval__(self) -&gt; np.ndarray:\n        \"\"\"Apply an isometry transformation to a point in the hyperbolic plane.\n\n        Returns:\n            np.ndarray: The transformed point (x', y').\n        \"\"\"\n        point = self._x[0].astype(np.float64)\n        matrix = self._x[1].astype(np.float64)\n        return np.dot(matrix, point)\n</code></pre>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.isometry.IsometryFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Apply an isometry transformation to a point in the hyperbolic plane.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The transformed point (x', y').</p>"},{"location":"modules/api/hyperbolic/#umf.functions.hyperbolic.isometry.IsometryFunction.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize the hyperbolic isometry function.</p> Source code in <code>umf/functions/hyperbolic/isometry.py</code> Python<pre><code>def __init__(self, *args: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic isometry function.\"\"\"\n    super().__init__(*args)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/","title":"Modules","text":"<p>API for function classes.</p> <p>Reference class for functions to generate data for benchmarking.</p> <p>Abstract class for plotting functions.</p> <p>About</p> <p>This module defines an abstract class <code>Plot</code> and a named tuple <code>GraphSettings</code> for plotting functions.</p> <ul> <li><code>GraphSettings</code>: A class for named tuples which defines the settings for     the graph, such as size, dpi, axis labels, title, color, colormap, and     alpha value.</li> <li><code>Plot</code>: An abstract class that defines methods for plotting data in 2D, 3D,     contour, surface, and dashboard formats, as well as animating the plot. It also     defines abstract methods for showing and saving the plot.</li> </ul>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.MaximaAPI","title":"<code>MaximaAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Maxima API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class MaximaAPI(BaseModel):\n    \"\"\"Maxima API for optimization functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    f_x: float | UniversalArray = Field(\n        ...,\n        description=\"Value of the function at the maximum or maxima.\",\n    )\n    x: UniversalArrayTuple | UniversalFloatTuple = Field(\n        ...,\n        description=\"Input data, where the maximum or maxima is located.\",\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.MinimaAPI","title":"<code>MinimaAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Minima API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class MinimaAPI(BaseModel):\n    \"\"\"Minima API for optimization functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    f_x: float | UniversalArray = Field(\n        ...,\n        description=\"Value of the function at the minimum or minima.\",\n    )\n    x: UniversalArrayTuple | UniversalFloatTuple = Field(\n        ...,\n        description=\"Input data, where the minimum or minima is located.\",\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsChaoticOscillatorAPI","title":"<code>ResultsChaoticOscillatorAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results API for chaotic oscillator functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsChaoticOscillatorAPI(BaseModel):\n    \"\"\"Results API for chaotic oscillator functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    t: UniversalArrayTuple = Field(\n        ...,\n        description=\"Time array for the chaotic oscillator.\",\n    )\n    initial_state: dict[str, UniversalArray] = Field(\n        default=...,\n        description=\"Initial conditions for the chaotic pendulum.\",\n    )\n    result: UniversalArray = Field(\n        default=...,\n        description=\"Result of the chaotic oscillator.\",\n    )\n    doc: str | None = Field(\n        default=...,\n        description=\"Function documentation string.\",\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsDistributionAPI","title":"<code>ResultsDistributionAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results API for distribution functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsDistributionAPI(BaseModel):\n    \"\"\"Results API for distribution functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    x: UniversalArrayTuple = Field(\n        ...,\n        description=\"Input data, which can be one, two, three, or higher dimensional.\",\n    )\n    result: UniversalArray | MeshArray = Field(\n        ...,\n        description=\"Function value as numpy array or numpy mesh grid array.\",\n    )\n    summary: SummaryStatisticsAPI = Field(\n        ...,\n        description=\"Summary statistics of the data.\",\n    )\n    doc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsFunctionAPI","title":"<code>ResultsFunctionAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsFunctionAPI(BaseModel):\n    \"\"\"Results API for optimization functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    x: UniversalArrayTuple = Field(\n        ...,\n        description=\"Input data, which can be one, two, three, or higher dimensional.\",\n    )\n    result: UniversalArray | MeshArray = Field(\n        ...,\n        description=\"Function value as numpy array or numpy mesh grid array.\",\n    )\n    minima: MinimaAPI | None = Field(\n        default=None,\n        description=\"Tuple of minima as numpy arrays.\",\n    )\n    maxima: MaximaAPI | None = Field(\n        default=None,\n        description=\"Tuple of maxima as numpy arrays.\",\n    )\n    doc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsHyperbolicAPI","title":"<code>ResultsHyperbolicAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results API for hyperbolic functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsHyperbolicAPI(BaseModel):\n    \"\"\"Results API for hyperbolic functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    x: UniversalArrayTuple = Field(\n        ...,\n        description=\"Input data, which can be one, two, three, or higher dimensional.\",\n    )\n    result: UniversalArray | MeshArray = Field(\n        ...,\n        description=\"Function value as numpy array or numpy mesh grid array.\",\n    )\n    doc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsPathologicalAPI","title":"<code>ResultsPathologicalAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Results API for pathological functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsPathologicalAPI(BaseModel):\n    \"\"\"Results API for pathological functions.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    x: UniversalArrayTuple = Field(\n        ...,\n        description=\"Input data, which can be one, two, three, or higher dimensional.\",\n    )\n    result: UniversalArray | MeshArray = Field(\n        ...,\n        description=\"Function value as numpy array or numpy mesh grid array.\",\n    )\n\n    doc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.SummaryStatisticsAPI","title":"<code>SummaryStatisticsAPI</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>API for summary statistics.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class SummaryStatisticsAPI(BaseModel):\n    \"\"\"API for summary statistics.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    mean: float | None = Field(\n        default=...,\n        description=\"Mean value of the data.\",\n    )\n    variance: float | None = Field(\n        default=...,\n        description=\"Variance of the data.\",\n    )\n    mode: float | UniversalFloatTuple | None = Field(\n        default=...,\n        description=\"Mode or modes of the data.\",\n    )\n    doc: str | None = Field(\n        default=...,\n        description=\"Documentation string for the summary statistics.\",\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousAsymmetricPseudo","title":"<code>ContinousAsymmetricPseudo</code>","text":"<p>               Bases: <code>ContinousPseudo</code></p> <p>Base class for continuous distributions for asym. pseudo Voigt like functions.</p> Note <p>In terms of pseudo Voigt like functions, the \\(\\gamma\\) parameter is used to provide an asymetric line shape. The \\(\\gamma\\) parameter is defined as the ratio of the Lorentzian contribution to the Gaussian contribution. In case of XPS and XAS, these type of functions are popular to model the line shape of the photoemission and absorption spectra.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>eta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>Asymmetry parameter of the distribution. Defaults to 0.0.</p> <code>0.0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> required <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([0, 1]\\).</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinousAsymmetricPseudo(ContinousPseudo):\n    r\"\"\"Base class for continuous distributions for asym. pseudo Voigt like functions.\n\n    Note:\n        In terms of pseudo Voigt like functions, the $\\gamma$ parameter is used to\n        provide an asymetric line shape. The $\\gamma$ parameter is defined as the ratio\n        of the Lorentzian contribution to the Gaussian contribution. In case of\n        **XPS** and **XAS**, these type of functions are popular to model the line shape\n        of the photoemission and absorption spectra.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        eta (float): Shape parameter of the distribution. Defaults to 0.5.\n        gamma (float): Asymmetry parameter of the distribution. Defaults to 0.0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n        OutOfRangeError: If the input data is not in the interval $[0, 1]$.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        eta: float = 0.5,\n        gamma: float = 0.0,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma, eta=eta, cumulative=False)\n        self.gamma = gamma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousAsymmetricPseudo.__init__","title":"<code>__init__(*x, mu=0, sigma=1, eta=0.5, gamma=0.0)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    eta: float = 0.5,\n    gamma: float = 0.0,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma, eta=eta, cumulative=False)\n    self.gamma = gamma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousPseudo","title":"<code>ContinousPseudo</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Base class for continuous distributions for pseudo Voigt like functions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>eta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([0, 1]\\).</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinousPseudo(ContinuousWSigma):\n    \"\"\"Base class for continuous distributions for pseudo Voigt like functions.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        eta (float): Shape parameter of the distribution. Defaults to 0.5.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n        OutOfRangeError: If the input data is not in the interval $[0, 1]$.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        eta: float = 0.5,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        if eta &lt; 0 or eta &gt; 1:\n            raise OutOfRangeError(\n                function_name=self.__class__.__name__,\n                start_range=0,\n                end_range=1,\n            )\n        self.eta = eta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousPseudo.__init__","title":"<code>__init__(*x, mu=0, sigma=1, eta=0.5, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    eta: float = 0.5,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n    if eta &lt; 0 or eta &gt; 1:\n        raise OutOfRangeError(\n            function_name=self.__class__.__name__,\n            start_range=0,\n            end_range=1,\n        )\n    self.eta = eta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.Continuous2PiInterval","title":"<code>Continuous2PiInterval</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with fixed interval of \\(2\\pi\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([-\\pi, \\pi]\\).</p> <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class Continuous2PiInterval(ContinuousDistributionBase):\n    r\"\"\"Base class for continuous distributions with fixed interval of $2\\pi$.\n\n    Args:\n        *x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        OutOfRangeError: If the input data is not in the interval $[-\\pi, \\pi]$.\n        MissingXError: If no input data is specified.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        kappa: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if np.min(x) &lt; -np.pi or np.max(x) &gt; np.pi:\n            raise OutOfRangeError(\n                function_name=self.__class__.__name__,\n                start_range=-np.pi,\n                end_range=np.pi,\n            )\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n        self.kappa = kappa\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.Continuous2PiInterval.__init__","title":"<code>__init__(*x, mu=0, kappa=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    kappa: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if np.min(x) &lt; -np.pi or np.max(x) &gt; np.pi:\n        raise OutOfRangeError(\n            function_name=self.__class__.__name__,\n            start_range=-np.pi,\n            end_range=np.pi,\n        )\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n    self.kappa = kappa\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousBoundedInterval","title":"<code>ContinuousBoundedInterval</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a bounded interval.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>start</code> <code>float</code> <p>Start of the interval. Defaults to 0.</p> <code>0</code> <code>end</code> <code>float</code> <p>End of the interval. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([start, end]\\).</p> <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousBoundedInterval(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with a bounded interval.\n\n    Args:\n        *x (UniversalArray): Input data, which currently must be one dimensional.\n        start (float): Start of the interval. Defaults to 0.\n        end (float): End of the interval. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        OutOfRangeError: If the input data is not in the interval $[start, end]$.\n        MissingXError: If no input data is specified.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        start: float = 0,\n        end: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if np.min(x) &lt; start or np.max(x) &gt; end:\n            raise OutOfRangeError(\n                function_name=self.__class__.__name__,\n                start_range=start,\n                end_range=end,\n            )\n        super().__init__(*x, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousBoundedInterval.__init__","title":"<code>__init__(*x, start=0, end=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    start: float = 0,\n    end: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if np.min(x) &lt; start or np.max(x) &gt; end:\n        raise OutOfRangeError(\n            function_name=self.__class__.__name__,\n            start_range=start,\n            end_range=end,\n        )\n    super().__init__(*x, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase","title":"<code>ContinuousDistributionBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for distributions with a standard deviation and beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousDistributionBase(ABC, metaclass=CoreElements):\n    \"\"\"Base class for distributions with a standard deviation and beta parameter.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float ): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if x[0] is None:\n            raise MissingXError\n\n        if len(x) != __1d__:\n            raise OutOfDimensionError(\n                function_name=self.__class__.__name__,\n                dimension=__1d__,\n            )\n        self._x = x[0]\n        self.mu = mu\n        self.cumulative = cumulative\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n        return (np.array(self._x),)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n        return (\n            self.cumulative_distribution_function()\n            if self.cumulative\n            else self.probability_density_function()\n        )\n\n    @abstractmethod\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n\n    @property\n    @abstractmethod\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        raise NoCumulativeError\n\n    def __call__(self) -&gt; ResultsDistributionAPI:\n        \"\"\"Return the results of the function.\"\"\"\n        return ResultsDistributionAPI(\n            x=self.__input__,\n            result=self.__eval__,\n            summary=self.__summary__,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__summary__","title":"<code>__summary__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsDistributionAPI:\n    \"\"\"Return the results of the function.\"\"\"\n    return ResultsDistributionAPI(\n        x=self.__input__,\n        result=self.__eval__,\n        summary=self.__summary__,\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__init__","title":"<code>__init__(*x, mu=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if x[0] is None:\n        raise MissingXError\n\n    if len(x) != __1d__:\n        raise OutOfDimensionError(\n            function_name=self.__class__.__name__,\n            dimension=__1d__,\n        )\n    self._x = x[0]\n    self.mu = mu\n    self.cumulative = cumulative\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    raise NoCumulativeError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.probability_density_function","title":"<code>probability_density_function()</code>  <code>abstractmethod</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>@abstractmethod\ndef probability_density_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability density function.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousMixed","title":"<code>ContinuousMixed</code>","text":"<p>               Bases: <code>ContinuousWSigma</code></p> <p>Base class for continuous distributions with mixed parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.0.</p> <code>0.0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousMixed(ContinuousWSigma):\n    r\"\"\"Base class for continuous distributions with mixed parameters.\n\n    Args:\n        x (UniversalArray): Input data, which can be one, two, three, or higher\n            dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        zeta (float): Shape parameter of the distribution. Defaults to 0.0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        zeta: float = 0.0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        self.zeta = zeta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousMixed.__init__","title":"<code>__init__(*x, mu=0, sigma=1, zeta=0.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    zeta: float = 0.0,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n    self.zeta = zeta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousPure","title":"<code>ContinuousPure</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousPure(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with a standard deviation.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWBeta","title":"<code>ContinuousWBeta</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>NotAPositiveNumberError</code> <p>If the beta parameter is not a positive number.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWBeta(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with beta parameter.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        NotAPositiveNumberError: If the beta parameter is not a positive number.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        beta: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n        if beta &lt;= 0:\n            raise NotAPositiveNumberError(var_number=\"beta\", number=beta)\n        self.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWBeta.__init__","title":"<code>__init__(*x, mu=0, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    beta: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n    if beta &lt;= 0:\n        raise NotAPositiveNumberError(var_number=\"beta\", number=beta)\n    self.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWLambda","title":"<code>ContinuousWLambda</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWLambda(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with beta parameter.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        lambda_: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, cumulative=cumulative)\n        if lambda_ &lt;= 0:\n            raise NotAPositiveNumberError(var_number=\"lambda_\", number=lambda_)\n        self.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWLambda.__init__","title":"<code>__init__(*x, lambda_=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    lambda_: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, cumulative=cumulative)\n    if lambda_ &lt;= 0:\n        raise NotAPositiveNumberError(var_number=\"lambda_\", number=lambda_)\n    self.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWSigma","title":"<code>ContinuousWSigma</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWSigma(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with a standard deviation.\n\n    Args:\n        x (UniversalArray): Input data, which can be one, two, three, or higher\n            dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n        self.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWSigma.__init__","title":"<code>__init__(*x, mu=0, sigma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n    self.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements","title":"<code>CoreElements</code>","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for functions.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class CoreElements(ABCMeta):\n    \"\"\"Metaclass for functions.\"\"\"\n\n    @property\n    @abstractmethod\n    def __eval__(cls) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n\n    @property\n    @abstractmethod\n    def __input__(cls) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements.__eval__","title":"<code>__eval__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements.__input__","title":"<code>__input__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase","title":"<code>DiscreteDistributionBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for discrete distributions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscreteDistributionBase(ABC, metaclass=CoreElements):\n    \"\"\"Base class for discrete distributions.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if x is None:\n            raise MissingXError\n\n        if len(x) != __1d__:\n            raise OutOfDimensionError(\n                function_name=self.__class__.__name__,\n                dimension=__1d__,\n            )\n        self._x = x[0]\n        self.cumulative = cumulative\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n        return (np.array(self._x),)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n        return (\n            self.cumulative_distribution_function()\n            if self.cumulative\n            else self.probability_mass_function()\n        )\n\n    @abstractmethod\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability mass function.\"\"\"\n\n    @property\n    @abstractmethod\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        raise NoCumulativeError\n\n    def __call__(self) -&gt; ResultsDistributionAPI:\n        \"\"\"Return the results of the function.\"\"\"\n        return ResultsDistributionAPI(\n            x=self.__input__,\n            result=self.__eval__,\n            summary=self.__summary__,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__summary__","title":"<code>__summary__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsDistributionAPI:\n    \"\"\"Return the results of the function.\"\"\"\n    return ResultsDistributionAPI(\n        x=self.__input__,\n        result=self.__eval__,\n        summary=self.__summary__,\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__init__","title":"<code>__init__(*x, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if x is None:\n        raise MissingXError\n\n    if len(x) != __1d__:\n        raise OutOfDimensionError(\n            function_name=self.__class__.__name__,\n            dimension=__1d__,\n        )\n    self._x = x[0]\n    self.cumulative = cumulative\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n    \"\"\"Return the cumulative distribution function.\"\"\"\n    raise NoCumulativeError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.probability_mass_function","title":"<code>probability_mass_function()</code>  <code>abstractmethod</code>","text":"<p>Return the probability mass function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>@abstractmethod\ndef probability_mass_function(self) -&gt; UniversalArray:\n    \"\"\"Return the probability mass function.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteP","title":"<code>DiscreteP</code>","text":"<p>               Bases: <code>DiscreteDistributionBase</code></p> <p>Base class for discrete distributions with a probability parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Probability parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscreteP(DiscreteDistributionBase):\n    \"\"\"Base class for discrete distributions with a probability parameter.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        p (float): Probability parameter of the distribution. Defaults to 0.5.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        p: float = 0.5,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, cumulative=cumulative)\n        if p &lt; 0 or p &gt; 1:\n            raise OutOfRangeError(\n                function_name=self.__class__.__name__,\n                start_range=0,\n                end_range=1,\n            )\n        self.p = p\n        self.q = 1 - p\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteP.__init__","title":"<code>__init__(*x, p=0.5, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    p: float = 0.5,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, cumulative=cumulative)\n    if p &lt; 0 or p &gt; 1:\n        raise OutOfRangeError(\n            function_name=self.__class__.__name__,\n            start_range=0,\n            end_range=1,\n        )\n    self.p = p\n    self.q = 1 - p\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscretePure","title":"<code>DiscretePure</code>","text":"<p>               Bases: <code>DiscreteDistributionBase</code></p> <p>Base class for discrete distributions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscretePure(DiscreteDistributionBase):\n    \"\"\"Base class for discrete distributions.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.HyperbolicFunction","title":"<code>HyperbolicFunction</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Class for hyperbolic functions.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class HyperbolicFunction(ABC, metaclass=CoreElements):\n    \"\"\"Class for hyperbolic functions.\"\"\"\n\n    def __init__(self, *args: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic function.\"\"\"\n        if args[0] is None:\n            raise MissingXError\n\n        self._x: tuple[UniversalArray, ...] = args\n        self.dimension: int = len(args)\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data for the hyperbolic function.\"\"\"\n        return self._x\n\n    @property\n    @abstractmethod\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the hyperbolic function.\"\"\"\n\n    def __call__(self) -&gt; ResultsHyperbolicAPI:\n        \"\"\"Return the results of the hyperbolic function.\"\"\"\n        return ResultsHyperbolicAPI(\n            x=self.__input__,\n            result=np.asarray(self.__eval__),\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.HyperbolicFunction.__eval__","title":"<code>__eval__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the hyperbolic function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.HyperbolicFunction.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data for the hyperbolic function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.HyperbolicFunction.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the hyperbolic function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsHyperbolicAPI:\n    \"\"\"Return the results of the hyperbolic function.\"\"\"\n    return ResultsHyperbolicAPI(\n        x=self.__input__,\n        result=np.asarray(self.__eval__),\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.HyperbolicFunction.__init__","title":"<code>__init__(*args)</code>","text":"<p>Initialize the hyperbolic function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(self, *args: UniversalArray) -&gt; None:\n    \"\"\"Initialize the hyperbolic function.\"\"\"\n    if args[0] is None:\n        raise MissingXError\n\n    self._x: tuple[UniversalArray, ...] = args\n    self.dimension: int = len(args)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction","title":"<code>OptFunction</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for functions for optimization.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> required <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class OptFunction(ABC, metaclass=CoreElements):\n    \"\"\"Base class for functions for optimization.\n\n    Args:\n        x: Input data, which can be one, two, three, or higher dimensional.\n        kwargs: Keyword arguments for the function.\n\n    Raises:\n        MissingXError: If no input data is specified.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if x[0] is None:\n            raise MissingXError\n\n        self._x: tuple[UniversalArray, ...] = x\n        self.dimension: int = len(x)\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n        return self._x\n\n    @property\n    @abstractmethod\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n\n    @property\n    @abstractmethod\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the zero function.\"\"\"\n\n    def __call__(self) -&gt; ResultsFunctionAPI:\n        \"\"\"Return the results of the function.\"\"\"\n        return ResultsFunctionAPI(\n            x=self.__input__,\n            result=self.__eval__,\n            minima=self.__minima__,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__eval__","title":"<code>__eval__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__minima__","title":"<code>__minima__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsFunctionAPI:\n    \"\"\"Return the results of the function.\"\"\"\n    return ResultsFunctionAPI(\n        x=self.__input__,\n        result=self.__eval__,\n        minima=self.__minima__,\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if x[0] is None:\n        raise MissingXError\n\n    self._x: tuple[UniversalArray, ...] = x\n    self.dimension: int = len(x)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc2D","title":"<code>OscillatorsFunc2D</code>","text":"<p>               Bases: <code>OscillatorsFuncBase</code></p> <p>Base class for two-dimensional chaotic oscillators.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class OscillatorsFunc2D(OscillatorsFuncBase):\n    \"\"\"Base class for two-dimensional chaotic oscillators.\"\"\"\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 0], y[:, 2]\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 1], y[:, 3]\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc2D.to_position","title":"<code>to_position</code>  <code>property</code>","text":"<p>Return the position of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc2D.to_velocity","title":"<code>to_velocity</code>  <code>property</code>","text":"<p>Return the velocity of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc3D","title":"<code>OscillatorsFunc3D</code>","text":"<p>               Bases: <code>OscillatorsFuncBase</code></p> <p>Base class for three-dimensional chaotic oscillators.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class OscillatorsFunc3D(OscillatorsFuncBase):\n    \"\"\"Base class for three-dimensional chaotic oscillators.\"\"\"\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 0], y[:, 1], y[:, 2]\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 3], y[:, 4], y[:, 5]\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc3D.to_position","title":"<code>to_position</code>  <code>property</code>","text":"<p>Return the position of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFunc3D.to_velocity","title":"<code>to_velocity</code>  <code>property</code>","text":"<p>Return the velocity of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase","title":"<code>OscillatorsFuncBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for chaotic oscillators.</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The format of the time data. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the oscillator. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> <code>TimeFormatError</code> <p>If the time format is not valid.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class OscillatorsFuncBase(ABC, metaclass=CoreElements):\n    \"\"\"Base class for chaotic oscillators.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str): The format of the time data. Defaults to \"seconds\".\n        velocity (bool): Whether to return the velocity of the oscillator.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n        TimeFormatError: If the time format is not valid.\n    \"\"\"\n\n    def __init__(\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if t[0] is None:\n            raise MissingXError\n\n        if len(t) != __1d__:\n            raise OutOfDimensionError(\n                function_name=self.__class__.__name__,\n                dimension=__1d__,\n            )\n\n        self.time_format = time_format\n        self.t = self.convert2sec(t[0])\n        self.velocity = velocity\n\n    def convert2sec(self, t: UniversalArray) -&gt; UniversalArray:\n        \"\"\"Convert the time data to seconds.\n\n        Args:\n            t (UniversalArray): The initial time data as input.\n\n        Returns:\n            UniversalArray: The time data converted to seconds.\n        \"\"\"\n        conversion_factors = {\"seconds\": 1, \"minutes\": 60, \"hours\": 3600, \"days\": 86400}\n\n        if self.time_format in conversion_factors:\n            return t * conversion_factors[self.time_format]\n        raise TimeFormatError(\n            time_format=self.time_format,\n            valid_formats=list(conversion_factors.keys()),\n        )\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n        return (self.t,)\n\n    def setup_initial_state(self) -&gt; UniversalArray:\n        \"\"\"Setup the initial state of the oscillator.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def __initial_configuration__(self) -&gt; dict[str, UniversalArray]:\n        \"\"\"Initialize the state of the oscillator.\"\"\"\n\n    @property\n    @abstractmethod\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the oscillator.\"\"\"\n\n    @abstractmethod\n    def equation_of_motion(self, initial_state: list[float], t: float) -&gt; tuple:\n        \"\"\"Return the equation of motion of the oscillator.\"\"\"\n\n    def solve(self, **kwargs: dict[str, Any]) -&gt; UniversalArrayTuple:\n        \"\"\"Solve the equation of motion of the oscillator.\"\"\"\n        return odeint(\n            func=self.equation_of_motion,\n            y0=self.initial_state,\n            t=self.t,\n            **kwargs,\n        )\n\n    @property\n    @abstractmethod\n    def to_position(self) -&gt; UniversalArray:\n        \"\"\"Return the position of the oscillator.\"\"\"\n\n    @property\n    @abstractmethod\n    def to_velocity(self) -&gt; UniversalArray:\n        \"\"\"Return the velocity of the oscillator.\"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n        return self.to_velocity if self.velocity else self.to_position\n\n    def __call__(self) -&gt; ResultsChaoticOscillatorAPI:\n        \"\"\"Return the results of the function.\"\"\"\n        return ResultsChaoticOscillatorAPI(\n            t=self.__input__,\n            result=self.__eval__,\n            initial_state=self.__initial_configuration__,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.__initial_configuration__","title":"<code>__initial_configuration__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Initialize the state of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.initial_state","title":"<code>initial_state</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the initial state of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.to_position","title":"<code>to_position</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the position of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.to_velocity","title":"<code>to_velocity</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the velocity of the oscillator.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsChaoticOscillatorAPI:\n    \"\"\"Return the results of the function.\"\"\"\n    return ResultsChaoticOscillatorAPI(\n        t=self.__input__,\n        result=self.__eval__,\n        initial_state=self.__initial_configuration__,\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.__init__","title":"<code>__init__(*t, time_format='seconds', velocity=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *t: UniversalArray,\n    time_format: str = \"seconds\",\n    velocity: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if t[0] is None:\n        raise MissingXError\n\n    if len(t) != __1d__:\n        raise OutOfDimensionError(\n            function_name=self.__class__.__name__,\n            dimension=__1d__,\n        )\n\n    self.time_format = time_format\n    self.t = self.convert2sec(t[0])\n    self.velocity = velocity\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.convert2sec","title":"<code>convert2sec(t)</code>","text":"<p>Convert the time data to seconds.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>UniversalArray</code> <p>The initial time data as input.</p> required <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The time data converted to seconds.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def convert2sec(self, t: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Convert the time data to seconds.\n\n    Args:\n        t (UniversalArray): The initial time data as input.\n\n    Returns:\n        UniversalArray: The time data converted to seconds.\n    \"\"\"\n    conversion_factors = {\"seconds\": 1, \"minutes\": 60, \"hours\": 3600, \"days\": 86400}\n\n    if self.time_format in conversion_factors:\n        return t * conversion_factors[self.time_format]\n    raise TimeFormatError(\n        time_format=self.time_format,\n        valid_formats=list(conversion_factors.keys()),\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.equation_of_motion","title":"<code>equation_of_motion(initial_state, t)</code>  <code>abstractmethod</code>","text":"<p>Return the equation of motion of the oscillator.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>@abstractmethod\ndef equation_of_motion(self, initial_state: list[float], t: float) -&gt; tuple:\n    \"\"\"Return the equation of motion of the oscillator.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.setup_initial_state","title":"<code>setup_initial_state()</code>","text":"<p>Setup the initial state of the oscillator.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def setup_initial_state(self) -&gt; UniversalArray:\n    \"\"\"Setup the initial state of the oscillator.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OscillatorsFuncBase.solve","title":"<code>solve(**kwargs)</code>","text":"<p>Solve the equation of motion of the oscillator.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def solve(self, **kwargs: dict[str, Any]) -&gt; UniversalArrayTuple:\n    \"\"\"Solve the equation of motion of the oscillator.\"\"\"\n    return odeint(\n        func=self.equation_of_motion,\n        y0=self.initial_state,\n        t=self.t,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalBase","title":"<code>PathologicalBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for pathological functions.</p> <p>This class serves as a template for creating objects that represent pathological functions. These functions are defined over a specific interval and are characterized by their shape parameters. The class provides the structure for handling input data, defining the interval of interest, and specifying the shape parameters of the function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one-dimensional.</p> <code>()</code> <code>n_0</code> <code>int</code> <p>Start of the interval. Defaults to 0.</p> <code>0</code> <code>n_1</code> <code>int</code> <p>End of the interval. Defaults to 100.</p> <code>100</code> <code>max_safe_exponent</code> <code>int | float</code> <p>Maximum safe exponent. Defaults to 200.</p> <code>200</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data (x) is specified. This error is raised to ensure that the function has the necessary data to operate on.</p> <code>OutOfDimensionError</code> <p>If the input data (x) has more than one dimension. This error is raised because the function is designed to work with one-dimensional data only.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class PathologicalBase(ABC, metaclass=CoreElements):\n    \"\"\"Base class for pathological functions.\n\n    This class serves as a template for creating objects that represent pathological\n    functions. These functions are defined over a specific interval and are\n    characterized by their shape parameters. The class provides the structure\n    for handling input data, defining the interval of interest, and specifying\n    the shape parameters of the function.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one-dimensional.\n        n_0 (int): Start of the interval. Defaults to 0.\n        n_1 (int): End of the interval. Defaults to 100.\n        max_safe_exponent (int | float): Maximum safe exponent. Defaults to 200.\n\n    Raises:\n        MissingXError: If no input data (x) is specified. This error is raised to ensure\n            that the function has the necessary data to operate on.\n        OutOfDimensionError: If the input data (x) has more than one dimension.\n            This error is raised because the function is designed to work with\n            one-dimensional data only.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        n_0: int = 0,\n        n_1: int = 100,\n        max_safe_exponent: float = 200,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if x[0] is None:\n            raise MissingXError\n\n        if len(x) != __1d__:\n            raise OutOfDimensionError(\n                function_name=self.__class__.__name__,\n                dimension=__1d__,\n            )\n        if np.abs(n_1) &gt; max_safe_exponent:\n            raise ExcessiveExponentError(\n                max_exponent=max_safe_exponent,\n                current_exponent=n_1,\n            )\n\n        self._x = x[0]\n        self.n_0 = n_0\n        self.n_1 = n_1\n\n    @property\n    def __input__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the input data.\"\"\"\n        return (np.array(self._x),)\n\n    @property\n    @abstractmethod\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the function.\"\"\"\n\n    def __call__(self) -&gt; ResultsPathologicalAPI:\n        \"\"\"Return the results of the function.\"\"\"\n        return ResultsPathologicalAPI(\n            x=self.__input__,\n            result=self.__eval__,\n            doc=self.__doc__,\n        )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalBase.__eval__","title":"<code>__eval__</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalBase.__input__","title":"<code>__input__</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsPathologicalAPI:\n    \"\"\"Return the results of the function.\"\"\"\n    return ResultsPathologicalAPI(\n        x=self.__input__,\n        result=self.__eval__,\n        doc=self.__doc__,\n    )\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalBase.__init__","title":"<code>__init__(*x, n_0=0, n_1=100, max_safe_exponent=200)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    n_0: int = 0,\n    n_1: int = 100,\n    max_safe_exponent: float = 200,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if x[0] is None:\n        raise MissingXError\n\n    if len(x) != __1d__:\n        raise OutOfDimensionError(\n            function_name=self.__class__.__name__,\n            dimension=__1d__,\n        )\n    if np.abs(n_1) &gt; max_safe_exponent:\n        raise ExcessiveExponentError(\n            max_exponent=max_safe_exponent,\n            current_exponent=n_1,\n        )\n\n    self._x = x[0]\n    self.n_0 = n_0\n    self.n_1 = n_1\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalPure","title":"<code>PathologicalPure</code>","text":"<p>               Bases: <code>PathologicalBase</code></p> <p>Base class for pathological functions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one-dimensional.</p> <code>()</code> <code>n_0</code> <code>int</code> <p>Start of the interval. Defaults to 0.</p> <code>0</code> <code>n_1</code> <code>int</code> <p>End of the interval. Defaults to 100.</p> <code>100</code> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class PathologicalPure(PathologicalBase):\n    \"\"\"Base class for pathological functions with a standard deviation.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one-dimensional.\n        n_0 (int): Start of the interval. Defaults to 0.\n        n_1 (int): End of the interval. Defaults to 100.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        n_0: int = 0,\n        n_1: int = 100,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, n_0=n_0, n_1=n_1)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalPure.__init__","title":"<code>__init__(*x, n_0=0, n_1=100)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    n_0: int = 0,\n    n_1: int = 100,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, n_0=n_0, n_1=n_1)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalWithCoefficients","title":"<code>PathologicalWithCoefficients</code>","text":"<p>               Bases: <code>PathologicalBase</code></p> <p>Base class for pathological functions with coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one-dimensional.</p> <code>()</code> <code>n_1</code> <code>int</code> <p>End of the interval. Defaults to 100.</p> <code>100</code> <code>a</code> <code>float</code> <p>First shape parameter of the function.</p> required <code>b</code> <code>float</code> <p>Second shape parameter of the function.</p> required Source code in <code>umf/meta/functions.py</code> Python<pre><code>class PathologicalWithCoefficients(PathologicalBase):\n    \"\"\"Base class for pathological functions with coefficients.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one-dimensional.\n        n_1 (int): End of the interval. Defaults to 100.\n        a (float): First shape parameter of the function.\n        b (float): Second shape parameter of the function.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        n_0: int = 0,\n        n_1: int = 100,\n        a: float,\n        b: float,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, n_0=n_0, n_1=n_1)\n        self.a = a\n        self.b = b\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.PathologicalWithCoefficients.__init__","title":"<code>__init__(*x, n_0=0, n_1=100, a, b)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    n_0: int = 0,\n    n_1: int = 100,\n    a: float,\n    b: float,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x, n_0=n_0, n_1=n_1)\n    self.a = a\n    self.b = b\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuous","title":"<code>SemiContinuous</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for semi continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuous(ContinuousDistributionBase):\n    \"\"\"Base class for semi continuous distributions with a standard deviation.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWBeta","title":"<code>SemiContinuousWBeta</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuousWBeta(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with beta parameter.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        beta: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if (min_x := np.min(x)) &lt; 0:\n            raise NotAPositiveNumberError(var_number=\"*x\", number=float(min_x))\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n        if beta &lt;= 0:\n            raise NotAPositiveNumberError(var_number=\"beta\", number=beta)\n        self.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWBeta.__init__","title":"<code>__init__(*x, mu=0, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    beta: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if (min_x := np.min(x)) &lt; 0:\n        raise NotAPositiveNumberError(var_number=\"*x\", number=float(min_x))\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n    if beta &lt;= 0:\n        raise NotAPositiveNumberError(var_number=\"beta\", number=beta)\n    self.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWSigma","title":"<code>SemiContinuousWSigma</code>","text":"<p>               Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuousWSigma(ContinuousDistributionBase):\n    \"\"\"Base class for continuous distributions with a standard deviation.\n\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if np.min(x) &lt; 0:\n            raise NotAPositiveNumberError(var_number=\"*x\", number=float(np.min(x)))\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n        self.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWSigma.__init__","title":"<code>__init__(*x, mu=0, sigma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    mu: float = 0,\n    sigma: float = 1,\n    cumulative: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if np.min(x) &lt; 0:\n        raise NotAPositiveNumberError(var_number=\"*x\", number=float(np.min(x)))\n    super().__init__(*x, mu=mu, cumulative=cumulative)\n    self.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.AnimationSettings","title":"<code>AnimationSettings</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A named tuple representing the settings for the animation of a 2D and 3D plot.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>int</code> <p>The number of frames in the animation. Defaults to 40.</p> required <code>interval</code> <code>int</code> <p>The delay between frames in milliseconds. Defaults to 30.</p> required <code>dpi</code> <code>int</code> <p>The resolution of the output animation in dots per inch. Defaults to 100.</p> required Source code in <code>umf/meta/plots.py</code> Python<pre><code>class AnimationSettings(NamedTuple):\n    \"\"\"A named tuple representing the settings for the animation of a 2D and 3D plot.\n\n    Args:\n        frames (int, optional): The number of frames in the animation. Defaults to 40.\n        interval (int, optional): The delay between frames in milliseconds. Defaults\n            to 30.\n        dpi (int, optional): The resolution of the output animation in dots per inch.\n            Defaults to 100.\n    \"\"\"\n\n    frames: int = 40\n    interval: int = 30\n    dpi: int = 100\n    steps: int = 100\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.GIFSettings","title":"<code>GIFSettings</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A named tuple representing the settings for the GIF animation of a 3D plot.</p> <p>Parameters:</p> Name Type Description Default <code>dpi</code> <code>int</code> <p>The resolution of the output GIF in dots per inch. Defaults to 100.</p> required <code>zoom</code> <code>bool</code> <p>Whether or not to include a zoom effect in the animation. Defaults to True.</p> required <code>zoom_start</code> <code>float</code> <p>The starting zoom level for the zoom effect. Defaults to 0.5.</p> required <code>zoom_stop</code> <code>float</code> <p>The ending zoom level for the zoom effect. Defaults to 1.5.</p> required <code>rotate</code> <code>bool</code> <p>Whether or not to include a rotation effect in the animation. Defaults to True.</p> required <code>elev</code> <code>int</code> <p>The elevation angle of the plot in degrees. Defaults to 30.</p> required <code>azim</code> <code>int</code> <p>The azimuth angle of the plot in degrees. Defaults to 5.</p> required <code>frames</code> <code>int</code> <p>The number of frames in the animation. Defaults to 72.</p> required <code>interval</code> <code>int</code> <p>The delay between frames in milliseconds. Defaults to  50.</p> required Source code in <code>umf/meta/plots.py</code> Python<pre><code>class GIFSettings(NamedTuple):\n    \"\"\"A named tuple representing the settings for the GIF animation of a 3D plot.\n\n    Args:\n        dpi (int, optional): The resolution of the output GIF in dots per inch.\n            Defaults to 100.\n        zoom (bool, optional): Whether or not to include a zoom effect in the animation.\n            Defaults to True.\n        zoom_start (float, optional): The starting zoom level for the zoom effect.\n            Defaults to 0.5.\n        zoom_stop (float, optional): The ending zoom level for the zoom effect.\n            Defaults to 1.5.\n        rotate (bool, optional): Whether or not to include a rotation effect in the\n            animation. Defaults to True.\n        elev (int, optional): The elevation angle of the plot in degrees. Defaults to\n            30.\n        azim (int, optional): The azimuth angle of the plot in degrees. Defaults to 5.\n        frames (int, optional): The number of frames in the animation. Defaults to 72.\n        interval (int, optional): The delay between frames in milliseconds. Defaults to\n             50.\n    \"\"\"\n\n    dpi: int = 100\n    zoom: bool = True\n    zoom_start: float = 0.5\n    zoom_stop: float = 1.5\n    rotate: bool = True\n    elev: int = 30\n    azim: int = 5\n    frames: int = 72\n    interval: int = 50\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.GraphSettings","title":"<code>GraphSettings</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Settings for the graph.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>The size of the plot. Defaults to (5, 5).</p> <code>dpi</code> <code>int</code> <p>The DPI of the plot. Defaults to 200.</p> <code>axis</code> <code>list[str]</code> <p>The labels for the axes of the plot. Defaults to  None.</p> <code>title</code> <code>str</code> <p>The title of the plot. Defaults to None.</p> <code>color</code> <code>str</code> <p>The color of the plot. Defaults to None.</p> <code>cmap</code> <code>str</code> <p>The colormap of the plot. Defaults to \"YlGnBu_r\".</p> <code>alpha</code> <code>float</code> <p>The alpha value of the plot. Defaults to None.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>class GraphSettings(NamedTuple):\n    \"\"\"Settings for the graph.\n\n    Attributes:\n        size (tuple[int, int]): The size of the plot. Defaults to (5, 5).\n        dpi (int, optional): The DPI of the plot. Defaults to 200.\n        axis (list[str], optional): The labels for the axes of the plot. Defaults to\n             None.\n        title (str, optional): The title of the plot. Defaults to None.\n        color (str, optional): The color of the plot. Defaults to None.\n        cmap (str, optional): The colormap of the plot. Defaults to \"YlGnBu_r\".\n        alpha (float, optional): The alpha value of the plot. Defaults to None.\n    \"\"\"\n\n    size: tuple[int, int] = (5, 5)\n    dpi: int = 200\n    axis: list[str] | None = None\n    title: str | None = None\n    color: str | None = None\n    cmap: str = \"viridis_r\"\n    alpha: float | None = None\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot","title":"<code>Plot</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for plotting functions.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Source code in <code>umf/meta/plots.py</code> Python<pre><code>class Plot(ABC):\n    \"\"\"Abstract class for plotting functions.\n\n    Args:\n        *x (UniversalArray):  Input data, which can be one, two, three, or higher\n             dimensional.\n\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the plot\n             function.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        settings: GraphSettings = None,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if x is None:\n            msg = \"x has to be specified.\"\n            raise ValueError(msg)\n\n        if settings is None:\n            settings = GraphSettings()\n\n        self._x = x\n        self.dimension = len(x)\n        self.title = settings.title\n        self.axis = (\n            settings.axis\n            if settings.axis is not None\n            else [f\"x_{i}\" for i in range(self.dimension)]\n        )\n        self.color = settings.color\n        self.cmap = settings.cmap\n        self.alpha = settings.alpha\n        self.size = settings.size\n        self.dpi = settings.dpi\n        self._kwargs = kwargs\n\n    def plot_2d(self) -&gt; None:\n        \"\"\"Plot the data in 2D.\"\"\"\n        raise NotImplementedError\n\n    def plot_series(self) -&gt; None:\n        \"\"\"Plot the data in 2D as a series.\"\"\"\n        raise NotImplementedError\n\n    def plot_3d(self) -&gt; None:\n        \"\"\"Plot the data in 3D.\"\"\"\n        raise NotImplementedError\n\n    def plot_contour(self) -&gt; None:\n        \"\"\"Plot the data as a contour plot.\"\"\"\n        raise NotImplementedError\n\n    def plot_surface(self) -&gt; None:\n        \"\"\"Plot the data as a surface plot.\"\"\"\n        raise NotImplementedError\n\n    def plot_dashboard(self) -&gt; None:\n        \"\"\"Plot the data as a dashboard.\"\"\"\n        raise NotImplementedError\n\n    def animate(self) -&gt; None:\n        \"\"\"Animate the plot.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def plot_show(self) -&gt; None:\n        \"\"\"Show the plot.\"\"\"\n\n    @property\n    @abstractmethod\n    def plot_return(self) -&gt; plt.figure | go.Figure:\n        \"\"\"Return the plot.\"\"\"\n\n    @staticmethod\n    def ax_return() -&gt; plt.Figure:\n        \"\"\"Return the Figure.\"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    @abstractmethod\n    def plot_save(\n        fig: plt.Figure | go.Figure,\n        fname: Path,\n        fformat: str = \"png\",\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Saves the given plot to a file.\n\n        Args:\n            fig (plt.Figure | go.Figure): The figure to save as an image file.\n            fname (Path): The file path to save the plot to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n                 function.\n        \"\"\"\n\n    @staticmethod\n    def plot_save_gif(\n        fig: plt.Figure,\n        ax_fig: plt.Figure,\n        fname: Path,\n        settings: GIFSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Saves the given plot to a file.\n\n        Notes:\n            This function can currently only be implemented for matplotlib plots and\n            not for plotly plots.\n\n        Args:\n            fig (plt.figure): The figure to save as an image file.\n            ax_fig (plt.Figure): The figure to save as an image file.\n            fname (Path): The file path to save the plot to.\n            settings (GIFSettings): The settings for the GIF animation.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n                 function.\n\n        Raises:\n            NotImplementedError: This function is not yet implemented.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_return","title":"<code>plot_return</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.__init__","title":"<code>__init__(*x, settings=None, **kwargs)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    settings: GraphSettings = None,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if x is None:\n        msg = \"x has to be specified.\"\n        raise ValueError(msg)\n\n    if settings is None:\n        settings = GraphSettings()\n\n    self._x = x\n    self.dimension = len(x)\n    self.title = settings.title\n    self.axis = (\n        settings.axis\n        if settings.axis is not None\n        else [f\"x_{i}\" for i in range(self.dimension)]\n    )\n    self.color = settings.color\n    self.cmap = settings.cmap\n    self.alpha = settings.alpha\n    self.size = settings.size\n    self.dpi = settings.dpi\n    self._kwargs = kwargs\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.animate","title":"<code>animate()</code>","text":"<p>Animate the plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def animate(self) -&gt; None:\n    \"\"\"Animate the plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.ax_return","title":"<code>ax_return()</code>  <code>staticmethod</code>","text":"<p>Return the Figure.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\ndef ax_return() -&gt; plt.Figure:\n    \"\"\"Return the Figure.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_2d","title":"<code>plot_2d()</code>","text":"<p>Plot the data in 2D.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_2d(self) -&gt; None:\n    \"\"\"Plot the data in 2D.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_3d","title":"<code>plot_3d()</code>","text":"<p>Plot the data in 3D.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_3d(self) -&gt; None:\n    \"\"\"Plot the data in 3D.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_contour","title":"<code>plot_contour()</code>","text":"<p>Plot the data as a contour plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_contour(self) -&gt; None:\n    \"\"\"Plot the data as a contour plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_dashboard","title":"<code>plot_dashboard()</code>","text":"<p>Plot the data as a dashboard.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_dashboard(self) -&gt; None:\n    \"\"\"Plot the data as a dashboard.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', **kwargs)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>The figure to save as an image file.</p> required <code>fname</code> <code>Path</code> <p>The file path to save the plot to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the save  function.</p> <code>{}</code> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\n@abstractmethod\ndef plot_save(\n    fig: plt.Figure | go.Figure,\n    fname: Path,\n    fformat: str = \"png\",\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Saves the given plot to a file.\n\n    Args:\n        fig (plt.Figure | go.Figure): The figure to save as an image file.\n        fname (Path): The file path to save the plot to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n             function.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_save_gif","title":"<code>plot_save_gif(fig, ax_fig, fname, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> Notes <p>This function can currently only be implemented for matplotlib plots and not for plotly plots.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save as an image file.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save as an image file.</p> required <code>fname</code> <code>Path</code> <p>The file path to save the plot to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF animation.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the save  function.</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This function is not yet implemented.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\ndef plot_save_gif(\n    fig: plt.Figure,\n    ax_fig: plt.Figure,\n    fname: Path,\n    settings: GIFSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Saves the given plot to a file.\n\n    Notes:\n        This function can currently only be implemented for matplotlib plots and\n        not for plotly plots.\n\n    Args:\n        fig (plt.figure): The figure to save as an image file.\n        ax_fig (plt.Figure): The figure to save as an image file.\n        fname (Path): The file path to save the plot to.\n        settings (GIFSettings): The settings for the GIF animation.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n             function.\n\n    Raises:\n        NotImplementedError: This function is not yet implemented.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_series","title":"<code>plot_series()</code>","text":"<p>Plot the data in 2D as a series.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_series(self) -&gt; None:\n    \"\"\"Plot the data in 2D as a series.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_show","title":"<code>plot_show()</code>  <code>abstractmethod</code>","text":"<p>Show the plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@abstractmethod\ndef plot_show(self) -&gt; None:\n    \"\"\"Show the plot.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_surface","title":"<code>plot_surface()</code>","text":"<p>Plot the data as a surface plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_surface(self) -&gt; None:\n    \"\"\"Plot the data as a surface plot.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/api/optimization/","title":"Modules","text":"<p>Bowl shaped functions for the useful-math-functions library.</p> <p>Drop steps functions for the useful-math-functions library.</p> <p>Many local minima functions for the useful-math-functions library.</p> <p>Plate shaped functions for the useful-math-functions library.</p> <p>Special optimization functions for the useful-math-functions library.</p> <p>Valley shaped functions for the useful-math-functions library.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1","title":"<code>BohachevskyFunctionType1</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Bohachevsky function type 1.</p> <p>The Bohachevsky function type 1 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 1 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType1(OptFunction):\n    r\"\"\"Bohachevsky function type 1.\n\n    The Bohachevsky function type 1 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 1 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType1\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 1 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2\n            + 2 * x_2**2\n            - 0.3 * np.cos(3 * np.pi * x_1)\n            - 0.4 * np.cos(4 * np.pi * x_2)\n            + 0.7\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 1.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 1.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 1 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 1.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 1.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"BohachevskyType1\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2","title":"<code>BohachevskyFunctionType2</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Bohachevsky function tye 2.</p> <p>The Bohachevsky function type 2 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 2 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType2(OptFunction):\n    r\"\"\"Bohachevsky function tye 2.\n\n    The Bohachevsky function type 2 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 2 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType2\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 2 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2\n            + 2 * x_2**2\n            - 0.3 * np.cos(3 * np.pi * x_1) * np.cos(4 * np.pi * x_2)\n            + 0.3\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 2.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 2.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 2 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 2.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 2.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"BohachevskyType2\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3","title":"<code>BohachevskyFunctionType3</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Bohachevsky function type 3.</p> <p>The Bohachevsky function type 3 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 3 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType3(OptFunction):\n    r\"\"\"Bohachevsky function type 3.\n\n    The Bohachevsky function type 3 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 3 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType3\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 3 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2 + 2 * x_2**2 - 0.3 * np.cos(3 * np.pi * x_1 + 4 * np.pi * x_2) + 0.3\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 3.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 3.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 3 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 3.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 3.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"BohachevskyType3\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction","title":"<code>PermBetaDFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Perm Beta D function.</p> <p>The Perm Beta D function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm Beta D function is defined as:</p> \\[     f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +     \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 0.5\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermBetaDFunction(OptFunction):\n    r\"\"\"Perm Beta D function.\n\n    The Perm Beta D function is a D-dimensional function with multimodal structure\n    and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Perm Beta D function is defined as:\n\n        $$\n            f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +\n            \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n\n        with constant $\\beta = 0.5$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Perm Beta D function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        beta = 0.5\n\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = sum(\n                (j**i + beta) * ((self._x[j - 1] / j) ** i - 1)\n                for j in range(1, self.dimension + 1)\n            )\n            outer_sum += inner_sum**2\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Perm Beta D function.\n\n        Returns:\n            MinimaAPI: Minima of the Perm Beta D function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Perm Beta D function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Perm Beta D function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Perm Beta D function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction","title":"<code>PermFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Perm function.</p> <p>The Perm function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D j^{i+1} (j + \\beta)       \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 10\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>The beta parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermFunction(OptFunction):\n    r\"\"\"Perm function.\n\n    The Perm function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Perm function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D j^{i+1} (j + \\beta)\n              \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n\n        with constant $\\beta = 10$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        beta (float, optional): The beta parameter. Defaults to 10.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, beta: float = 10) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n        self.beta = beta\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Perm function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = sum(\n                j ** (i + 1) * (j + self.beta) * ((self._x[j - 1] / j) ** i - 1)\n                for j in range(1, self.dimension + 1)\n            )\n            outer_sum += inner_sum**2\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Perm function.\n\n        Returns:\n            MinimaAPI: Minima of the Perm function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Perm function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Perm function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Perm function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__init__","title":"<code>__init__(*x, beta=10)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, beta: float = 10) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n    self.beta = beta\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction","title":"<code>RotatedHyperEllipseFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Rotated hyper-ellipse function.</p> <p>The Rotated hyper-ellipse function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... RotatedHyperEllipseFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rotated hyper-ellipse function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2 \\] <p>with \\(D\\) the dimension of the input and \\(a_{ij}\\) the rotation matrix. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class RotatedHyperEllipseFunction(OptFunction):\n    r\"\"\"Rotated hyper-ellipse function.\n\n    The Rotated hyper-ellipse function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... RotatedHyperEllipseFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rotated hyper-ellipse function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2\n        $$\n\n        with $D$ the dimension of the input and $a_{ij}$ the rotation matrix. The\n        hypercube of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/rothyp.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"RotatedHyperEllipse\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rotated hyper-ellipse function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n        for i in range(self.dimension):\n            inner_sum = np.zeros(self._x[0].shape)\n            for j in range(i + 1):\n                inner_sum += self._x[j] ** 2\n            outer_sum = outer_sum + inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Rotated hyper-ellipse function.\n\n        Returns:\n            MinimaAPI: Minima of the Rotated hyper-ellipse function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Rotated hyper-ellipse function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Rotated hyper-ellipse function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Rotated hyper-ellipse function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"RotatedHyperEllipse\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction","title":"<code>SphereFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Sphere function.</p> <p>The Sphere function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sphere function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SphereFunction(OptFunction):\n    r\"\"\"Sphere function.\n\n    The Sphere function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n        &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sphere function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D x_i^2\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/spheref.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sphere function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return np.sum(np.power(self._x, 2), axis=0)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sphere function.\n\n        Returns:\n            MinimaAPI: Minima of the Sphere function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Sphere function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Sphere function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sphere function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction","title":"<code>SumOfDifferentPowersFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Sum of different powers function.</p> <p>The Sum of different powers function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... SumOfDifferentPowersFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum of different powers function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>_Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumOfDifferentPowersFunction(OptFunction):\n    r\"\"\"Sum of different powers function.\n\n    The Sum of different powers function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... SumOfDifferentPowersFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sum of different powers function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1}\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        _Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sum of different powers function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = abs(self._x[i - 1]) ** (i + 1)\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sum of different powers function.\n\n        Returns:\n            MinimaAPI: Minima of the Sum of different powers function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Sum of different powers function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Sum of different powers function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sum of different powers function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction","title":"<code>SumSquaresFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Sum squares function.</p> <p>The Sum squares function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum squares function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D i x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumSquaresFunction(OptFunction):\n    r\"\"\"Sum squares function.\n\n    The Sum squares function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sum squares function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D i x_i^2\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumsqu.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sum squares function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = i * self._x[i - 1] ** 2\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sum squares function.\n\n        Returns:\n            MinimaAPI: Minima of the Sum squares function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Sum squares function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Sum squares function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sum squares function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction","title":"<code>TridFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Trid function.</p> <p>The Trid function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Trid function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class TridFunction(OptFunction):\n    r\"\"\"Trid function.\n\n    The Trid function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Trid function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1}\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/trid.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Trid function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = (self._x[i - 1] - 1) ** 2 - self._x[i - 1] * self._x[i - 2]\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Trid function.\n\n        Returns:\n            MinimaAPI: Minima of the Trid function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-self.dimension * (self.dimension + 4) * (self.dimension - 1) / 6,\n            x=tuple(i * (self.dimension + 1 - i) for i in range(1, self.dimension + 1)),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Trid function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Trid function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Trid function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction","title":"<code>ZirilliFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Zirilli function.</p> <p>The Zirilli function is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zirilli function is defined as:</p> \\[     f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2 \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class ZirilliFunction(OptFunction):\n    r\"\"\"Zirilli function.\n\n    The Zirilli function is a 2D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zirilli function is defined as:\n\n        $$\n            f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2\n        $$\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Zirilli\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Zirilli function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 0.25 * x_1**4 - 0.5 * x_1**2 + 0.1 * x_1 + 0.5 * x_2**2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zirilli function.\n\n        Returns:\n            MinimaAPI: Minima of the Zirilli function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-0.352386073800034,\n            x=(-1.046680576580755, 0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Zirilli function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Zirilli function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Zirilli function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Zirilli\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function","title":"<code>DeJongN5Function</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>De Jong N.5 Function.</p> <p>The De Jong N.5 function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n&gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The De Jong N.5 function is defined as:</p> \\[     f(x, y) = \\left(         0.0002 + \\sum_{i=1}^{25}         \\frac{1}{             i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6         }     \\right)^{-1} \\] <p>where</p> \\[     a = \\left(         \\begin{matrix}         -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\         -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32         \\end{matrix}         \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  adddimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Elements of the matrix a, which has to become are 2-dimensional with shape (2, 25). Defaults to None.</p> <code>None</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class DeJongN5Function(OptFunction):\n    r\"\"\"De Jong N.5 Function.\n\n    The De Jong N.5 function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n        &gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The De Jong N.5 function is defined as:\n\n        $$\n            f(x, y) = \\left(\n                0.0002 + \\sum_{i=1}^{25}\n                \\frac{1}{\n                    i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6\n                }\n            \\right)^{-1}\n        $$\n\n        where\n\n        $$\n            a = \\left(\n                \\begin{matrix}\n                -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\\n                -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32\n                \\end{matrix}\n                \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/dejong5.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             adddimensional.\n        A (UniversalArray, optional): Elements of the matrix a, which has to become are\n            2-dimensional with shape (2, 25). Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        A: UniversalArray | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"De Jong N.5\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n        if A is None:\n            row_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\n            row_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\n            self.a_matrix = np.vstack((row_1, row_2))\n        elif A.shape != (2, 25):\n            msg = \"The shape of a has to be (2, 25).\"\n            raise ValueError(msg)\n        else:\n            self.a_matrix = A\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the De Jong N.5 function.\n\n        Returns:\n            UniversalArray: The value of the De Jong N.5 function.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        a_1 = self.a_matrix[0, :]\n        a_2 = self.a_matrix[1, :]\n\n        sum_ = np.zeros_like(x_1)\n\n        for i in range(25):\n            sum_ += 1 / ((i + 1) + (x_1 - a_1[i]) ** 6 + (x_2 - a_2[i]) ** 6)\n\n        return (0.0002 + sum_) ** -1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the De Jong N.5 function.\n\n        Returns:\n            MinimaAPI: The minima of the De Jong N.5 function.\n        \"\"\"\n        return MinimaAPI(f_x=0.0, x=(0.0, 0.0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the De Jong N.5 function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the De Jong N.5 function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the De Jong N.5 function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the De Jong N.5 function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__init__","title":"<code>__init__(*x, A=None)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    A: UniversalArray | None = None,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"De Jong N.5\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n\n    if A is None:\n        row_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\n        row_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\n        self.a_matrix = np.vstack((row_1, row_2))\n    elif A.shape != (2, 25):\n        msg = \"The shape of a has to be (2, 25).\"\n        raise ValueError(msg)\n    else:\n        self.a_matrix = A\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction","title":"<code>EasomFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Easom Function.</p> <p>The Easom function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Easom function is defined as:</p> \\[     f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2     - \\left(y-\\pi\\right)^2\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class EasomFunction(OptFunction):\n    r\"\"\"Easom Function.\n\n    The Easom function is a two-dimensional function with a single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Easom function is defined as:\n\n        $$\n            f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2\n            - \\left(y-\\pi\\right)^2\\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/easom.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Easom\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Easom function.\n\n        Returns:\n            UniversalArray: The value of the Easom function.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        return np.array(\n            -np.cos(x_1)\n            * np.cos(x_2)\n            * np.exp(-((x_1 - np.pi) ** 2) - (x_2 - np.pi) ** 2),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Easom function.\n\n        Returns:\n            MinimaAPI: The minima of the Easom function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-1.0,\n            x=np.array([np.pi, np.pi]),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Easom function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the Easom function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Easom function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the Easom function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Easom\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction","title":"<code>MichalewiczFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Michalewicz Function.</p> <p>The Michalewicz function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Michalewicz function is defined as:</p> \\[     f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>m</code> <code>int</code> <p>The m parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class MichalewiczFunction(OptFunction):\n    r\"\"\"Michalewicz Function.\n\n    The Michalewicz function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n        &gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Michalewicz function is defined as:\n\n        $$\n            f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/michal.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        m (int, optional): The m parameter. Defaults to 10.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n        self.m = m\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Michalewicz function.\n\n        Returns:\n            UniversalArray: The value of the Michalewicz function.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n\n        for i, x_i in enumerate(self._x, start=1):\n            sum_ += np.sin(x_i) * np.sin((i * x_i**2) / np.pi) ** (2 * self.m)\n\n        return -sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Michalewicz function.\n\n         The minima of the Michalewicz function is not unique and depends on the\n            m parameter and dimensionality of the function.\n\n        Returns:\n            MinimaAPI: The minima of the Michalewicz function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-1.8013,\n            x=(2.20, 1.57),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Michalewicz function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the Michalewicz function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Michalewicz function.</p> <p>The minima of the Michalewicz function is not unique and depends on the     m parameter and dimensionality of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the Michalewicz function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__init__","title":"<code>__init__(*x, m=10)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n\n    self.m = m\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction","title":"<code>AckleyFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Ackley function.</p> <p>The Ackley function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Ackley function is defined as:</p> \\[     f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}       \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)       \\right) + e + \\alpha \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>alpha</code> <code>float</code> <p>Scaling factor. Default is 20.0.</p> <code>20.0</code> <code>beta</code> <code>float</code> <p>Scaling factor. Default is 0.2.</p> <code>0.2</code> <code>gamma</code> <code>float</code> <p>Scaling factor. Default is 2.0 * np.pi.</p> <code>2.0 * pi</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class AckleyFunction(OptFunction):\n    r\"\"\"Ackley function.\n\n    The Ackley function is a multi-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Ackley function is defined as:\n\n        $$\n            f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}\n              \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)\n              \\right) + e + \\alpha\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/ackley.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        alpha (float): Scaling factor. Default is 20.0.\n        beta (float): Scaling factor. Default is 0.2.\n        gamma (float): Scaling factor. Default is 2.0 * np.pi.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        alpha: float = 20.0,\n        beta: float = 0.2,\n        gamma: float = 2.0 * np.pi,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n        self._alpha = alpha\n        self._beta = beta\n        self._gamma = gamma\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Ackley function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_1 = np.zeros_like(self._x[0])\n        sum_2 = np.zeros_like(self._x[0])\n\n        for _i, _x in enumerate(self._x, start=1):\n            # Calculate sum of squares of x values\n            sum_1 += _x**2\n            # Calculate sum of cosines of x values\n            sum_2 += np.cos(self._gamma * _x)\n\n        # Calculate exponential terms\n        terms_1 = -self._alpha * np.exp(-self._beta * np.sqrt(1 / _i * sum_1))\n        terms_2 = -np.exp(1 / _i * sum_2)\n\n        # Calculate Ackley function value\n        terms_3 = np.e + self._alpha\n        return terms_1 + terms_2 + terms_3\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Ackley function.\"\"\"\n        return MinimaAPI(f_x=0.0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Ackley function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Ackley function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__init__","title":"<code>__init__(*x, alpha=20.0, beta=0.2, gamma=2.0 * np.pi)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    alpha: float = 20.0,\n    beta: float = 0.2,\n    gamma: float = 2.0 * np.pi,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n    self._alpha = alpha\n    self._beta = beta\n    self._gamma = gamma\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function","title":"<code>BukinN6Function</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Bukin function number 6.</p> <p>The Bukin function number 6 is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n&gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bukin function number 6 is defined as:</p> \\[     f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +     0.01 \\left| x + 10 \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class BukinN6Function(OptFunction):\n    r\"\"\"Bukin function number 6.\n\n    The Bukin function number 6 is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n        &gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bukin function number 6 is defined as:\n\n        $$\n            f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +\n            0.01 \\left| x + 10 \\right|\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/bukin6.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Bukin\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bukin function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = 100 * np.sqrt(np.abs(x_2 - 0.01 * x_1**2))\n        term_2 = 0.01 * np.abs(x_1 + 10)\n\n        return term_1 + term_2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(-10.0, 1.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Bukin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Bukin\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction","title":"<code>CrossInTrayFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Cross-in-tray function.</p> <p>The Cross-in-tray function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cross-in-tray function is defined as:</p> \\[     f(x) = -0.0001 \\cdot \\left( \\left| \\sin(x_1) \\sin(x_2)     \\exp \\left( \\left| 100 - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right) \\right|     + 1 \\right)^{0.1} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class CrossInTrayFunction(OptFunction):\n    r\"\"\"Cross-in-tray function.\n\n    The Cross-in-tray function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Cross-in-tray function is defined as:\n\n        $$\n            f(x) = -0.0001 \\cdot \\left( \\left| \\sin(x_1) \\sin(x_2)\n            \\exp \\left( \\left| 100 - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right) \\right|\n            + 1 \\right)^{0.1}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/crossit.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Cross-in-tray\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Cross-in-tray function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(x_1) * np.sin(x_2)\n        term_2 = np.exp(np.abs(100 - np.sqrt(x_1**2 + x_2**2) / np.pi))\n        return -0.0001 * np.abs(term_1 * term_2 + 1) ** 0.1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-2.06261,\n            x=tuple(\n                np.array([1.34941, 1.34941]),\n                np.array([-1.34941, -1.34941]),\n                np.array([1.34941, -1.34941]),\n                np.array([-1.34941, 1.34941]),\n            ),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Cross-in-tray function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Cross-in-tray\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction","title":"<code>DropWaveFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Drop-wave function.</p> <p>The Drop-wave function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Drop-wave function is defined as:</p> \\[     f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)     / (0.5(x_1^2 + x_2^2) + 2) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class DropWaveFunction(OptFunction):\n    r\"\"\"Drop-wave function.\n\n    The Drop-wave function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Drop-wave function is defined as:\n\n        $$\n            f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)\n            / (0.5(x_1^2 + x_2^2) + 2)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/drop.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Drop-wave\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Drop-wave function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = 12 * np.sqrt(x_1**2 + x_2**2)\n        term_2 = 0.5 * (x_1**2 + x_2**2) + 2\n\n        return -((1 + np.cos(term_1)) / term_2)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=-1.0, x=tuple(0.0, 0.0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Drop-wave function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Drop-wave\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction","title":"<code>EggHolderFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Egg-holder function.</p> <p>The Egg-holder function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n&gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Egg-holder function is defined as:</p> \\[     f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}     + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1     - (x_2 + 47) \\right|} \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class EggHolderFunction(OptFunction):\n    r\"\"\"Egg-holder function.\n\n    The Egg-holder function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n        &gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Egg-holder function is defined as:\n\n        $$\n            f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}\n            + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1\n            - (x_2 + 47) \\right|} \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/egg.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Egg-holder\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Egg-holder function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sqrt(np.abs(x_2 + 47 + x_1 / 2))\n        term_2 = np.sqrt(np.abs(x_1 - (x_2 + 47)))\n\n        return -(x_2 + 47) * np.sin(term_1) - x_1 * np.sin(term_2)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=-959.6407, x=tuple(512, 404.2319))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Egg-holder function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Egg-holder\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction","title":"<code>GramacyLeeFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Gramacy and Lee function.</p> <p>The Gramacy and Lee function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GramacyLeeFunction\n&gt;&gt;&gt; x = np.linspace(-1, 2.5, 1000)\n&gt;&gt;&gt; y = GramacyLeeFunction(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot(x, y)\n&gt;&gt;&gt; plt.savefig(\"GramacyLeeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gramacy and Lee function is defined as:</p> \\[     f(x) = \\sin(10 \\pi x_1) / (2 x_1) + (x_1 - 1)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be one dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GramacyLeeFunction(OptFunction):\n    r\"\"\"Gramacy and Lee function.\n\n    The Gramacy and Lee function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GramacyLeeFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 2.5, 1000)\n        &gt;&gt;&gt; y = GramacyLeeFunction(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot(x, y)\n        &gt;&gt;&gt; plt.savefig(\"GramacyLeeFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gramacy and Lee function is defined as:\n\n        $$\n            f(x) = \\sin(10 \\pi x_1) / (2 x_1) + (x_1 - 1)^4\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/gramacy.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be one dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __1d__:\n            raise OutOfDimensionError(\n                function_name=\"Gramacy and Lee\",\n                dimension=__1d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Gramacy and Lee function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n\n        term_1 = np.sin(10 * np.pi * x_1) / (2 * x_1)\n        term_2 = (x_1 - 1) ** 4\n\n        return term_1 + term_2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=None, x=None)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Gramacy and Lee function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __1d__:\n        raise OutOfDimensionError(\n            function_name=\"Gramacy and Lee\",\n            dimension=__1d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction","title":"<code>GriewankFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Griewank function.</p> <p>The Griewank function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Griewank function is defined as:</p> \\[     f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos     \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GriewankFunction(OptFunction):\n    r\"\"\"Griewank function.\n\n    The Griewank function is a multi-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Griewank function is defined as:\n\n        $$\n            f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos\n            \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/griewank.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Griewank function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n        for i, x_i in enumerate(self._x, start=1):\n            sum_ += 1 / 4000 * x_i**2\n            if i == 1:\n                prod_ = np.cos(x_i / np.sqrt(i))\n            prod_ *= np.cos(x_i / np.sqrt(i))\n\n        return sum_ - prod_ + 1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Griewank function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction","title":"<code>HolderTableFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Holder table function.</p> <p>The Holder table function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Holder table function is defined as:</p> \\[     f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /     \\pi \\right| \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class HolderTableFunction(OptFunction):\n    r\"\"\"Holder table function.\n\n    The Holder table function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Holder table function is defined as:\n\n        $$\n            f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /\n            \\pi \\right| \\right|\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/holder.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Holder table\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Holder table function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(x_1) * np.cos(x_2)\n        term_2 = np.abs(1 - np.sqrt(x_1**2 + x_2**2) / np.pi)\n        term_3 = np.exp(term_2)\n\n        return -np.abs(term_1 * term_3)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-19.2085,\n            x=tuple(\n                np.array([8.05502, 9.66459]),\n                np.array([8.05502, -9.66459]),\n                np.array([-8.05502, 9.66459]),\n                np.array([-8.05502, -9.66459]),\n            ),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Holder table function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Holder table\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction","title":"<code>LangermannFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Langermann function.</p> <p>The Langermann function is a multi-dimensional function with many unevenly distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Langermann function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}     (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi     \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right) \\] <p>with the constants :math:<code>c_i</code> and the :math:<code>a_{ij}</code> given by:</p> \\[     c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =     \\left\\{ 3, 5, 2, 1, 7 \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Matrix of constants :math:<code>a_{ij}</code>. The numbers of rows has to be equal to the number of input data, respectively, dimensions. Defaults to :math:<code>a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}</code>.</p> <code>None</code> <code>c</code> <code>UniversalArray</code> <p>Vector of constants :math:<code>c_i</code>. Defaults to :math:<code>c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}</code>.</p> <code>None</code> <code>m</code> <code>int</code> <p>Number of local minima. Defaults to 5.</p> <code>5</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LangermannFunction(OptFunction):\n    r\"\"\"Langermann function.\n\n    The Langermann function is a multi-dimensional function with many unevenly\n    distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Langermann function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}\n            (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi\n            \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right)\n        $$\n\n        with the constants :math:`c_i` and the :math:`a_{ij}` given by:\n\n        $$\n            c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =\n            \\left\\{ 3, 5, 2, 1, 7 \\right\\}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/langer.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        A (UniversalArray, optional): Matrix of constants :math:`a_{ij}`. The numbers\n            of rows has to be equal to the number of input data, respectively,\n            dimensions. Defaults to :math:`a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}`.\n        c (UniversalArray, optional): Vector of constants :math:`c_i`. Defaults to\n            :math:`c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}`.\n        m (int, optional): Number of local minima. Defaults to 5.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        A: UniversalArray = None,\n        c: UniversalArray = None,\n        m: int = 5,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n        if A is None:\n            A = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\n\n        if c is None:\n            c = np.array([1, 2, 5, 2, 3], dtype=float)\n\n        if len(x) != A.shape[0]:\n            msg = \"Dimension of x must match number of rows in A.\"\n            raise ValueError(msg)\n\n        if len(A.shape) != __2d__:\n            msg = (\n                \"A must be two dimensional array. In case of one input the  \"\n                \"array must lool like 'np.array([[...]])'. \"\n            )\n            raise ValueError(\n                msg,\n            )\n        if A.shape[1] != m:\n            raise MatchLengthError(_object=\"A\", _target=\"m\")\n\n        if len(c) != m:\n            raise MatchLengthError(_object=\"C\", _target=\"m\")\n\n        if len(c.shape) != __1d__:\n            msg = \"c must be one dimensional array.\"\n            raise ValueError(msg)\n\n        self.a_matrix = A\n        self._c = c\n        self._m = m\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Langermann function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        outer_sum = np.zeros_like(self._x[0])\n        for i in range(self._m):\n            inner_sum = np.zeros_like(self._x[0])\n            for j, _x in enumerate(self._x):\n                inner_sum += (_x - self.a_matrix[j, i]) ** 2\n            outer_sum += (\n                self._c[i] * np.exp(-inner_sum / np.pi) * np.cos(np.pi * inner_sum)\n            )\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(\n                np.array([self.a_matrix[0, i], self.a_matrix[1, i]])\n                for i in range(self._m)\n            ),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Langermann function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__init__","title":"<code>__init__(*x, A=None, c=None, m=5)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    A: UniversalArray = None,\n    c: UniversalArray = None,\n    m: int = 5,\n) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n\n    if A is None:\n        A = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\n\n    if c is None:\n        c = np.array([1, 2, 5, 2, 3], dtype=float)\n\n    if len(x) != A.shape[0]:\n        msg = \"Dimension of x must match number of rows in A.\"\n        raise ValueError(msg)\n\n    if len(A.shape) != __2d__:\n        msg = (\n            \"A must be two dimensional array. In case of one input the  \"\n            \"array must lool like 'np.array([[...]])'. \"\n        )\n        raise ValueError(\n            msg,\n        )\n    if A.shape[1] != m:\n        raise MatchLengthError(_object=\"A\", _target=\"m\")\n\n    if len(c) != m:\n        raise MatchLengthError(_object=\"C\", _target=\"m\")\n\n    if len(c.shape) != __1d__:\n        msg = \"c must be one dimensional array.\"\n        raise ValueError(msg)\n\n    self.a_matrix = A\n    self._c = c\n    self._m = m\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction","title":"<code>LevyFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Levy function.</p> <p>The Levy function is a multi-dimensional function with many local and harmonic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy function is defined as:</p> \\[     f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[     1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]     + \\left( w_d - 1 \\right)^2 \\left[     1 + \\sin^2( 2 \\pi w_d ) \\right] \\] <p>with the :math:<code>w_i</code> given by:</p> \\[     w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in     \\left\\{ 1, \\dots, d \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyFunction(OptFunction):\n    r\"\"\"Levy function.\n\n    The Levy function is a multi-dimensional function with many local and harmonic\n    distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Levy function is defined as:\n\n        $$\n            f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[\n            1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]\n            + \\left( w_d - 1 \\right)^2 \\left[\n            1 + \\sin^2( 2 \\pi w_d ) \\right]\n        $$\n\n        with the :math:`w_i` given by:\n\n        $$\n            w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in\n            \\left\\{ 1, \\dots, d \\right\\}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Levy function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n\n        term_1 = np.sin(np.pi * (1 + (1 / 4) * (self._x[0] - 1))) ** 2\n\n        if len(self._x) == 1:\n            return term_1\n\n        for i in range(1, len(self._x) - 1):\n            term_2 = (1 + (1 / 4) * (self._x[i] - 1)) ** 2\n            term_3 = 1 + 10 * np.sin(np.pi * (1 + (1 / 4) * (self._x[i] - 1)) + 1) ** 2\n            sum_ += term_2 * term_3\n\n        term_4 = (1 + (1 / 4) * (self._x[-1] - 1)) ** 2\n        term_5 = (1 + np.sin(2 * np.pi * (1 + (1 / 4) * (self._x[-1] - 1)))) ** 2\n        sum_ += term_4 * term_5\n        return term_1 + sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([1.0]) for _ in range(len(self._x))),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Levy function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function","title":"<code>LevyN13Function</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Levy N. 13 function.</p> <p>The Levy N. 13 function is a two-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy N. 13 function is defined as:</p> \\[     f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1     + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1     + \\sin^2( 2 \\pi x_2 ) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyN13Function(OptFunction):\n    r\"\"\"Levy N. 13 function.\n\n    The Levy N. 13 function is a two-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Levy N. 13 function is defined as:\n\n        $$\n            f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 2 \\pi x_2 ) \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy13.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Levy N. 13\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Levy N. 13 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(3 * np.pi * x_1) ** 2\n        term_2 = (x_1 - 1) ** 2\n        term_3 = 1 + np.sin(3 * np.pi * x_2) ** 2\n        term_4 = (x_2 - 1) ** 2\n        term_5 = 1 + np.sin(2 * np.pi * x_2) ** 2\n        return term_1 + term_2 * term_3 + term_4 * term_5\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(1.0, 1.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Levy N. 13 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Levy N. 13\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction","title":"<code>RastriginFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Rastrigin function.</p> <p>The Rastrigin function is a multi-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n&gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rastrigin function is defined as:</p> \\[     f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class RastriginFunction(OptFunction):\n    r\"\"\"Rastrigin function.\n\n    The Rastrigin function is a multi-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n        &gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rastrigin function is defined as:\n\n        $$\n            f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rastr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rastrigin function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n        for x_i in self._x:\n            sum_ += x_i**2 - 10 * np.cos(2 * np.pi * x_i)\n        return 10 * len(self._x) + sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([0.0]) for _ in range(len(self._x))),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Rastrigin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function","title":"<code>SchafferN2Function</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Schaffer N. 2 function.</p> <p>The Schaffer N. 2 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 2 function is defined as:</p> \\[     f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|     \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN2Function(OptFunction):\n    r\"\"\"Schaffer N. 2 function.\n\n    The Schaffer N. 2 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schaffer N. 2 function is defined as:\n\n        $$\n            f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|\n            \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer2.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Schaffer N. 2\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schaffer N. 2 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            0.5\n            + (np.sin(np.abs(x_1**2 + x_2**2)) ** 2 - 0.5)\n            / (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Schaffer N. 2 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Schaffer N. 2\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function","title":"<code>SchafferN4Function</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Schaffer N. 4 function.</p> <p>The Schaffer N. 4 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 4 function is defined as:</p> \\[     f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }     { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN4Function(OptFunction):\n    r\"\"\"Schaffer N. 4 function.\n\n    The Schaffer N. 4 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schaffer N. 4 function is defined as:\n\n        $$\n            f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }\n            { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer4.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Schaffer N. 4\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schaffer N. 4 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            0.5\n            + (np.sin(np.sqrt(x_1**2 + x_2**2)) ** 2 - 0.5)\n            / (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Schaffer N. 4 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Schaffer N. 4\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction","title":"<code>SchwefelFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Schwefel function.</p> <p>The Schwefel function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schwefel function is defined as:</p> \\[     f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin     \\left( \\sqrt{ \\left| x_i \\right| } \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchwefelFunction(OptFunction):\n    r\"\"\"Schwefel function.\n\n    The Schwefel function is a multi-dimensional function with a\n    single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schwefel function is defined as:\n\n        $$\n            f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin\n            \\left( \\sqrt{ \\left| x_i \\right| } \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schwef.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schwefel function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        return 418.9829 * len(self._x) - np.sum(\n            self._x * np.sin(np.sqrt(np.abs(self._x))),\n            axis=0,\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(420.968746, 420.968746),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Schwefel function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction","title":"<code>ShubertFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Shubert function.</p> <p>The Shubert function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Shubert function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +     \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class ShubertFunction(OptFunction):\n    r\"\"\"Shubert function.\n\n    The Shubert function is a two-dimensional function with a\n    single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Shubert function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +\n            \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/shubert.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Shubert\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Shubert function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return np.sum(\n            np.array(\n                [\n                    i * np.cos((i + 1) * x_1 + i) + i * np.cos((i + 1) * x_2 + i)\n                    for i in range(1, 6)\n                ],\n            ),\n            axis=0,\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(f_x=-186.7309, x=(-7.708309818, -0.800371886))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Shubert function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Shubert\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction","title":"<code>BoothFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Booth Function.</p> <p>The Booth function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Booth function is defined as:</p> \\[     f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class BoothFunction(OptFunction):\n    r\"\"\"Booth Function.\n\n    The Booth function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Booth function is defined as:\n\n        $$\n            f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/booth.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            msg = f\"Expected 2 arguments, but got {len(x)}.\"\n            raise ValueError(msg)\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Booth function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (x_1 + 2 * x_2 - 7) ** 2 + (2 * x_1 + x_2 - 5) ** 2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Booth function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(1.0, 3.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Booth function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Booth function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        msg = f\"Expected 2 arguments, but got {len(x)}.\"\n        raise ValueError(msg)\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction","title":"<code>MatyasFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Matyas Function.</p> <p>The Matyas function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Matyas function is defined as:</p> \\[     f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class MatyasFunction(OptFunction):\n    r\"\"\"Matyas Function.\n\n    The Matyas function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Matyas function is defined as:\n\n        $$\n            f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/matya.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Matyas\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Matyas function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 0.26 * (x_1**2 + x_2**2) - 0.48 * x_1 * x_2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Matyas function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Matyas function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Matyas function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Matyas\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction","title":"<code>McCormickFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>McCormick Function.</p> <p>The McCormick function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n&gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The McCormick function is defined as:</p> \\[     f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class McCormickFunction(OptFunction):\n    r\"\"\"McCormick Function.\n\n    The McCormick function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n        &gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The McCormick function is defined as:\n\n        $$\n            f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/mccorm.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the McCormick function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return np.sin(x_1 + x_2) + (x_1 - x_2) ** 2 - 1.5 * x_1 + 2.5 * x_2 + 1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the McCormick function.\"\"\"\n        return MinimaAPI(\n            f_x=-1.9133,\n            x=(-0.54719, -1.54719),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the McCormick function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the McCormick function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction","title":"<code>PowerSumFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Power Sum Function.</p> <p>The Power Sum function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Power Sum function is defined as:</p> \\[     f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class PowerSumFunction(OptFunction):\n    r\"\"\"Power Sum Function.\n\n    The Power Sum function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Power Sum function is defined as:\n\n        $$\n            f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/powersum.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Power Sum\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Evaluate the Power Sum function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return x_1**2 + x_2**2 + x_1**4 + x_2**4\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Power Sum function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Power Sum function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Power Sum function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Power Sum\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction","title":"<code>ZakharovFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Zakharov Function.</p> <p>The Zakharov function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zakharov function is defined as:</p> \\[     f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2     + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZakharovFunction(OptFunction):\n    r\"\"\"Zakharov Function.\n\n    The Zakharov function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zakharov function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2\n            + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zakharov.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Evaluate the Zakharov function at x.\"\"\"\n        sum_1 = np.zeros_like(self._x[0])\n        sum_2 = np.zeros_like(self._x[0])\n\n        for i in range(self.dimension):\n            sum_1 += self._x[i] ** 2\n            sum_2 += 0.5 * (i + 1) * self._x[i]\n\n        return sum_1 + sum_2**2 + sum_2**4\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zakharov function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.zeros_like(self.dimension)),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the Zakharov function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Zakharov function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction","title":"<code>ZettlFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Zettl function.</p> <p>The Zettl function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zettl function is defined as:</p> \\[     f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZettlFunction(OptFunction):\n    r\"\"\"Zettl function.\n\n    The Zettl function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zettl function is defined as:\n\n        $$\n            f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zettl.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            msg = f\"Expected 2 arguments, but got {len(x)}.\"\n            raise ValueError(msg)\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Zettl function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return (\n            self._x[0] ** 2 + self._x[1] ** 2 - 2 * self._x[0]\n        ) ** 2 + 0.25 * self._x[0]\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zettl function.\n\n        Returns:\n            MinimaAPI: Minima of the Zettl function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Zettl function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Zettl function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Zettl function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        msg = f\"Expected 2 arguments, but got {len(x)}.\"\n        raise ValueError(msg)\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction","title":"<code>BealeFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Beale function.</p> <p>The Beale function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n&gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Beale function is defined as:</p> \\[     f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BealeFunction(OptFunction):\n    r\"\"\"Beale function.\n\n    The Beale function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n        &gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Beale function is defined as:\n\n        $$\n            f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/beale.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Beale\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Beale function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        return (\n            (1.5 - x + x * y) ** 2\n            + (2.25 - x + x * y**2) ** 2\n            + (2.625 - x + x * y**3) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Beale function.\n\n        Returns:\n            MinimaAPI: Minima of the Beale function.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=(0.5))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Beale function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Beale function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Beale function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Beale\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction","title":"<code>BraninFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Branin function.</p> <p>The Branin function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(0, 15, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Branin function is defined as:</p> \\[     f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s \\] <p>where</p> \\[     a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BraninFunction(OptFunction):\n    r\"\"\"Branin function.\n\n    The Branin function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(0, 15, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Branin function is defined as:\n\n        $$\n            f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s\n        $$\n\n        where\n\n        $$\n            a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/branin.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Branin\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Branin function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        a = 1\n        b = 5.1 / (4 * np.pi**2)\n        c = 5 / np.pi\n        r = 6\n        s = 10\n        t = 1 / (8 * np.pi)\n        return a * (y - b * x**2 + c * x - r) ** 2 + s * (1 - t) * np.cos(y) + s\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Branin function.\n\n        Returns:\n            MinimaAPI: Minima of the Branin function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.397887,\n            x=tuple(\n                np.array([-np.pi, 12.275]),\n                np.array([np.pi, 2.275]),\n                np.array([np.pi, 9.42478]),\n                np.array([9.42478, 2.475]),\n            ),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Branin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Branin function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Branin function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Branin\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction","title":"<code>GoldsteinPriceFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Goldstein-Price function.</p> <p>The Goldstein-Price function is a two-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function is defined as:</p> \\[     f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2     \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)     \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2     \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right) \\] <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceFunction(OptFunction):\n    r\"\"\"Goldstein-Price function.\n\n    The Goldstein-Price function is a two-dimensional function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Goldstein-Price function is defined as:\n\n        $$\n            f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2\n            \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)\n            \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2\n            \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right)\n        $$\n\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Goldstein-Price\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Goldstein-Price function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return (\n            1\n            + (self._x[0] + self._x[1] + 1) ** 2\n            * (\n                19\n                - 14 * self._x[0]\n                + 3 * self._x[0] ** 2\n                - 14 * self._x[1]\n                + 6 * self._x[0] * self._x[1]\n                + 3 * self._x[1] ** 2\n            )\n        ) * (\n            30\n            + (2 * self._x[0] - 3 * self._x[1]) ** 2\n            * (\n                18\n                - 32 * self._x[0]\n                + 12 * self._x[0] ** 2\n                + 48 * self._x[1]\n                - 36 * self._x[0] * self._x[1]\n                + 27 * self._x[1] ** 2\n            )\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Goldstein-Price function.\n\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Goldstein-Price function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Goldstein-Price function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Goldstein-Price function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Goldstein-Price\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction","title":"<code>GoldsteinPriceLogFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Goldstein-Price function in logarithmic form.</p> <p>The Goldstein-Price function in logarithmic form is a two-dimensional function. In this form, the function offers a better conditioning by using the logarithm.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function in logarithmic form is defined as:</p> <p>$$     f(x, y) = frac{1}{2.427} left[     log left( 1 + left( bar{x}_1 + bar{x}_2 + 1 right)^2     left( 19 - 14 x + 3 bar{x}_1^2 - 14 bar{x}_2 + 6 bar{x}_1 bar{x}_2     + 3 bar{x}_2^2 right) right) + log left( 30 + left( 2 bar{x}_1 - 3     bar{x}_2 right)^2 left( 18 - 32 bar{x}_1 + 12 bar{x}_1^2 + 48     bar{x}_2 - 36 bar{x}_1 bar{x}_2 + 27 y^2 right) right) - 8.683 right]</p> Scdoc<pre><code>\\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n</code></pre> <p>$$</p> <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceLogFunction(OptFunction):\n    r\"\"\"Goldstein-Price function in logarithmic form.\n\n    The Goldstein-Price function in logarithmic form is a two-dimensional function.\n    In this form, the function offers a better conditioning by using the logarithm.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Goldstein-Price function in logarithmic form is defined as:\n\n        $$\n            f(x, y) = \\frac{1}{2.427} \\left[\n            \\log \\left( 1 + \\left( \\bar{x}_1 + \\bar{x}_2 + 1 \\right)^2\n            \\left( 19 - 14 x + 3 \\bar{x}_1^2 - 14 \\bar{x}_2 + 6 \\bar{x}_1 \\bar{x}_2\n            + 3 \\bar{x}_2^2 \\right) \\right) + \\log \\left( 30 + \\left( 2 \\bar{x}_1 - 3\n            \\bar{x}_2 \\right)^2 \\left( 18 - 32 \\bar{x}_1 + 12 \\bar{x}_1^2 + 48\n            \\bar{x}_2 - 36 \\bar{x}_1 \\bar{x}_2 + 27 y^2 \\right) \\right) - 8.683 \\right]\n\n            \\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n        $$\n\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Goldstein-Price\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Goldstein-Price function in logarithmic form at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = 4 * self._x[0] - 2\n        x_2 = 4 * self._x[1] - 2\n        return (\n            1\n            / 2.427\n            * (\n                np.log(\n                    1\n                    + (x_1 + x_2 + 1) ** 2\n                    * (\n                        19\n                        - 14 * x_1\n                        + 3 * x_1**2\n                        - 14 * x_2\n                        + 6 * x_1 * x_2\n                        + 3 * x_2**2\n                    ),\n                )\n                + np.log(\n                    30\n                    + (2 * x_1 - 3 * x_2) ** 2\n                    * (\n                        18\n                        - 32 * x_1\n                        + 12 * x_1**2\n                        + 48 * x_2\n                        - 36 * x_1 * x_2\n                        + 27 * x_2**2\n                    ),\n                )\n                - 8.683\n            )\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Goldstein-Price function in logarithmic form.\n\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function in logarithmic form.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Goldstein-Price function in logarithmic form at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Goldstein-Price function in logarithmic form.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Goldstein-Price function in logarithmic form.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Goldstein-Price\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.HimmelblauFunction","title":"<code>HimmelblauFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Himmelblau function.</p> <p>The Himmelblau function is a two-dimensional function with four global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import HimmelblauFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HimmelblauFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HimmelblauFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Himmelblau function is defined as:</p> \\[     f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class HimmelblauFunction(OptFunction):\n    r\"\"\"Himmelblau function.\n\n    The Himmelblau function is a two-dimensional function with four global minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import HimmelblauFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HimmelblauFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HimmelblauFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Himmelblau function is defined as:\n\n        $$\n            f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/himmel.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Himmelblau\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Himmelblau function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Himmelblau function.\n\n        Returns:\n            MinimaAPI: Minima of the Himmelblau function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(\n                np.array([3.0, 2.0]),\n                np.array([-2.805118, 3.131312]),\n                np.array([-3.779310, -3.283186]),\n                np.array([3.584428, -1.848126]),\n            ),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.HimmelblauFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Himmelblau function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.HimmelblauFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Himmelblau function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Himmelblau function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.HimmelblauFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"Himmelblau\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction","title":"<code>StyblinskiTangFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Styblinski-Tang function.</p> <p>The Styblinski-Tang function is a D-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Styblinski-Tang function is defined as:</p> \\[     f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right) \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-5, 5]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class StyblinskiTangFunction(OptFunction):\n    r\"\"\"Styblinski-Tang function.\n\n    The Styblinski-Tang function is a D-dimensional function.\n\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Styblinski-Tang function is defined as:\n\n        $$\n            f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right)\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-5, 5]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/stybtang.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Styblinski-Tang function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return np.array(\n            0.5\n            * sum(\n                (self._x[i - 1] ** 4 - 16 * self._x[i - 1] ** 2 + 5 * self._x[i - 1])\n                for i in range(1, self.dimension + 1)\n            ),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Styblinski-Tang function.\n\n        Returns:\n            MinimaAPI: Minima of the Styblinski-Tang function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-39.16616570377142,\n            x=tuple(np.ones(self.dimension) * -2.903534),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Styblinski-Tang function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the Styblinski-Tang function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Styblinski-Tang function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction","title":"<code>DixonPriceFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Dixon-Price function.</p> <p>The Dixon-Price function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Dixon-Price function is defined as:</p> \\[ f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class DixonPriceFunction(OptFunction):\n    r\"\"\"Dixon-Price function.\n\n    The Dixon-Price function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Dixon-Price function is defined as:\n\n        $$\n        f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/dixonpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the Dixon-Price function.\"\"\"\n        if len(x) &lt; __2d__:\n            raise TooSmallDimensionError(\n                function_name=\"DixonPrice\",\n                dimension=__2d__,\n                len_x=len(x),\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Dixon-Price function at x.\"\"\"\n        x = self._x\n\n        return (x[0] - 1) ** 2 + sum(\n            (i + 1) * (x[i] - x[i - 1] ** 2) ** 2 for i in range(1, len(x))\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the zero function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([2 ** (-i) for i in range(1, len(self._x) + 1)])),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Dixon-Price function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the Dixon-Price function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the Dixon-Price function.\"\"\"\n    if len(x) &lt; __2d__:\n        raise TooSmallDimensionError(\n            function_name=\"DixonPrice\",\n            dimension=__2d__,\n            len_x=len(x),\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction","title":"<code>RosenbrockFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Rosenbrock function.</p> <p>The Rosenbrock function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rosenbrock function is defined as:</p> \\[ f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class RosenbrockFunction(OptFunction):\n    r\"\"\"Rosenbrock function.\n\n    The Rosenbrock function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rosenbrock function is defined as:\n\n        $$\n        f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rosen.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the Rosenbrock function.\"\"\"\n        if len(x) &lt; __2d__:\n            raise TooSmallDimensionError(\n                function_name=\"Rosenbrock\",\n                dimension=__2d__,\n                len_x=len(x),\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rosenbrock function at x.\"\"\"\n        x = self._x\n\n        return np.array(\n            sum(\n                100 * (x[i + 1] - x[i] ** 2) ** 2 + (1 - x[i]) ** 2\n                for i in range(len(x) - 1)\n            ),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the zero function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([1.0 for _ in range(len(self._x))])),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate Rosenbrock function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the Rosenbrock function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the Rosenbrock function.\"\"\"\n    if len(x) &lt; __2d__:\n        raise TooSmallDimensionError(\n            function_name=\"Rosenbrock\",\n            dimension=__2d__,\n            len_x=len(x),\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction","title":"<code>SixHumpCamelFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Six-hump camel function.</p> <p>The six-hump camel function is a two-dimensional function with six minima, where two of them are global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The six-hump camel function is defined as:</p> \\[ f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class SixHumpCamelFunction(OptFunction):\n    r\"\"\"Six-hump camel function.\n\n    The six-hump camel function is a two-dimensional function with six\n    minima, where two of them are global minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The six-hump camel function is defined as:\n\n        $$\n        f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel6.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the six-hump camel function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"SixHumpCamel\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the six-hump camel function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            (4 - 2.1 * x_1**2 + (x_1**4) / 3) * x_1**2\n            + x_1 * x_2\n            + (-4 + 4 * x_2**2) * x_2**2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the six-hump camel function.\"\"\"\n        return MinimaAPI(\n            f_x=-1.031628453489877,\n            x=tuple(np.array([0.0898, -0.7126], [-0.0898, 0.7126])),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the six-hump camel function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the six-hump camel function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the six-hump camel function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the six-hump camel function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"SixHumpCamel\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction","title":"<code>ThreeHumpCamelFunction</code>","text":"<p>               Bases: <code>OptFunction</code></p> <p>Three-hump camel function.</p> <p>The three-hump camel function is a two-dimensional function with three minima, where one of the minima is a global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The three-hump camel function is defined as:</p> \\[ f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class ThreeHumpCamelFunction(OptFunction):\n    r\"\"\"Three-hump camel function.\n\n    The three-hump camel function is a two-dimensional function with three\n    minima, where one of the minima is a global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The three-hump camel function is defined as:\n\n        $$\n        f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel3.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the three-hump camel function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"ThreeHumpCamel\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the three-hump camel function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 2 * x_1**2 - 1.05 * x_1**4 + (x_1**6) / 6 + x_1 * x_2 + x_2**2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the three-hump camel function.\"\"\"\n        return MinimaAPI(\n            f_x=np.array([0.0, 0.0]),\n            x=tuple(np.array([0.0])),\n        )\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Evaluate the three-hump camel function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__minima__","title":"<code>__minima__</code>  <code>property</code>","text":"<p>Return the minima of the three-hump camel function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the three-hump camel function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n    \"\"\"Initialize the three-hump camel function.\"\"\"\n    if len(x) != __2d__:\n        raise OutOfDimensionError(\n            function_name=\"ThreeHumpCamel\",\n            dimension=__2d__,\n        )\n    super().__init__(*x)\n</code></pre>"},{"location":"modules/api/plots/","title":"Modules","text":"<p>Plotting functions for 2D and 3D functions.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot","title":"<code>ClassicPlot</code>","text":"<p>               Bases: <code>Plot</code></p> <p>Plotting functions using via matplotlib.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n&gt;&gt;&gt; plot.plot_dashboard()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.meta.plots import GIFSettings\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; # Start with a simple plot\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     X,\n...     Y,\n...     Z,\n...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n... )\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; # Now only zoom\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n...     settings=GIFSettings(rotate=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n...     settings=GIFSettings(zoom=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only zoom and rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n...     settings=GIFSettings(),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>class ClassicPlot(Plot):\n    r\"\"\"Plotting functions using via matplotlib.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = X ** 2 + Y ** 2\n        &gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n        &gt;&gt;&gt; plot.plot_3d()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n        &gt;&gt;&gt; plot.plot_contour()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n        &gt;&gt;&gt; plot.plot_dashboard()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n        &gt;&gt;&gt; plot.plot_close()\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.meta.plots import GIFSettings\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; # Start with a simple plot\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; plot = ClassicPlot(\n        ...     X,\n        ...     Y,\n        ...     Z,\n        ...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n        ... )\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; # Now only zoom\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n        ...     settings=GIFSettings(rotate=False),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; # Now only rotate\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n        ...     settings=GIFSettings(zoom=False),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; # Now only zoom and rotate\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n        ...     settings=GIFSettings(),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; plot.plot_close()\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ...    RayleighDistribution,\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; plot = ClassicPlot(\n        ...     np.array([x, y_sigma_1]),\n        ...     np.array([x, y_sigma_2]),\n        ...     np.array([x, y_sigma_3]),\n        ...     settings=GraphSettings(\n        ...         axis=[\"x\", r\"$f(x)$\"],\n        ...         title=\"Rayleigh Distribution\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        settings (GraphSettings, optional): Settings for the graph. Defaults to None.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the plot\n             function.\n    \"\"\"\n\n    fig: plt.Figure\n    ax: plt.figure\n\n    def plot_2d(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n        \"\"\"Plot a 2D function.\n\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n        \"\"\"\n        if ax is None:\n            self.fig = plt.figure(figsize=self.size)\n            self.ax = self.fig.add_subplot(111)\n        self.ax.plot(*self._x, color=self.color, **self._kwargs)\n        self.label_settings()\n\n    def plot_series(\n        self,\n        ax: FigureTypeMatplotlib | None = None,\n        label: list[str | None] | None = None,\n    ) -&gt; None:\n        \"\"\"Plot a 2D function as a series.\n\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n            label (list[str | None], optional): The label of each line. Defaults to\n                     None.\n        \"\"\"\n        if ax is None:\n            self.fig = plt.figure(figsize=self.size)\n            self.ax = self.fig.add_subplot(111)\n        if label is None:\n            label = [None for _ in self._x]\n        for i, _x in enumerate(self._x):\n            self.ax.plot(*_x, label=label[i], **self._kwargs)\n        self.label_settings(legend=True)\n\n    def plot_3d(self, ax: plt.Figure | None = None) -&gt; None:\n        \"\"\"Plot a 3D function.\n\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n        \"\"\"\n        if ax is None:\n            self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n            self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.plot_wireframe(\n            *self._x,\n            edgecolor=plt.colormaps.get_cmap(self.color).colors,\n            alpha=self.alpha,\n            **self._kwargs,\n        )\n        self.label_settings(dim3=True)\n\n    def plot_contour(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n        \"\"\"Plot a contour plot.\"\"\"\n        if ax is None:\n            self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n            self.ax = self.fig.add_subplot(111)\n        self.ax.contour(\n            *self._x,\n            cmap=plt.colormaps.get_cmap(self.cmap),\n            alpha=self.alpha,\n            **self._kwargs,\n        )\n        self.label_settings()\n\n    def plot_surface(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n        \"\"\"Plot a 3D function.\"\"\"\n        if ax is None:\n            self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n            self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.plot_surface(\n            *self._x,\n            cmap=plt.colormaps.get_cmap(self.cmap),\n            alpha=self.alpha,\n            **self._kwargs,\n        )\n        self.label_settings(dim3=True)\n\n    def label_settings(self, *, dim3: bool = False, legend: bool = False) -&gt; None:\n        \"\"\"Set the labels for a 2D or 3D plot.\n\n        Args:\n            ax (plt.Figure): Figure objects to set the labels and title.\n            dim3 (bool, optional): Whether the plot is 3D. Defaults to False.\n            legend (bool, optional): Whether to show the legend. Defaults to False.\n        \"\"\"\n        self.ax.set_xlabel(self.axis[0])\n        self.ax.set_ylabel(self.axis[1])\n        if dim3:\n            self.ax.set_zlabel(self.axis[2])\n        self.ax.set_title(self.title)\n        if legend is not None:\n            self.ax.legend()\n\n    def plot_dashboard(self) -&gt; None:\n        \"\"\"Plot a dashboard.\"\"\"\n        from matplotlib import gridspec\n\n        self.fig = plt.figure(tight_layout=True, figsize=self.size, dpi=self.dpi)\n        gs = gridspec.GridSpec(2, 2)\n\n        self.plot_contour(self.fig.add_subplot(gs[0, :]))\n        self.plot_3d(self.fig.add_subplot(gs[1, 0], projection=\"3d\"))\n        self.plot_surface(self.fig.add_subplot(gs[1, 1], projection=\"3d\"))\n        self.fig.align_labels()\n\n    def plot_show(self) -&gt; None:\n        \"\"\"Show the plot.\"\"\"\n        plt.show()\n\n    @property\n    def plot_return(self) -&gt; FigureTypeMatplotlib:\n        \"\"\"Return the plot.\"\"\"\n        return self.fig\n\n    @property\n    def ax_return(self) -&gt; FigureTypeMatplotlib:\n        \"\"\"Return the Figure.\"\"\"\n        return self.ax\n\n    @staticmethod\n    def plot_save(\n        fig: FigureTypeMatplotlib,\n        fname: Path,\n        fformat: str = \"png\",\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save the plot.\n\n        Args:\n            fig (plt.figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                 save function.\n        \"\"\"\n        fig.savefig(fname.with_suffix(f\".{fformat}\"), **kwargs)\n\n    @staticmethod\n    def plot_save_gif(\n        *,\n        fig: FigureTypeMatplotlib,\n        ax_fig: SubFigureTypeMatplotlib,\n        fname: Path,\n        settings: GIFSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Saves the given plot to a file.\n\n        Note:\n            For generating GIFs, the a subfunction is used to update the plot for each\n            frame of the animation. This subfunction is defined in the function\n            `update`.\n\n        Args:\n            fig (plt.figure): The figure to save.\n            ax_fig (plt.Figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            settings (GIFSettings): The settings for the GIF.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                    save function.\n        \"\"\"\n\n        def update(frame: int, settings: GIFSettings) -&gt; list[SubFigureTypeMatplotlib]:\n            \"\"\"Updates the plot for each frame of the animation.\n\n            Args:\n                fig (plt.figure): The figure to update.\n                ax_fig (plt.Figure): The figure to update.\n                frame (int): The current frame number.\n                settings (GIFSettings): The settings for the GIF.\n                **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                    save function.\n\n            Returns:\n                list[SubFigureTypeMatplotlib]: A list of the updated plot elements.\n            \"\"\"\n            surf: SubFigureTypeMatplotlib = ax_fig\n            if settings.zoom:\n                ax_fig.set_box_aspect(\n                    None,\n                    zoom=np.linspace(\n                        settings.zoom_start,\n                        settings.zoom_stop,\n                        settings.frames,\n                    )[frame],\n                )\n            if settings.rotate:\n                ax_fig.view_init(\n                    elev=settings.elev,\n                    azim=frame * settings.azim % 360,\n                )\n            return [surf]\n\n        anim = FuncAnimation(\n            fig=fig,\n            func=update,\n            frames=settings.frames,\n            interval=settings.interval,\n            fargs=(settings,),\n        )\n        anim.save(filename=fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n\n    @staticmethod\n    def plot_save_animation(\n        *,\n        fig: FigureTypeMatplotlib,\n        ax_fig: SubFigureTypeMatplotlib,\n        fname: Path,\n        settings: AnimationSettings,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Create and save an animation of a 2D plot with scatter and line elements.\n\n        This function generates an animation by progressively revealing data points\n        in both a scatter plot and a line plot, then saves it as an animated file.\n\n        Args:\n            fig (FigureTypeMatplotlib): The matplotlib figure object containing the plot\n            ax_fig (SubFigureTypeMatplotlib): The axis object containing the plots to\n                animate\n            fname (Path): Path object specifying where to save the animation file\n            settings (AnimationSettings): Settings object containing animation\n                parameters like frames, interval, and dpi\n            **kwargs: Additional keyword arguments passed to animation.save()\n        \"\"\"\n        x_axis_data = ax_fig.lines[0].get_xdata()\n        y_axis_data = ax_fig.lines[0].get_ydata()\n\n        scat = ax_fig.collections[\n            0\n        ]  # Assuming the scatter plot is the first collection\n\n        line2: plt.Line2D = ax_fig.lines[\n            1\n        ]  # Assuming the line plot to update is the second line\n\n        def update(frame: int, settings: GIFSettings) -&gt; list[plt.Artist]:  # noqa: ARG001\n            # for each frame, update the data stored on each artist.\n            x = x_axis_data[:frame]\n            y = y_axis_data[:frame]\n            # update the scatter plot:\n            data = np.stack([x, y]).T\n            scat.set_offsets(data)\n            # update the line plot:\n            line2.set_xdata(x_axis_data[:frame])\n            line2.set_ydata(y_axis_data[:frame])\n            return [scat, line2]\n\n        anim = FuncAnimation(\n            fig=fig,\n            func=update,\n            frames=settings.frames,\n            interval=settings.interval,\n            fargs=(settings,),\n        )\n        anim.save(filename=fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n\n    @staticmethod\n    def plot_close() -&gt; None:\n        \"\"\"Close all plots.\"\"\"\n        plt.close(\"all\")\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.ax_return","title":"<code>ax_return</code>  <code>property</code>","text":"<p>Return the Figure.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_return","title":"<code>plot_return</code>  <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.label_settings","title":"<code>label_settings(*, dim3=False, legend=False)</code>","text":"<p>Set the labels for a 2D or 3D plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure objects to set the labels and title.</p> required <code>dim3</code> <code>bool</code> <p>Whether the plot is 3D. Defaults to False.</p> <code>False</code> <code>legend</code> <code>bool</code> <p>Whether to show the legend. Defaults to False.</p> <code>False</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def label_settings(self, *, dim3: bool = False, legend: bool = False) -&gt; None:\n    \"\"\"Set the labels for a 2D or 3D plot.\n\n    Args:\n        ax (plt.Figure): Figure objects to set the labels and title.\n        dim3 (bool, optional): Whether the plot is 3D. Defaults to False.\n        legend (bool, optional): Whether to show the legend. Defaults to False.\n    \"\"\"\n    self.ax.set_xlabel(self.axis[0])\n    self.ax.set_ylabel(self.axis[1])\n    if dim3:\n        self.ax.set_zlabel(self.axis[2])\n    self.ax.set_title(self.title)\n    if legend is not None:\n        self.ax.legend()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_2d","title":"<code>plot_2d(ax=None)</code>","text":"<p>Plot a 2D function.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_2d(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n    \"\"\"Plot a 2D function.\n\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n    \"\"\"\n    if ax is None:\n        self.fig = plt.figure(figsize=self.size)\n        self.ax = self.fig.add_subplot(111)\n    self.ax.plot(*self._x, color=self.color, **self._kwargs)\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_3d","title":"<code>plot_3d(ax=None)</code>","text":"<p>Plot a 3D function.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_3d(self, ax: plt.Figure | None = None) -&gt; None:\n    \"\"\"Plot a 3D function.\n\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n    \"\"\"\n    if ax is None:\n        self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n    self.ax.plot_wireframe(\n        *self._x,\n        edgecolor=plt.colormaps.get_cmap(self.color).colors,\n        alpha=self.alpha,\n        **self._kwargs,\n    )\n    self.label_settings(dim3=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_close","title":"<code>plot_close()</code>  <code>staticmethod</code>","text":"<p>Close all plots.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_close() -&gt; None:\n    \"\"\"Close all plots.\"\"\"\n    plt.close(\"all\")\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_contour","title":"<code>plot_contour(ax=None)</code>","text":"<p>Plot a contour plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_contour(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n    \"\"\"Plot a contour plot.\"\"\"\n    if ax is None:\n        self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n        self.ax = self.fig.add_subplot(111)\n    self.ax.contour(\n        *self._x,\n        cmap=plt.colormaps.get_cmap(self.cmap),\n        alpha=self.alpha,\n        **self._kwargs,\n    )\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_dashboard","title":"<code>plot_dashboard()</code>","text":"<p>Plot a dashboard.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_dashboard(self) -&gt; None:\n    \"\"\"Plot a dashboard.\"\"\"\n    from matplotlib import gridspec\n\n    self.fig = plt.figure(tight_layout=True, figsize=self.size, dpi=self.dpi)\n    gs = gridspec.GridSpec(2, 2)\n\n    self.plot_contour(self.fig.add_subplot(gs[0, :]))\n    self.plot_3d(self.fig.add_subplot(gs[1, 0], projection=\"3d\"))\n    self.plot_surface(self.fig.add_subplot(gs[1, 1], projection=\"3d\"))\n    self.fig.align_labels()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save the plot.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the  save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save(\n    fig: FigureTypeMatplotlib,\n    fname: Path,\n    fformat: str = \"png\",\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save the plot.\n\n    Args:\n        fig (plt.figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n             save function.\n    \"\"\"\n    fig.savefig(fname.with_suffix(f\".{fformat}\"), **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_save_animation","title":"<code>plot_save_animation(*, fig, ax_fig, fname, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create and save an animation of a 2D plot with scatter and line elements.</p> <p>This function generates an animation by progressively revealing data points in both a scatter plot and a line plot, then saves it as an animated file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The matplotlib figure object containing the plot</p> required <code>ax_fig</code> <code>SubFigure</code> <p>The axis object containing the plots to animate</p> required <code>fname</code> <code>Path</code> <p>Path object specifying where to save the animation file</p> required <code>settings</code> <code>AnimationSettings</code> <p>Settings object containing animation parameters like frames, interval, and dpi</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments passed to animation.save()</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save_animation(\n    *,\n    fig: FigureTypeMatplotlib,\n    ax_fig: SubFigureTypeMatplotlib,\n    fname: Path,\n    settings: AnimationSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Create and save an animation of a 2D plot with scatter and line elements.\n\n    This function generates an animation by progressively revealing data points\n    in both a scatter plot and a line plot, then saves it as an animated file.\n\n    Args:\n        fig (FigureTypeMatplotlib): The matplotlib figure object containing the plot\n        ax_fig (SubFigureTypeMatplotlib): The axis object containing the plots to\n            animate\n        fname (Path): Path object specifying where to save the animation file\n        settings (AnimationSettings): Settings object containing animation\n            parameters like frames, interval, and dpi\n        **kwargs: Additional keyword arguments passed to animation.save()\n    \"\"\"\n    x_axis_data = ax_fig.lines[0].get_xdata()\n    y_axis_data = ax_fig.lines[0].get_ydata()\n\n    scat = ax_fig.collections[\n        0\n    ]  # Assuming the scatter plot is the first collection\n\n    line2: plt.Line2D = ax_fig.lines[\n        1\n    ]  # Assuming the line plot to update is the second line\n\n    def update(frame: int, settings: GIFSettings) -&gt; list[plt.Artist]:  # noqa: ARG001\n        # for each frame, update the data stored on each artist.\n        x = x_axis_data[:frame]\n        y = y_axis_data[:frame]\n        # update the scatter plot:\n        data = np.stack([x, y]).T\n        scat.set_offsets(data)\n        # update the line plot:\n        line2.set_xdata(x_axis_data[:frame])\n        line2.set_ydata(y_axis_data[:frame])\n        return [scat, line2]\n\n    anim = FuncAnimation(\n        fig=fig,\n        func=update,\n        frames=settings.frames,\n        interval=settings.interval,\n        fargs=(settings,),\n    )\n    anim.save(filename=fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_save_gif","title":"<code>plot_save_gif(*, fig, ax_fig, fname, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> Note <p>For generating GIFs, the a subfunction is used to update the plot for each frame of the animation. This subfunction is defined in the function <code>update</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the     save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save_gif(\n    *,\n    fig: FigureTypeMatplotlib,\n    ax_fig: SubFigureTypeMatplotlib,\n    fname: Path,\n    settings: GIFSettings,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Saves the given plot to a file.\n\n    Note:\n        For generating GIFs, the a subfunction is used to update the plot for each\n        frame of the animation. This subfunction is defined in the function\n        `update`.\n\n    Args:\n        fig (plt.figure): The figure to save.\n        ax_fig (plt.Figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        settings (GIFSettings): The settings for the GIF.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                save function.\n    \"\"\"\n\n    def update(frame: int, settings: GIFSettings) -&gt; list[SubFigureTypeMatplotlib]:\n        \"\"\"Updates the plot for each frame of the animation.\n\n        Args:\n            fig (plt.figure): The figure to update.\n            ax_fig (plt.Figure): The figure to update.\n            frame (int): The current frame number.\n            settings (GIFSettings): The settings for the GIF.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                save function.\n\n        Returns:\n            list[SubFigureTypeMatplotlib]: A list of the updated plot elements.\n        \"\"\"\n        surf: SubFigureTypeMatplotlib = ax_fig\n        if settings.zoom:\n            ax_fig.set_box_aspect(\n                None,\n                zoom=np.linspace(\n                    settings.zoom_start,\n                    settings.zoom_stop,\n                    settings.frames,\n                )[frame],\n            )\n        if settings.rotate:\n            ax_fig.view_init(\n                elev=settings.elev,\n                azim=frame * settings.azim % 360,\n            )\n        return [surf]\n\n    anim = FuncAnimation(\n        fig=fig,\n        func=update,\n        frames=settings.frames,\n        interval=settings.interval,\n        fargs=(settings,),\n    )\n    anim.save(filename=fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_series","title":"<code>plot_series(ax=None, label=None)</code>","text":"<p>Plot a 2D function as a series.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> <code>label</code> <code>list[str | None]</code> <p>The label of each line. Defaults to      None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_series(\n    self,\n    ax: FigureTypeMatplotlib | None = None,\n    label: list[str | None] | None = None,\n) -&gt; None:\n    \"\"\"Plot a 2D function as a series.\n\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n        label (list[str | None], optional): The label of each line. Defaults to\n                 None.\n    \"\"\"\n    if ax is None:\n        self.fig = plt.figure(figsize=self.size)\n        self.ax = self.fig.add_subplot(111)\n    if label is None:\n        label = [None for _ in self._x]\n    for i, _x in enumerate(self._x):\n        self.ax.plot(*_x, label=label[i], **self._kwargs)\n    self.label_settings(legend=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_show","title":"<code>plot_show()</code>","text":"<p>Show the plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_show(self) -&gt; None:\n    \"\"\"Show the plot.\"\"\"\n    plt.show()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_surface","title":"<code>plot_surface(ax=None)</code>","text":"<p>Plot a 3D function.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_surface(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n    \"\"\"Plot a 3D function.\"\"\"\n    if ax is None:\n        self.fig = plt.figure(figsize=self.size, dpi=self.dpi)\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n    self.ax.plot_surface(\n        *self._x,\n        cmap=plt.colormaps.get_cmap(self.cmap),\n        alpha=self.alpha,\n        **self._kwargs,\n    )\n    self.label_settings(dim3=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot","title":"<code>PlotlyPlot</code>","text":"<p>               Bases: <code>Plot</code></p> <p>Plotting functions using via plotly.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = PlotlyPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for the plot.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>class PlotlyPlot(Plot):\n    r\"\"\"Plotting functions using via plotly.\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = X ** 2 + Y ** 2\n        &gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n        &gt;&gt;&gt; plot.plot_3d()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n        &gt;&gt;&gt; plot.plot_contour()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ...    RayleighDistribution,\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; plot = PlotlyPlot(\n        ...     np.array([x, y_sigma_1]),\n        ...     np.array([x, y_sigma_2]),\n        ...     np.array([x, y_sigma_3]),\n        ...     settings=GraphSettings(\n        ...         axis=[\"x\", r\"$f(x)$\"],\n        ...         title=\"Rayleigh Distribution\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        settings (GraphSettings, optional): Settings for the graph. Defaults to None.\n        **kwargs (dict[str, Any]): Keyword arguments for the plot.\n    \"\"\"\n\n    fig: FigureTypePlotly\n\n    def plot_2d(self, *, mode: str = \"lines\", width: int = 2) -&gt; None:\n        \"\"\"Plot a 2D function.\n\n        Args:\n            mode (str, optional): The mode of the plot. Defaults to \"lines\".\n            width (int, optional): The width of the line. Defaults to 2.\n        \"\"\"\n        self.check_mode(mode)\n\n        self.fig = go.Figure(\n            data=go.Scatter(\n                x=self._x[0],\n                y=self._x[1],\n                mode=mode,\n                marker_color=self.color,\n                line={\"color\": self.color, \"width\": width},\n                **self._kwargs,\n            ),\n        )\n        self.label_settings()\n\n    def plot_series(\n        self,\n        mode: str = \"lines\",\n        width: int = 2,\n        label: list[str | None] | None = None,\n    ) -&gt; None:\n        \"\"\"Plot a 2D function as a series.\"\"\"\n        self.check_mode(mode)\n\n        self.fig = go.Figure()\n        if label is None:\n            label = [None for _ in self._x]\n        for i, _x in enumerate(self._x):\n            self.fig.add_trace(\n                go.Scatter(\n                    x=_x[0],\n                    y=_x[1],\n                    mode=mode,\n                    marker_color=self.color,\n                    line={\"color\": self.color, \"width\": width},\n                    name=label[i],\n                    **self._kwargs,\n                ),\n            )\n        self.label_settings(legend=True)\n\n    def check_mode(self, mode: str) -&gt; None:\n        \"\"\"Check if the mode is valid.\"\"\"\n        if mode not in {\"lines\", \"markers\", \"lines+markers\"}:\n            raise PlotAttributeError(\n                choose=mode,\n                modes={\"lines\", \"markers\", \"lines+markers\"},\n            )\n\n    # 3D plots as mesh\n    def plot_3d(self, width: int = 2) -&gt; None:\n        \"\"\"Plot a 3D function as meshgrid.\n\n        Args:\n            width (int, optional): The width of the line. Defaults to 2.\n        \"\"\"\n        lines = []\n\n        def _scatter3d(\n            *,\n            width: int,\n            i: int,\n            twist: bool = False,\n        ) -&gt; PlotlyScatterParameters:\n            \"\"\"Return the function parameter for a Plotly scatter3d plot.\n\n            Args:\n                width (int): The width of the line.\n                i (int): The index of the line.\n                twist (bool, optional): Whether to twist the line. Defaults to False.\n\n            Returns:\n                PlotlyScatterParameters: The function parameter for a Plotly scatter3d\n                     plot.\n            \"\"\"\n            x, y, z = self._x\n            x, y, z = (\n                (x[:, i], y[:, i], z[:, i]) if twist else (x[i, :], y[i, :], z[i, :])\n            )\n            return {\n                \"x\": x,\n                \"y\": y,\n                \"z\": z,\n                \"mode\": \"lines\",\n                \"line\": {\"color\": z, \"width\": width, \"colorscale\": self.cmap},\n            }\n\n        for i in range(len(self._x[0])):\n            lines.extend(\n                (\n                    go.Scatter3d(**_scatter3d(width=width, i=i)),\n                    go.Scatter3d(**_scatter3d(width=width, i=i, twist=True)),\n                ),\n            )\n        self.fig = go.Figure(data=lines)\n        self.label_settings()\n\n    def plot_contour(\n        self,\n        *,\n        contours_coloring: str | None = None,\n        showscale: bool = False,\n    ) -&gt; None:\n        \"\"\"Plot a contour plot.\n\n        Args:\n            contours_coloring (str, optional): The color of the contours. Defaults to\n                     None.\n            showscale (bool, optional): Whether to show the color scale. Defaults to\n                     False.\n\n        Raises:\n            ValueError: If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",\n                    or \"none\".\n        \"\"\"\n        if (\n            contours_coloring not in {\"fill\", \"heatmap\", \"lines\", \"none\"}\n            and contours_coloring is not None\n        ):\n            raise PlotAttributeError(\n                choose=contours_coloring,\n                modes={\"fill\", \"heatmap\", \"lines\", \"none\"},\n            )\n        self.fig = go.Figure(\n            data=go.Contour(\n                x=self._x[0].flatten(),\n                y=self._x[1].flatten(),\n                z=self._x[2].flatten(),\n                colorscale=self.cmap,\n                opacity=self.alpha,\n                showscale=showscale,\n                contours_coloring=contours_coloring,\n                **self._kwargs,\n            ),\n        )\n        self.label_settings()\n\n    def plot_surface(\n        self,\n        *,\n        color: str | None = None,\n        showscale: bool = False,\n    ) -&gt; None:\n        \"\"\"Plot a 3D function as surface.\n\n        Args:\n            color (str, optional): The color of the plot. Defaults to None.\n            showscale (bool, optional): Whether to show the color scale. Defaults to\n                     False.\n        \"\"\"\n        self.fig = go.Figure(\n            data=go.Surface(\n                x=self._x[0],\n                y=self._x[1],\n                z=self._x[2],\n                colorscale=self.cmap,\n                opacity=self.alpha,\n                showscale=showscale,\n                surfacecolor=color,\n                **self._kwargs,\n            ),\n        )\n        self.label_settings()\n\n    def label_settings(self, *, legend: bool = False) -&gt; None:\n        \"\"\"Set the labels for a 3D plot.\"\"\"\n        axis_titles = {\n            2: {\"xaxis_title\", \"yaxis_title\"},\n            3: {\"xaxis_title\", \"yaxis_title\", \"zaxis_title\"},\n        }\n        if len(self.axis) in axis_titles:\n            scene = {\n                title: self.axis[i]\n                for i, title in enumerate(axis_titles[len(self.axis)])\n            }\n            self.fig.update_layout(\n                title=self.title,\n                scene=scene,\n                showlegend=legend,\n                legend=(\n                    {\n                        \"orientation\": \"h\",\n                        \"yanchor\": \"bottom\",\n                        \"y\": 1.02,\n                        \"xanchor\": \"right\",\n                        \"x\": 1,\n                    }\n                    if legend\n                    else None\n                ),\n            )\n\n    def plot_show(self) -&gt; None:\n        \"\"\"Show the plot.\"\"\"\n        self.fig.show()\n\n    @property\n    def plot_return(self) -&gt; FigureTypePlotly:\n        \"\"\"Return the plot.\"\"\"\n        return self.fig\n\n    @staticmethod\n    def plot_save(\n        fig: go.Figure,\n        fname: Path,\n        fformat: str = \"png\",\n        scale: int = 3,\n        **kwargs: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Save the plot.\n\n        Args:\n            fig (go.Figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            scale (int, optional): The scale of the plot. Defaults to 3.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                 save function.\n        \"\"\"\n        fig.write_image(fname.with_suffix(f\".{fformat}\"), scale=scale, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_return","title":"<code>plot_return</code>  <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.check_mode","title":"<code>check_mode(mode)</code>","text":"<p>Check if the mode is valid.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def check_mode(self, mode: str) -&gt; None:\n    \"\"\"Check if the mode is valid.\"\"\"\n    if mode not in {\"lines\", \"markers\", \"lines+markers\"}:\n        raise PlotAttributeError(\n            choose=mode,\n            modes={\"lines\", \"markers\", \"lines+markers\"},\n        )\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.label_settings","title":"<code>label_settings(*, legend=False)</code>","text":"<p>Set the labels for a 3D plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def label_settings(self, *, legend: bool = False) -&gt; None:\n    \"\"\"Set the labels for a 3D plot.\"\"\"\n    axis_titles = {\n        2: {\"xaxis_title\", \"yaxis_title\"},\n        3: {\"xaxis_title\", \"yaxis_title\", \"zaxis_title\"},\n    }\n    if len(self.axis) in axis_titles:\n        scene = {\n            title: self.axis[i]\n            for i, title in enumerate(axis_titles[len(self.axis)])\n        }\n        self.fig.update_layout(\n            title=self.title,\n            scene=scene,\n            showlegend=legend,\n            legend=(\n                {\n                    \"orientation\": \"h\",\n                    \"yanchor\": \"bottom\",\n                    \"y\": 1.02,\n                    \"xanchor\": \"right\",\n                    \"x\": 1,\n                }\n                if legend\n                else None\n            ),\n        )\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_2d","title":"<code>plot_2d(*, mode='lines', width=2)</code>","text":"<p>Plot a 2D function.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The mode of the plot. Defaults to \"lines\".</p> <code>'lines'</code> <code>width</code> <code>int</code> <p>The width of the line. Defaults to 2.</p> <code>2</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_2d(self, *, mode: str = \"lines\", width: int = 2) -&gt; None:\n    \"\"\"Plot a 2D function.\n\n    Args:\n        mode (str, optional): The mode of the plot. Defaults to \"lines\".\n        width (int, optional): The width of the line. Defaults to 2.\n    \"\"\"\n    self.check_mode(mode)\n\n    self.fig = go.Figure(\n        data=go.Scatter(\n            x=self._x[0],\n            y=self._x[1],\n            mode=mode,\n            marker_color=self.color,\n            line={\"color\": self.color, \"width\": width},\n            **self._kwargs,\n        ),\n    )\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_3d","title":"<code>plot_3d(width=2)</code>","text":"<p>Plot a 3D function as meshgrid.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the line. Defaults to 2.</p> <code>2</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_3d(self, width: int = 2) -&gt; None:\n    \"\"\"Plot a 3D function as meshgrid.\n\n    Args:\n        width (int, optional): The width of the line. Defaults to 2.\n    \"\"\"\n    lines = []\n\n    def _scatter3d(\n        *,\n        width: int,\n        i: int,\n        twist: bool = False,\n    ) -&gt; PlotlyScatterParameters:\n        \"\"\"Return the function parameter for a Plotly scatter3d plot.\n\n        Args:\n            width (int): The width of the line.\n            i (int): The index of the line.\n            twist (bool, optional): Whether to twist the line. Defaults to False.\n\n        Returns:\n            PlotlyScatterParameters: The function parameter for a Plotly scatter3d\n                 plot.\n        \"\"\"\n        x, y, z = self._x\n        x, y, z = (\n            (x[:, i], y[:, i], z[:, i]) if twist else (x[i, :], y[i, :], z[i, :])\n        )\n        return {\n            \"x\": x,\n            \"y\": y,\n            \"z\": z,\n            \"mode\": \"lines\",\n            \"line\": {\"color\": z, \"width\": width, \"colorscale\": self.cmap},\n        }\n\n    for i in range(len(self._x[0])):\n        lines.extend(\n            (\n                go.Scatter3d(**_scatter3d(width=width, i=i)),\n                go.Scatter3d(**_scatter3d(width=width, i=i, twist=True)),\n            ),\n        )\n    self.fig = go.Figure(data=lines)\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_contour","title":"<code>plot_contour(*, contours_coloring=None, showscale=False)</code>","text":"<p>Plot a contour plot.</p> <p>Parameters:</p> Name Type Description Default <code>contours_coloring</code> <code>str</code> <p>The color of the contours. Defaults to      None.</p> <code>None</code> <code>showscale</code> <code>bool</code> <p>Whether to show the color scale. Defaults to      False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",     or \"none\".</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_contour(\n    self,\n    *,\n    contours_coloring: str | None = None,\n    showscale: bool = False,\n) -&gt; None:\n    \"\"\"Plot a contour plot.\n\n    Args:\n        contours_coloring (str, optional): The color of the contours. Defaults to\n                 None.\n        showscale (bool, optional): Whether to show the color scale. Defaults to\n                 False.\n\n    Raises:\n        ValueError: If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",\n                or \"none\".\n    \"\"\"\n    if (\n        contours_coloring not in {\"fill\", \"heatmap\", \"lines\", \"none\"}\n        and contours_coloring is not None\n    ):\n        raise PlotAttributeError(\n            choose=contours_coloring,\n            modes={\"fill\", \"heatmap\", \"lines\", \"none\"},\n        )\n    self.fig = go.Figure(\n        data=go.Contour(\n            x=self._x[0].flatten(),\n            y=self._x[1].flatten(),\n            z=self._x[2].flatten(),\n            colorscale=self.cmap,\n            opacity=self.alpha,\n            showscale=showscale,\n            contours_coloring=contours_coloring,\n            **self._kwargs,\n        ),\n    )\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', scale=3, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save the plot.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>scale</code> <code>int</code> <p>The scale of the plot. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the  save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save(\n    fig: go.Figure,\n    fname: Path,\n    fformat: str = \"png\",\n    scale: int = 3,\n    **kwargs: dict[str, Any],\n) -&gt; None:\n    \"\"\"Save the plot.\n\n    Args:\n        fig (go.Figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        scale (int, optional): The scale of the plot. Defaults to 3.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n             save function.\n    \"\"\"\n    fig.write_image(fname.with_suffix(f\".{fformat}\"), scale=scale, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_series","title":"<code>plot_series(mode='lines', width=2, label=None)</code>","text":"<p>Plot a 2D function as a series.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_series(\n    self,\n    mode: str = \"lines\",\n    width: int = 2,\n    label: list[str | None] | None = None,\n) -&gt; None:\n    \"\"\"Plot a 2D function as a series.\"\"\"\n    self.check_mode(mode)\n\n    self.fig = go.Figure()\n    if label is None:\n        label = [None for _ in self._x]\n    for i, _x in enumerate(self._x):\n        self.fig.add_trace(\n            go.Scatter(\n                x=_x[0],\n                y=_x[1],\n                mode=mode,\n                marker_color=self.color,\n                line={\"color\": self.color, \"width\": width},\n                name=label[i],\n                **self._kwargs,\n            ),\n        )\n    self.label_settings(legend=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_show","title":"<code>plot_show()</code>","text":"<p>Show the plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_show(self) -&gt; None:\n    \"\"\"Show the plot.\"\"\"\n    self.fig.show()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_surface","title":"<code>plot_surface(*, color=None, showscale=False)</code>","text":"<p>Plot a 3D function as surface.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>The color of the plot. Defaults to None.</p> <code>None</code> <code>showscale</code> <code>bool</code> <p>Whether to show the color scale. Defaults to      False.</p> <code>False</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_surface(\n    self,\n    *,\n    color: str | None = None,\n    showscale: bool = False,\n) -&gt; None:\n    \"\"\"Plot a 3D function as surface.\n\n    Args:\n        color (str, optional): The color of the plot. Defaults to None.\n        showscale (bool, optional): Whether to show the color scale. Defaults to\n                 False.\n    \"\"\"\n    self.fig = go.Figure(\n        data=go.Surface(\n            x=self._x[0],\n            y=self._x[1],\n            z=self._x[2],\n            colorscale=self.cmap,\n            opacity=self.alpha,\n            showscale=showscale,\n            surfacecolor=color,\n            **self._kwargs,\n        ),\n    )\n    self.label_settings()\n</code></pre>"},{"location":"modules/api/theory/","title":"Modules","text":"<p>Pathological functions for the useful-math-functions library.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.BesicovitchFunction","title":"<code>BesicovitchFunction</code>","text":"<p>               Bases: <code>PathologicalPure</code></p> <p>Besicovitch Function.</p> <p>The Besicovitch function is a fractal-like continuous function defined on the real line. It is also known as the Besicovitch-Eggleston function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import BesicovitchFunction\n&gt;&gt;&gt; x = np.linspace(0, 1, 10000)\n&gt;&gt;&gt; wf = BesicovitchFunction(x, n=30)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 100\n...     ax.set_xlim(0 + zoom_factor/2 ,1 - zoom_factor/2)\n...     ax.set_ylim(-1 + zoom_factor, 1 - zoom_factor)\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('BesicovitchFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Besicovitch function is a fractal-like continuous function defined on the real line. It is also known as the Besicovitch-Eggleston function.</p> \\[ B(x) = \\sum_{n=1}^{n_1} \\frac{\\sin(\\pi 2^n x)}{\\mu^n} \\] <p>with constraint \\(\\mu \\geq 1\\).</p> <p>Reference: en.wikipedia.org/wiki/Besicovitch</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Weierstrass function is evaluated.</p> <code>()</code> <code>n</code> <code>int</code> <p>Number of iterations to compute the Besicovitch function. Defaults to 10.</p> <code>10</code> <code>mu</code> <code>float</code> <p>A parameter of the function that controls the frequency of oscillations. Must satisfy the condition b &gt;= 1. Defaults to 2.</p> <code>2</code> <p>Raises:</p> Type Description <code>NotLargerThanAnyError</code> <p>If \\(\\mu\\) is not larger than 1.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class BesicovitchFunction(PathologicalPure):\n    r\"\"\"Besicovitch Function.\n\n    The Besicovitch function is a fractal-like continuous function defined on the\n    real line. It is also known as the Besicovitch-Eggleston function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import BesicovitchFunction\n        &gt;&gt;&gt; x = np.linspace(0, 1, 10000)\n        &gt;&gt;&gt; wf = BesicovitchFunction(x, n=30)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 100\n        ...     ax.set_xlim(0 + zoom_factor/2 ,1 - zoom_factor/2)\n        ...     ax.set_ylim(-1 + zoom_factor, 1 - zoom_factor)\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('BesicovitchFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Besicovitch function is a fractal-like continuous function defined on the\n        real line. It is also known as the Besicovitch-Eggleston function.\n\n        $$\n        B(x) = \\sum_{n=1}^{n_1} \\frac{\\sin(\\pi 2^n x)}{\\mu^n}\n        $$\n\n        with constraint $\\mu \\geq 1$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Besicovitch\n\n    Args:\n        *x (UniversalArray): Input values for which the Weierstrass function is\n            evaluated.\n        n (int, optional): Number of iterations to compute the Besicovitch function.\n            Defaults to 10.\n        mu (float, optional): A parameter of the function that controls the frequency\n            of oscillations. Must satisfy the condition b &gt;= 1. Defaults to 2.\n\n    Raises:\n        NotLargerThanAnyError: If $\\mu$ is not larger than 1.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 10, mu: float = 2) -&gt; None:\n        \"\"\"Initialize the Besicovitch function.\"\"\"\n        if mu &lt; 1:\n            raise NotLargerThanAnyError(var_number=\"mu\", number=mu, minimum=1)\n        super().__init__(*x, n_0=1, n_1=n)\n        self.mu = mu\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Besicovitch function.\"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(1, self.n_1 + 1):\n            result += np.sin(2**n * np.pi * self._x) / (self.mu**n)\n        return result\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.BesicovitchFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the Besicovitch function.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.BesicovitchFunction.__init__","title":"<code>__init__(*x, n=10, mu=2)</code>","text":"<p>Initialize the Besicovitch function.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, n: int = 10, mu: float = 2) -&gt; None:\n    \"\"\"Initialize the Besicovitch function.\"\"\"\n    if mu &lt; 1:\n        raise NotLargerThanAnyError(var_number=\"mu\", number=mu, minimum=1)\n    super().__init__(*x, n_0=1, n_1=n)\n    self.mu = mu\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.MandelbrotsFractalFunction","title":"<code>MandelbrotsFractalFunction</code>","text":"<p>               Bases: <code>PathologicalPure</code></p> <p>Mandelbrot's Fractal Function.</p> <p>The Mandelbrot set is a famous example of a fractal, a mathematical object that exhibits self-similarity at different scales. It is named after the mathematician Benoit Mandelbrot, who first visualized and defined it in 1980. The set is created by iterating the function f_c(z) = z^2 + c over complex numbers c, where z starts at zero. A complex number c is part of the Mandelbrot set if, when applying this iteration, the absolute value of z does not diverge to infinity no matter how many times the iteration is applied. The beauty of the Mandelbrot set lies in its complex and boundary-defining structure, which reveals an infinitely detailed and varied pattern upon magnification.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import MandelbrotsFractalFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 1000)\n&gt;&gt;&gt; rf = MandelbrotsFractalFunction(x, max_iter=50)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; ax_return= ax.imshow(\n...                rf.result,\n...                cmap='seismic',\n...                extent=(-2, 2, -2, 2),\n...                interpolation='bilinear',\n...               )\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 50.0\n...     ax.set_xlim(-2 , 2 - zoom_factor)\n...     ax.set_ylim(-2 + zoom_factor, 2 - zoom_factor)\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('MandelbrotsFractalFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Mandelbrot set is the set of complex numbers \\(\\(c\\)\\) for which the function \\(\\(f_c(z) = z^2 + c\\)\\) does not diverge when iterated from \\(\\(z = 0\\)\\). The Mandelbrot set is a fractal, meaning that it exhibits self-similarity at different scales.</p> \\[ M = \\{c \\in \\mathbb{C} : \\lim_{n \\to \\infty} |z_n| \\leq 2\\} \\] <p>where \\((z_{n+1} = z_n^2 + c)\\) and \\((z_0 = 0)\\).</p> <p>Reference: en.wikipedia.org/wiki/Mandelbrot_set</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The coordinates in the complex plane where the function will be evaluated.</p> <code>()</code> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations to perform. Defaults to 100.</p> <code>100</code> <code>escape_threshold</code> <code>float</code> <p>The threshold for escaping the fractal region. Defaults to 2.0.</p> <code>2.0</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class MandelbrotsFractalFunction(PathologicalPure):\n    r\"\"\"Mandelbrot's Fractal Function.\n\n    The Mandelbrot set is a famous example of a fractal, a mathematical object that\n    exhibits self-similarity at different scales. It is named after the mathematician\n    Benoit Mandelbrot, who first visualized and defined it in 1980. The set is created\n    by iterating the function f_c(z) = z^2 + c over complex numbers c, where z starts\n    at zero. A complex number c is part of the Mandelbrot set if, when applying this\n    iteration, the absolute value of z does not diverge to infinity no matter how many\n    times the iteration is applied. The beauty of the Mandelbrot set lies in its\n    complex and boundary-defining structure, which reveals an infinitely detailed and\n    varied pattern upon magnification.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import MandelbrotsFractalFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 1000)\n        &gt;&gt;&gt; rf = MandelbrotsFractalFunction(x, max_iter=50)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; ax_return= ax.imshow(\n        ...                rf.result,\n        ...                cmap='seismic',\n        ...                extent=(-2, 2, -2, 2),\n        ...                interpolation='bilinear',\n        ...               )\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 50.0\n        ...     ax.set_xlim(-2 , 2 - zoom_factor)\n        ...     ax.set_ylim(-2 + zoom_factor, 2 - zoom_factor)\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('MandelbrotsFractalFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Mandelbrot set is the set of complex numbers $\\(c\\)$ for which the function\n        $\\(f_c(z) = z^2 + c\\)$ does not diverge when iterated from $\\(z = 0\\)$. The\n        Mandelbrot set is a fractal, meaning that it exhibits self-similarity at\n        different scales.\n\n        $$\n        M = \\{c \\in \\mathbb{C} : \\lim_{n \\to \\infty} |z_n| \\leq 2\\}\n        $$\n\n        where $(z_{n+1} = z_n^2 + c)$ and $(z_0 = 0)$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Mandelbrot_set\n\n    Args:\n        *x (UniversalArray): The coordinates in the complex plane where the function\n            will be evaluated.\n        max_iter (int, optional): The maximum number of iterations to perform. Defaults\n            to 100.\n        escape_threshold (float, optional): The threshold for escaping the fractal\n            region. Defaults to 2.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        max_iter: int = 100,\n        escape_threshold: float = 2.0,\n    ) -&gt; None:\n        \"\"\"Initialize the Mandelbrot's Fractal function.\"\"\"\n        super().__init__(*x, n_0=0, n_1=max_iter)\n        self.escape_threshold = escape_threshold\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Mandelbrot's Fractal function.\n\n        Returns:\n            UniversalArray: The Mandelbrot's Fractal function.\n        \"\"\"\n        height = len(self._x)\n        width = 2 * len(self._x) // 3\n        mandelbrot_set = np.zeros((height, width))\n\n        for i in range(height):\n            for j in range(width):\n                c = complex(self._x[j], self._x[i])\n                z = 0\n                for k in range(self.n_1):\n                    z: complex = z**2 + c\n                    if abs(z) &gt; self.escape_threshold:\n                        mandelbrot_set[i, j] = k\n                        break\n                else:\n                    mandelbrot_set[i, j] = self.n_1\n        return mandelbrot_set\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.MandelbrotsFractalFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the Mandelbrot's Fractal function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The Mandelbrot's Fractal function.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.MandelbrotsFractalFunction.__init__","title":"<code>__init__(*x, max_iter=100, escape_threshold=2.0)</code>","text":"<p>Initialize the Mandelbrot's Fractal function.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    max_iter: int = 100,\n    escape_threshold: float = 2.0,\n) -&gt; None:\n    \"\"\"Initialize the Mandelbrot's Fractal function.\"\"\"\n    super().__init__(*x, n_0=0, n_1=max_iter)\n    self.escape_threshold = escape_threshold\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.RiemannFunction","title":"<code>RiemannFunction</code>","text":"<p>               Bases: <code>PathologicalPure</code></p> <p>Riemann Function.</p> <p>The Riemann function is a mathematical function that is defined as the sum of a series of terms. Each term in the series is calculated using the Riemann zeta function and the sine function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import RiemannFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n&gt;&gt;&gt; rf = RiemannFunction(x, n=20)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, rf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...         -3 + zoom_factor / 1.3, 3 - zoom_factor / 1.3\n...         )\n...     ax.set_ylim(\n...             -2.5 + zoom_factor / 5, 2.5 - zoom_factor / 5\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('RiemannFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Riemann function is a mathematical function that is defined as the sum of a series of terms. Each term in the series is calculated using the Riemann zeta function and the sine function.</p> \\[ R(x) = \\sum_{n=1}^{n_1} \\frac{1}{n^2} \\sin(n^2 \\pi x) \\] <p>Reference: en.wikipedia.org/wiki/Riemann_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The input values at which to evaluate the Riemann function.</p> <code>()</code> <code>n</code> <code>int</code> <p>The number of terms to include in the series. Defaults to 100.</p> <code>100</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class RiemannFunction(PathologicalPure):\n    r\"\"\"Riemann Function.\n\n    The Riemann function is a mathematical function that is defined as the sum of\n    a series of terms. Each term in the series is calculated using the\n    Riemann zeta function and the sine function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import RiemannFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n        &gt;&gt;&gt; rf = RiemannFunction(x, n=20)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, rf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...         -3 + zoom_factor / 1.3, 3 - zoom_factor / 1.3\n        ...         )\n        ...     ax.set_ylim(\n        ...             -2.5 + zoom_factor / 5, 2.5 - zoom_factor / 5\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('RiemannFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Riemann function is a mathematical function that is defined as the sum of\n        a series of terms. Each term in the series is calculated using the\n        Riemann zeta function and the sine function.\n\n        $$\n        R(x) = \\sum_{n=1}^{n_1} \\frac{1}{n^2} \\sin(n^2 \\pi x)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Riemann_function\n\n    Args:\n        *x (UniversalArray): The input values at which to evaluate the Riemann function.\n        n (int, optional): The number of terms to include in the series.\n            Defaults to 100.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n        \"\"\"Initialize the Riemann function.\"\"\"\n        super().__init__(*x, n_0=1, n_1=n)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Riemann function.\n\n        Returns:\n            UniversalArray: The Riemann function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(self.n_0, self.n_1 + 1):\n            result += (1 / n**2) * np.sin(n**2 * np.pi * self._x)\n        return result\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.RiemannFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the Riemann function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The Riemann function.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.RiemannFunction.__init__","title":"<code>__init__(*x, n=100)</code>","text":"<p>Initialize the Riemann function.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n    \"\"\"Initialize the Riemann function.\"\"\"\n    super().__init__(*x, n_0=1, n_1=n)\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.TakagiFunction","title":"<code>TakagiFunction</code>","text":"<p>               Bases: <code>PathologicalPure</code></p> <p>Takagi Function.</p> <p>The Takagi function is a fractal-like continuous function defined on the real line. It is also known as the Takagi-Landsberg function or the Blancmange function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import TakagiFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 1.5, 100000)\n&gt;&gt;&gt; tf = TakagiFunction(x, n=20)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, tf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...             -1.5 + zoom_factor / 2.5, 1.5 - zoom_factor / 2.5\n...         )\n...     ax.set_ylim(\n...          0 + zoom_factor / 25, 0.6 - zoom_factor / 25\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('TakagiFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Takagi function is defined as the sum of a series of terms. Each term in the series is calculated using the absolute value of the fractional part of the input value raised to a power. It is also known as Blancmange curve.</p> \\[ T(x) = \\sum_{n=0}^{\\infty} \\frac{\\phi(2^n x)}{2^n} \\] <p>where \\((\\phi(x))\\) is the distance from \\((x)\\) to the nearest integer.</p> <p>Reference: en.wikipedia.org/wiki/Takagi_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Takagi function will be calculated.</p> <code>()</code> <code>n</code> <code>int</code> <p>Number of iterations to compute the Takagi function. Defaults to 100.</p> <code>100</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class TakagiFunction(PathologicalPure):\n    r\"\"\"Takagi Function.\n\n    The Takagi function is a fractal-like continuous function defined on the real line.\n    It is also known as the Takagi-Landsberg function or the Blancmange function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import TakagiFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 1.5, 100000)\n        &gt;&gt;&gt; tf = TakagiFunction(x, n=20)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, tf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...             -1.5 + zoom_factor / 2.5, 1.5 - zoom_factor / 2.5\n        ...         )\n        ...     ax.set_ylim(\n        ...          0 + zoom_factor / 25, 0.6 - zoom_factor / 25\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('TakagiFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Takagi function is defined as the sum of a series of terms. Each term in the\n        series is calculated using the absolute value of the fractional part of the\n        input value raised to a power. It is also known as Blancmange curve.\n\n        $$\n        T(x) = \\sum_{n=0}^{\\infty} \\frac{\\phi(2^n x)}{2^n}\n        $$\n\n        where $(\\phi(x))$ is the distance from $(x)$ to the nearest integer.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Takagi_function\n\n    Args:\n        *x (UniversalArray): Input values for which the Takagi function will be\n            calculated.\n        n (int, optional): Number of iterations to compute the Takagi function.\n            Defaults to 100.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n        \"\"\"Initialize the Takagi function.\"\"\"\n        super().__init__(*x, n_0=0, n_1=n)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Takagi function.\n\n        Returns:\n            UniversalArray: The Takagi function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(1, self.n_1):\n            result += self.phi(x=2**n * self._x) / 2**n\n        return result\n\n    @staticmethod\n    def phi(x: UniversalArray) -&gt; UniversalArray:\n        \"\"\"Calculate the distance from x to the nearest integer.\"\"\"\n        return np.abs(x - np.round(x))\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.TakagiFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the Takagi function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The Takagi function.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.TakagiFunction.__init__","title":"<code>__init__(*x, n=100)</code>","text":"<p>Initialize the Takagi function.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n    \"\"\"Initialize the Takagi function.\"\"\"\n    super().__init__(*x, n_0=0, n_1=n)\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.TakagiFunction.phi","title":"<code>phi(x)</code>  <code>staticmethod</code>","text":"<p>Calculate the distance from x to the nearest integer.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>@staticmethod\ndef phi(x: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Calculate the distance from x to the nearest integer.\"\"\"\n    return np.abs(x - np.round(x))\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.WeierstrassFunction","title":"<code>WeierstrassFunction</code>","text":"<p>               Bases: <code>PathologicalWithCoefficients</code></p> <p>Weierstrass function.</p> <p>The Weierstrass function is a famous example of a real-valued function that is continuous everywhere but differentiable nowhere. It is defined by an infinite series that oscillates too wildly to settle down to a smooth curve.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import WeierstrassFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n&gt;&gt;&gt; wf = WeierstrassFunction(x, n=20, a=0.5, b=30)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...             -3 + zoom_factor / 1.3, 3 - zoom_factor/ 1.3\n...         )\n...     ax.set_ylim(\n...             -2.5 + zoom_factor / 2.5, 2.5 - zoom_factor / 5\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('WeierstrassFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Weierstrass function is a prototypical example of a pathological function in mathematical analysis. Its definition challenges the intuition that a continuous function must be smooth.</p> \\[ W(x) = \\sum_{n=0}^{n_1} a^n \\cos(b^n \\pi x) \\] <p>with constraints \\(0 &lt; a &lt; 1\\) and \\(ab &gt; 1 + 3\\pi/2\\).</p> <p>Reference: en.wikipedia.org/wiki/Weierstrass_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Weierstrass function is evaluated.</p> <code>()</code> <code>n</code> <code>int</code> <p>The upper limit of the summation. Defaults to 10.</p> <code>10</code> <code>a</code> <code>float</code> <p>A parameter of the function that controls the amplitude of oscillations. Must be in the range (0, 1). Defaults to 0.9.</p> <code>0.9</code> <code>b</code> <code>float</code> <p>A parameter of the function that controls the frequency of oscillations. Must satisfy the condition a * b &gt; (1 + 3 * np.pi / 2). Defaults to 7.</p> <code>7</code> <p>Raises:</p> Type Description <code>NotInRangesError</code> <p>If \\(a\\) is not in the range \\((0, 1)\\).</p> <code>NotLargerThanAnyError</code> <p>If \\(a * b\\) is not larger than \\((1 + 3 * np.pi / 2)\\).</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class WeierstrassFunction(PathologicalWithCoefficients):\n    r\"\"\"Weierstrass function.\n\n    The Weierstrass function is a famous example of a real-valued function that is\n    continuous everywhere but differentiable nowhere. It is defined by an infinite\n    series that oscillates too wildly to settle down to a smooth curve.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import WeierstrassFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n        &gt;&gt;&gt; wf = WeierstrassFunction(x, n=20, a=0.5, b=30)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...             -3 + zoom_factor / 1.3, 3 - zoom_factor/ 1.3\n        ...         )\n        ...     ax.set_ylim(\n        ...             -2.5 + zoom_factor / 2.5, 2.5 - zoom_factor / 5\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('WeierstrassFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Weierstrass function is a prototypical example of a pathological\n        function in mathematical analysis. Its definition challenges the\n        intuition that a continuous function must be smooth.\n\n        $$\n        W(x) = \\sum_{n=0}^{n_1} a^n \\cos(b^n \\pi x)\n        $$\n\n        with constraints $0 &lt; a &lt; 1$ and $ab &gt; 1 + 3\\pi/2$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Weierstrass_function\n\n    Args:\n        *x (UniversalArray): Input values for which the Weierstrass function is\n            evaluated.\n        n (int, optional): The upper limit of the summation. Defaults to 10.\n        a (float, optional): A parameter of the function that controls the amplitude of\n            oscillations. Must be in the range (0, 1). Defaults to 0.9.\n        b (float, optional): A parameter of the function that controls the frequency\n            of oscillations. Must satisfy the condition a * b &gt; (1 + 3 * np.pi / 2).\n            Defaults to 7.\n\n    Raises:\n        NotInRangesError: If $a$ is not in the range $(0, 1)$.\n        NotLargerThanAnyError: If $a * b$ is not larger than $(1 + 3 * np.pi / 2)$.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        n: int = 10,\n        a: float = 0.9,\n        b: float = 7,\n    ) -&gt; None:\n        \"\"\"Initialize the Weierstrass function.\"\"\"\n        if not 0 &lt; a &lt; 1:\n            raise NotInRangesError(var_number=\"a\", number=a, ranges=(0, 1))\n\n        if a * b &lt;= (1 + 3 * np.pi / 2):\n            raise NotLargerThanAnyError(\n                var_number=\"a * b\",\n                number=a * b,\n                minimum=(1 + 3 * np.pi / 2),\n            )\n        super().__init__(*x, n_0=0, n_1=n, a=a, b=b)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Weierstrass function.\n\n        Returns:\n            UniversalArray: The Weierstrass function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(self.n_0, self.n_1 + 1):\n            result += self.a**n * np.cos(self.b**n * np.pi * self._x)\n        return result\n</code></pre>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.WeierstrassFunction.__eval__","title":"<code>__eval__</code>  <code>property</code>","text":"<p>Calculate the Weierstrass function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The Weierstrass function.</p>"},{"location":"modules/api/theory/#umf.functions.theory.pathological.WeierstrassFunction.__init__","title":"<code>__init__(*x, n=10, a=0.9, b=7)</code>","text":"<p>Initialize the Weierstrass function.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>def __init__(\n    self,\n    *x: UniversalArray,\n    n: int = 10,\n    a: float = 0.9,\n    b: float = 7,\n) -&gt; None:\n    \"\"\"Initialize the Weierstrass function.\"\"\"\n    if not 0 &lt; a &lt; 1:\n        raise NotInRangesError(var_number=\"a\", number=a, ranges=(0, 1))\n\n    if a * b &lt;= (1 + 3 * np.pi / 2):\n        raise NotLargerThanAnyError(\n            var_number=\"a * b\",\n            number=a * b,\n            minimum=(1 + 3 * np.pi / 2),\n        )\n    super().__init__(*x, n_0=0, n_1=n, a=a, b=b)\n</code></pre>"},{"location":"modules/export/","title":"Export","text":"<p>The useful-math-functions-functions-functions-functions-functions package provides several functions for exporting mathematical expressions as images, text, or binary data. Furthermore it is possible to export the whole documentation of function or module as a string.</p>"},{"location":"modules/export/2d_and_3d_plots/","title":"2D and 3D Plots","text":""},{"location":"modules/export/2d_and_3d_plots/#matplotlib-type-plots","title":"Matplotlib-type Plots","text":"<p>Plotting functions using via matplotlib.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n&gt;&gt;&gt; plot.plot_dashboard()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.meta.plots import GIFSettings\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; # Start with a simple plot\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     X,\n...     Y,\n...     Z,\n...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n... )\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; # Now only zoom\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n...     settings=GIFSettings(rotate=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n...     settings=GIFSettings(zoom=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only zoom and rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n...     settings=GIFSettings(),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Types Matplotlib-type Plots 3D-Plot Contour-Plot Surface-Plot Dashboard-Plot coming soon 2D-Plot"},{"location":"modules/export/2d_and_3d_plots/#plotly-type-plots","title":"Plotly-type Plots","text":"<p>Plotting functions using via plotly.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = PlotlyPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for the plot.</p> <code>{}</code> Types Plotly-type Plots 3D-Plot Contour-Plot Surface-Plot Dashboard-Plot coming soon 2D-Plot"},{"location":"modules/export/dataset_generation/","title":"Dataset Generation","text":""},{"location":"modules/export/dataset_generation/#optbench-dataset-generation","title":"OptBench Dataset Generation","text":"<p>Dataset Generation</p> <p>This page describes how to generate the OptBench dataset, which covers a wide range a wide range of different formats:</p> <ul> <li> Text file based as <code>*.csv</code> and <code>*.json</code></li> <li> Binary file based as <code>*.npy</code></li> <li> Image file based as <code>*.png</code> for 2D, 3D, and gif animations. Furthermore,        the image files can also contains series of different functions, if the        used functions are 2D.</li> </ul> Text file based dataset generation JSONCSVCode JSON<pre><code>{\n    \"x_0\": [\n        [\n        -5.0, -4.9, -4.800000000000001, -4.700000000000001, -4.600000000000001,\n        -4.500000000000002, -4.400000000000002, -4.3000000000000025,\n        -4.200000000000003, -4.100000000000003, -4.0000000000000036,\n        -3.900000000000004, -3.8000000000000043, -3.7000000000000046,\n        -3.600000000000005, -3.5000000000000053, -3.4000000000000057,\n        -3.300000000000006, -3.2000000000000064, -3.1000000000000068,\n        -3.000000000000007, -2.9000000000000075, -2.800000000000008,\n        -2.700000000000008, -2.6000000000000085, -2.500000000000009,\n        -2.4000000000000092, -2.3000000000000096, -2.20000000000001,\n        -2.1000000000000103, -2.0000000000000107, -1.900000000000011,\n        -1.8000000000000114, -1.7000000000000117, -1.600000000000012,\n        -1.5000000000000124, -1.4000000000000128, -1.3000000000000131,\n        -1.2000000000000135, -1.1000000000000139, -1.0000000000000142,\n        -0.9000000000000146, -0.8000000000000149, -0.7000000000000153,\n        -0.6000000000000156, -0.500000000000016, -0.40000000000001634,\n        -0.3000000000000167, -0.20000000000001705, -0.10000000000001741,\n        -1.7763568394002505e-14, 0.09999999999998188, 0.19999999999998153,\n        0.29999999999998117, 0.3999999999999808, 0.49999999999998046,\n        0.5999999999999801, 0.6999999999999797, 0.7999999999999794,\n        0.899999999999979, 0.9999999999999787, 1.0999999999999783,\n        1.199999999999978, 1.2999999999999776, 1.3999999999999773,\n        1.499999999999977, 1.5999999999999766, 1.6999999999999762,\n        1.7999999999999758, 1.8999999999999755, 1.9999999999999751,\n        2.0999999999999748, 2.1999999999999744, 2.299999999999974,\n        2.3999999999999737, 2.4999999999999734, 2.599999999999973,\n        2.6999999999999726, 2.7999999999999723, 2.899999999999972,\n        2.9999999999999716, 3.0999999999999712, 3.199999999999971,\n        3.2999999999999705, 3.39999999999997, 3.49999999999997,\n        3.5999999999999694, 3.699999999999969, 3.7999999999999687,\n        3.8999999999999684, 3.999999999999968, 4.099999999999968,\n        4.199999999999967, 4.299999999999967, 4.399999999999967,\n        4.499999999999966, 4.599999999999966, 4.6999999999999655,\n        4.799999999999965, 4.899999999999965\n        ], ...\n    ]\n}\n</code></pre> Scdoc<pre><code>x_0,x_1,x_2\n-5.000000,-5.000000,12.642411\n-5.000000,-4.900000,12.816406\n-5.000000,-4.800000,13.289395\n-5.000000,-4.700000,13.727453\n-5.000000,-4.600000,13.966601\n-5.000000,-4.500000,13.993625\n-5.000000,-4.400000,13.820456\n-5.000000,-4.300000,13.435255\n-5.000000,-4.200000,12.851327\n-5.000000,-4.100000,12.232743\n-5.000000,-4.000000,11.913518\n-5.000000,-3.900000,12.089881\n...,...,...\n</code></pre> <p>For the generation of the dataset, the following code snippet can be used:</p> Python<pre><code>es.save_as_csv(dir_name=\"csv\")\nes.save_as_json(dir_name=\"json\")\n</code></pre> Image Generation Matplotlib <code>res.plot_style = \"matplot\"</code>Plotly <code>res.plot_style = \"plotly\"</code> Example - I Example - II Example - I Example - II <p>A class for optimizing and benchmarking mathematical functions.</p> <p>About OptBench</p> <p>This class inherits from the <code>FunctionBorg</code>, <code>PlotBorg</code>, and <code>SaveBorg</code> classes, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # 3D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n&gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n&gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # 2D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench(\n...     [\n...         \"CrystalBallDistribution\",\n...         \"PseudoVoigtDistribution\",\n...         \"AsymmetricRamanLineshape\",\n...     ],\n...     [\n...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n...     ],\n...     start=-10,\n...     stop=10,\n...     step_size=0.1,\n...     dim=2,\n... )\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>list[str] | str</code> <p>Name of the function(s) to optimize and benchmark.</p> required <code>func_args</code> <code>list[dict[str, Any]] | dict[str, Any] | None</code> <p>Arguments  for the function(s). Defaults to None.</p> <code>None</code> <code>start</code> <code>float</code> <p>Start value of the range. Defaults to -5.0.</p> <code>-5.0</code> <code>stop</code> <code>float</code> <p>Stop value of the range. Defaults to 5.0.</p> <code>5.0</code> <code>step_size</code> <code>float | int</code> <p>Step value of the range or number of maximum  steps. Defaults to 0.1.</p> <code>0.1</code> <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either  'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>ValueError</code> <p>Number of dimensions must be greater than 1.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of dimensions.</p> <code>shared_result</code> <code>dict</code> <p>Dictionary containing arrays for plotting and saving.</p> <p>Methods:</p> Name Description <code>initializeshared_result</code> <p>Make arrays for plotting, saving and add them to share result.</p> <code>create_range</code> <p>float, stop: float,</p> <code>step_size</code> <p>float, dim: int = 2, mode: str = \"arange\")</p> <code>-&gt; list[UniversalArray] | MeshArray</code> <p>Create range of values for each dimension.</p>"},{"location":"modules/export/gifs/","title":"GIFs","text":"<p>About GIFs</p> <p>In addition to the standard image formats, UMF supports exporting plots as animated GIFs. This is done by calling the <code>plot.save_gif</code> method.</p> <p>Saves the given plot to a file.</p> Note <p>For generating GIFs, the a subfunction is used to update the plot for each frame of the animation. This subfunction is defined in the function <code>update</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the     save function.</p> <code>{}</code> Zoom Rotation Zoom + Rotation"},{"location":"modules/functions/","title":"Functions","text":"<p>In the field of mathematics, a function refers to a connection between a set of possible inputs and a set of potential outputs. It is essential to note that each input corresponds to one output. Therefore, a function can be regarded as a set of rules that assigns one specific element from the set of potential outputs to each item in the possible inputs. Functions are widely used in various fields such as physics, economics, computer science, chemistry, and spectroscopy to describe the relationship between quantities, represent geometric shapes, and model real-world situations.</p> <p>Sometimes, all that's necessary are functions that can link together inputs and outputs.</p> <pre><code>graph LR\nA[Inputs] --&gt; B[Function]\nB --&gt; C[Outputs]</code></pre>"},{"location":"modules/functions/chaotic/oscillators/","title":"Oscillators","text":""},{"location":"modules/functions/chaotic/oscillators/#double-pendulum","title":"Double Pendulum","text":"<p>Double Pendulum differential equation.</p> <p>The double pendulum is a simple physical system that exhibits chaotic behavior. The double pendulum consists of two pendulums attached to each other, where the motion of the second pendulum is influenced by the motion of the first pendulum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoublePendulum\n&gt;&gt;&gt; pendulum = DoublePendulum(np.linspace(0, 10, 1000))\n&gt;&gt;&gt; x1, y1, x2, y2 = pendulum.__eval__\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x2) - 0.5, max(x2) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y2) - 0.5, max(y2) + 0.5)\n&gt;&gt;&gt; (line,) = ax.plot([], [], \"o-\", lw=2)\n&gt;&gt;&gt; def init():\n...     line.set_data([], [])\n...     return (line,)\n&gt;&gt;&gt; def update(frame):\n...     line.set_data([0, x1[frame], x2[frame]], [0, y1[frame], y2[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return (line,)\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('DoublePendulum.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The double pendulum differential equation is defined as:</p> \\[ \\begin{align*} \\dot{z_1} &amp;= \\frac{m_2 g \\sin(\\theta_2) \\cos(\\theta_1 - \\theta_2) - m_2 \\sin(\\theta_1 - \\theta_2) (l_1 z_1^2 \\cos(\\theta_1 - \\theta_2) + l_2 z_2^2) - (m_1 + m_2) g \\sin(\\theta_1)}{l_1 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\\\ \\dot{z_2} &amp;= \\frac{(m_1 + m_2) (l_1 z_1^2 \\sin(\\theta_1 - \\theta_2) - g \\sin(\\theta_2) + g \\sin(\\theta_1) \\cos(\\theta_1 - \\theta_2)) + m_2 l_2 z_2^2 \\sin(\\theta_1 - \\theta_2) \\cos(\\theta_1 - \\theta_2)}{l_2 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\end{align*} \\] <p>with \\(\\dot{\\theta_1} = z_1 \\\\\\) and \\(\\dot{\\theta_2} = z_2\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>theta1</code> <code>float</code> <p>The initial angle of the first pendulum. Defaults to pi / 2.</p> <code>pi / 2</code> <code>theta2</code> <code>float</code> <p>The initial angle of the second pendulum. Defaults to pi / 2.</p> <code>pi / 2</code> <code>z1</code> <code>float</code> <p>The initial angular velocity of the first pendulum. Defaults to 0.0.</p> <code>0.0</code> <code>z2</code> <code>float</code> <p>The initial angular velocity of the second pendulum. Defaults to 0.0.</p> <code>0.0</code> <code>m1</code> <code>float</code> <p>The mass of the first pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>m2</code> <code>float</code> <p>The mass of the second pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>l1</code> <code>float</code> <p>The length of the first pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>l2</code> <code>float</code> <p>The length of the second pendulum. Defaults to 1.0.</p> <code>1.0</code> <code>g</code> <code>float</code> <p>The acceleration due to gravity. Defaults to 9.81.</p> <code>g</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the double pendulum. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class DoublePendulum(OscillatorsFuncBase):\n    r\"\"\"Double Pendulum differential equation.\n\n    The double pendulum is a simple physical system that exhibits chaotic behavior.\n    The double pendulum consists of two pendulums attached to each other, where the\n    motion of the second pendulum is influenced by the motion of the first pendulum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import DoublePendulum\n        &gt;&gt;&gt; pendulum = DoublePendulum(np.linspace(0, 10, 1000))\n        &gt;&gt;&gt; x1, y1, x2, y2 = pendulum.__eval__\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x2) - 0.5, max(x2) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y2) - 0.5, max(y2) + 0.5)\n        &gt;&gt;&gt; (line,) = ax.plot([], [], \"o-\", lw=2)\n        &gt;&gt;&gt; def init():\n        ...     line.set_data([], [])\n        ...     return (line,)\n        &gt;&gt;&gt; def update(frame):\n        ...     line.set_data([0, x1[frame], x2[frame]], [0, y1[frame], y2[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return (line,)\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('DoublePendulum.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The double pendulum differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{z_1} &amp;= \\frac{m_2 g \\sin(\\theta_2) \\cos(\\theta_1 - \\theta_2)\n        - m_2 \\sin(\\theta_1 - \\theta_2) (l_1 z_1^2 \\cos(\\theta_1 - \\theta_2)\n        + l_2 z_2^2) - (m_1 + m_2) g \\sin(\\theta_1)}{l_1 (m_1\n        + m_2 \\sin^2(\\theta_1 - \\theta_2))} \\\\\n        \\dot{z_2} &amp;= \\frac{(m_1 + m_2) (l_1 z_1^2 \\sin(\\theta_1 - \\theta_2)\n        - g \\sin(\\theta_2) + g \\sin(\\theta_1) \\cos(\\theta_1 - \\theta_2))\n        + m_2 l_2 z_2^2 \\sin(\\theta_1 - \\theta_2) \\cos(\\theta_1\n        - \\theta_2)}{l_2 (m_1 + m_2 \\sin^2(\\theta_1 - \\theta_2))}\n        \\end{align*}\n        $$\n\n        with $\\dot{\\theta_1} = z_1 \\\\$ and $\\dot{\\theta_2} = z_2$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        theta1 (float, optional): The initial angle of the first pendulum. Defaults to\n            pi / 2.\n        theta2 (float, optional): The initial angle of the second pendulum. Defaults to\n            pi / 2.\n        z1 (float, optional): The initial angular velocity of the first pendulum.\n            Defaults to 0.0.\n        z2 (float, optional): The initial angular velocity of the second pendulum.\n            Defaults to 0.0.\n        m1 (float, optional): The mass of the first pendulum. Defaults to 1.0.\n        m2 (float, optional): The mass of the second pendulum. Defaults to 1.0.\n        l1 (float, optional): The length of the first pendulum. Defaults to 1.0.\n        l2 (float, optional): The length of the second pendulum. Defaults to 1.0.\n        g (float, optional): The acceleration due to gravity. Defaults to 9.81.\n        velocity (bool, optional): Whether to return the velocity of the double\n            pendulum. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        theta1: float = pi / 2,\n        theta2: float = pi / 2,\n        z1: float = 0.0,\n        z2: float = 0.0,\n        m1: float = 1.0,\n        m2: float = 1.0,\n        l1: float = 1.0,\n        l2: float = 1.0,\n        g: float = g,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(\n            *t,\n            time_format=time_format,\n            velocity=velocity,\n        )\n        self.theta1 = theta1\n        self.theta2 = theta2\n        self.z1 = z1\n        self.z2 = z2\n        self.m1 = m1\n        self.m2 = m2\n        self.l1 = l1\n        self.l2 = l2\n        self.g = g\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the double pendulum.\n\n        Returns:\n            dict[str, float]: The initial configuration of the double pendulum.\n        \"\"\"\n        return OrderedDict(\n            sorted(\n                {\n                    \"theta1\": self.theta1,\n                    \"theta2\": self.theta2,\n                    \"z1\": self.z1,\n                    \"z2\": self.z2,\n                    \"m1\": self.m1,\n                    \"m2\": self.m2,\n                    \"l1\": self.l1,\n                    \"l2\": self.l2,\n                    \"g\": self.g,\n                }.items(),\n            ),\n        )\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the double pendulum.\n\n        Returns:\n            list[float]: The initial state of the double pendulum.\n        \"\"\"\n        return [self.theta1, self.z1, self.theta2, self.z2]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return the equation of motion of the double pendulum.\n\n        Args:\n            initial_state (list[float]): The initial state of the double pendulum.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float, float]: The equation of motion of the double\n                pendulum.\n        \"\"\"\n        theta1, z1, theta2, z2 = initial_state\n        c, s = np.cos(theta1 - theta2), np.sin(theta1 - theta2)\n\n        theta1_dot = z1\n        z1_dot = (\n            (\n                self.m2 * self.g * np.sin(theta2) * c\n                - self.m2 * s * (self.l1 * z1**2 * c + self.l2 * z2**2)\n                - (self.m1 + self.m2) * self.g * np.sin(theta1)\n            )\n            / self.l1\n            / (self.m1 + self.m2 * s**2)\n        )\n        theta2_dot = z2\n        z2_dot = (\n            (\n                (self.m1 + self.m2)\n                * (\n                    self.l1 * z1**2 * s\n                    - self.g * np.sin(theta2)\n                    + self.g * np.sin(theta1) * c\n                )\n                + self.m2 * self.l2 * z2**2 * s * c\n            )\n            / self.l2\n            / (self.m1 + self.m2 * s**2)\n        )\n        return theta1_dot, z1_dot, theta2_dot, z2_dot\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the double pendulum.\n\n        Returns:\n            UniversalArrayTuple: The position of the double pendulum.\n        \"\"\"\n        y = self.solve()\n        x1 = self.l1 * np.sin(y[:, 0])\n        y1 = -self.l1 * np.cos(y[:, 0])\n        x2 = x1 + self.l2 * np.sin(y[:, 2])\n        y2 = y1 - self.l2 * np.cos(y[:, 2])\n\n        return x1, y1, x2, y2\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the double pendulum.\n\n        Returns:\n            UniversalArrayTuple: The velocity of the double pendulum.\n        \"\"\"\n        y = self.solve()\n        vx1 = self.l1 * np.sin(y[:, 1])\n        vy1 = -self.l1 * np.cos(y[:, 1])\n        vx2 = vx1 + self.l2 * np.sin(y[:, 3])\n        vy2 = vy1 - self.l2 * np.cos(y[:, 3])\n\n        return vx1, vy1, vx2, vy2\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/chaotic/oscillators/#magnetic-pendulum","title":"Magnetic Pendulum","text":"<p>Magnetic Pendulum differential equation.</p> <p>The magnetic pendulum is an intriguing physical system that exhibits chaotic behavior when subjected to magnetic fields. It consists of a pendulum bob influenced by the magnetic fields of several surrounding magnets. The motion of the pendulum bob is affected by these magnetic fields, and the chaotic behavior is further enhanced by the presence of magnets with both north and south poles.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import MagneticPendulum\n&gt;&gt;&gt; pendulum = MagneticPendulum(np.linspace(0, 2.5, 500))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; magnet_x, magnet_y, _ = zip(*pendulum.magnets, strict=True)\n&gt;&gt;&gt; _ = ax.scatter(magnet_x, magnet_y, marker=\"x\")\n&gt;&gt;&gt; scat = ax.scatter([], [], cmap=\"viridis\", s=10)\n&gt;&gt;&gt; (line,) = ax.plot([], [], linestyle=\"dashed\", color=\"grey\", alpha=0.6)\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; def init():\n...     scat.set_offsets([])\n...     line.set_data([], [])\n...     return scat, line\n&gt;&gt;&gt; def update(frame):\n...     start = max(0, frame - 50)\n...     scat.set_offsets(np.c_[x[start:frame], y[start:frame]])\n...     line.set_data(x[:frame], y[:frame])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return scat, line\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=len(t), interval=10, blit=True)\n&gt;&gt;&gt; ani.save('MagneticPendulum.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The magnetic pendulum differential equation is defined as:</p> \\[ \\begin{align*} \\frac{d\\omega_\\theta}{dt} &amp;= -\\frac{g}{l} \\sin(\\theta) + \\frac{1}{m \\cdot l} \\left( f_{mx} \\cos(\\theta) \\cos(\\phi) + f_{my} \\cos(\\theta) \\sin(\\phi) + f_{mz} \\sin(\\theta) \\right), \\\\ \\frac{d\\omega_\\phi}{dt} &amp;= \\frac{1}{m \\cdot l \\sin(\\theta)} \\left( f_{mx} \\sin(\\phi) - f_{my} \\cos(\\phi) \\right). \\end{align*} \\] <p>with \\(\\frac{d\\theta}{dt} = \\omega_\\theta\\) and \\(\\frac{d\\phi}{dt} = \\omega_\\phi\\), while components of the magnetic force \\(((f_{mx}, f_{my}, f_{mz}))\\) are calculated as follows:</p> \\[ \\begin{align*} f_{mx} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (x - x_i)}{d_i^3}, \\\\ f_{my} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (y - y_i)}{d_i^3}, \\\\ f_{mz} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot z}{d_i^3}, \\end{align*} \\] <p>with \\(d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2 + z^2}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>l</code> <code>float</code> <p>The length of the pendulum. Defaults to 2.</p> <code>2</code> <code>m</code> <code>float</code> <p>The mass of the pendulum. Defaults to 0.5.</p> <code>0.5</code> <code>x0</code> <code>float</code> <p>The initi`al x-coordinate of the pendulum bob. Defaults to 0.5.</p> <code>0.5</code> <code>y0</code> <code>float</code> <p>The initial y-coordinate of the pendulum bob. Defaults to 0.5.</p> <code>0.5</code> <code>theta</code> <code>float</code> <p>The initial angle theta of the pendulum. Defaults to pi/4.</p> <code>pi / 4</code> <code>phi</code> <code>float</code> <p>The initial angle phi of the pendulum. Defaults to pi/2.</p> <code>pi / 2</code> <code>magnetic_constant</code> <code>float</code> <p>The magnetic constant. Defaults to 1.0e10.</p> <code>10000000000.0</code> <code>magnets</code> <code>list[tuple[float, float, int]]</code> <p>A list of magnets, each defined by a tuple of (x, y, pole). Defaults to None.</p> <code>None</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the magnetic pendulum. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class MagneticPendulum(OscillatorsFuncBase):\n    r\"\"\"Magnetic Pendulum differential equation.\n\n    The magnetic pendulum is an intriguing physical system that exhibits chaotic\n    behavior when subjected to magnetic fields. It consists of a pendulum bob influenced\n    by the magnetic fields of several surrounding magnets. The motion of the pendulum\n    bob is affected by these magnetic fields, and the chaotic behavior is further\n    enhanced by the presence of magnets with both north and south poles.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import MagneticPendulum\n        &gt;&gt;&gt; pendulum = MagneticPendulum(np.linspace(0, 2.5, 500))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; magnet_x, magnet_y, _ = zip(*pendulum.magnets, strict=True)\n        &gt;&gt;&gt; _ = ax.scatter(magnet_x, magnet_y, marker=\"x\")\n        &gt;&gt;&gt; scat = ax.scatter([], [], cmap=\"viridis\", s=10)\n        &gt;&gt;&gt; (line,) = ax.plot([], [], linestyle=\"dashed\", color=\"grey\", alpha=0.6)\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; def init():\n        ...     scat.set_offsets([])\n        ...     line.set_data([], [])\n        ...     return scat, line\n        &gt;&gt;&gt; def update(frame):\n        ...     start = max(0, frame - 50)\n        ...     scat.set_offsets(np.c_[x[start:frame], y[start:frame]])\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return scat, line\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=len(t), interval=10, blit=True)\n        &gt;&gt;&gt; ani.save('MagneticPendulum.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The magnetic pendulum differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\frac{d\\omega_\\theta}{dt} &amp;= -\\frac{g}{l} \\sin(\\theta) + \\frac{1}{m \\cdot l}\n        \\left( f_{mx} \\cos(\\theta) \\cos(\\phi) + f_{my} \\cos(\\theta) \\sin(\\phi)\n        + f_{mz} \\sin(\\theta) \\right), \\\\\n        \\frac{d\\omega_\\phi}{dt} &amp;= \\frac{1}{m \\cdot l \\sin(\\theta)} \\left( f_{mx}\n        \\sin(\\phi) - f_{my} \\cos(\\phi) \\right).\n        \\end{align*}\n        $$\n\n        with $\\frac{d\\theta}{dt} = \\omega_\\theta$ and\n        $\\frac{d\\phi}{dt} = \\omega_\\phi$, while components of the magnetic force\n        $((f_{mx}, f_{my}, f_{mz}))$ are calculated as follows:\n\n        $$\n        \\begin{align*}\n        f_{mx} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (x - x_i)}{d_i^3}, \\\\\n        f_{my} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot (y - y_i)}{d_i^3}, \\\\\n        f_{mz} &amp;= \\sum_{i} \\frac{\\mu_0 \\cdot k_i \\cdot z}{d_i^3},\n        \\end{align*}\n        $$\n\n        with $d_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2 + z^2}$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        l (float, optional): The length of the pendulum. Defaults to 2.\n        m (float, optional): The mass of the pendulum. Defaults to 0.5.\n        x0 (float, optional): The initi`al x-coordinate of the pendulum bob. Defaults\n            to 0.5.\n        y0 (float, optional): The initial y-coordinate of the pendulum bob. Defaults\n            to 0.5.\n        theta (float, optional): The initial angle theta of the pendulum. Defaults to\n            pi/4.\n        phi (float, optional): The initial angle phi of the pendulum. Defaults to pi/2.\n        magnetic_constant (float, optional): The magnetic constant. Defaults to 1.0e10.\n        magnets (list[tuple[float, float, int]], optional): A list of magnets, each\n            defined by a tuple of (x, y, pole). Defaults to None.\n        velocity (bool, optional): Whether to return the velocity of the magnetic\n            pendulum. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        l: float = 2,  # noqa: E741\n        m: float = 0.5,\n        x0: float = 0.5,\n        y0: float = 0.5,\n        theta: float = pi / 4,\n        phi: float = pi / 2,\n        magnetic_constant: float = 1.0e10,\n        magnets: list[tuple[float, float, int]] | None = None,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.l = l\n        self.m = m\n        self.x0 = x0\n        self.y0 = y0\n        self.theta = theta\n        self.phi = phi\n        self.magnetic_constant = magnetic_constant\n        self.magnets: list[tuple[float, float, int]] = (\n            magnets\n            if magnets is not None\n            else [\n                (1.0, 1.0, +1),\n                (-1.0, 1.0, +1),\n                (-1.0, -1.0, +1),\n                (1.0, -1.0, +1),\n                (0.5, 0.5, -1),\n                (-0.5, 0.5, -1),\n                (-0.5, -0.5, -1),\n                (0.5, -0.5, -1),\n            ]\n        )\n\n    @property\n    def __initial_configuration__(\n        self,\n    ) -&gt; dict[str, float | list[tuple[float, float, int]]]:\n        \"\"\"Return the initial configuration of the pendulum.\"\"\"\n        return {\n            \"l\": self.l,\n            \"m\": self.m,\n            \"x0\": self.x0,\n            \"y0\": self.y0,\n            \"theta\": self.theta,\n            \"phi\": self.phi,\n            \"magnetic_constant\": self.magnetic_constant,\n            \"magnets\": self.magnets,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the pendulum.\"\"\"\n        return [self.theta, self.phi, self.x0, self.y0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Return the equation of motion of the magnetic pendulum.\n\n        Args:\n            initial_state (list[float]): The initial state of the magnetic pendulum.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float, float]: The equation of motion of the magnetic\n                pendulum.\n        \"\"\"\n        theta, phi, omega_theta, omega_phi = initial_state\n        x = self.l * np.sin(theta) * np.cos(phi)\n        y = self.l * np.sin(theta) * np.sin(phi)\n        z = -self.l * np.cos(theta)\n        f_mx, f_my, f_mz = self.magnetic_force(x, y, z)\n\n        dtheta_dt = omega_theta\n        dphi_dt = omega_phi\n        domega_theta_dt = -(g / self.l) * np.sin(theta) + (\n            f_mx * np.cos(theta) * np.cos(phi)\n            + f_my * np.cos(theta) * np.sin(phi)\n            + f_mz * np.sin(theta)\n        ) / (self.m * self.l)\n        domega_phi_dt = (f_mx * np.sin(phi) - f_my * np.cos(phi)) / (\n            self.m * self.l * np.sin(theta)\n        )\n\n        return dtheta_dt, dphi_dt, domega_theta_dt, domega_phi_dt\n\n    def magnetic_force(\n        self,\n        x: UniversalArray,\n        y: UniversalArray,\n        z: UniversalArray,\n    ) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the magnetic force on the pendulum bob.\n\n        Args:\n            x (UniversalArray): The x-coordinate of the pendulum bob.\n            y (UniversalArray): The y-coordinate of the pendulum bob.\n            z (UniversalArray): The z-coordinate of the pendulum bob.\n\n        Returns:\n            UniversalArrayTuple: The magnetic force on the pendulum bob.\n        \"\"\"\n        f_mx, f_my, f_mz = 0.0, 0.0, 0.0\n        for x_m, y_m, pole in self.magnets:\n            d = np.sqrt((x - x_m) ** 2 + (y - y_m) ** 2 + z**2)\n            if d != 0:\n                force_magnitude = self.magnetic_constant * mu_0 * pole / d**2\n                f_mx += force_magnitude * (x - x_m) / d\n                f_my += force_magnitude * (y - y_m) / d\n                f_mz += force_magnitude * z / d\n        return f_mx, f_my, f_mz\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the 3D position of the pendulum bob.\"\"\"\n        y = self.solve()\n        x1 = self.l * np.sin(y[:, 0]) * np.cos(y[:, 1])\n        y1 = self.l * np.sin(y[:, 0]) * np.sin(y[:, 1])\n        z1 = -self.l * np.cos(y[:, 0])\n        return x1, y1, z1\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Compute the 3D velocity of the pendulum bob.\"\"\"\n        y = self.solve()\n        vx = self.l * y[:, 2] * np.cos(y[:, 0]) * np.cos(y[:, 1])\n        vy = self.l * y[:, 2] * np.sin(y[:, 0]) * np.sin(y[:, 1])\n        vz = self.l * y[:, 2] * np.sin(y[:, 0])\n        return vx, vy, vz\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/chaotic/oscillators/#lorenz-attractor","title":"Lorenz Attractor","text":"<p>Lorenz Attractor differential equation.</p> <p>The Lorenz attractor is a set of differential equations that exhibit chaotic behavior. The Lorenz attractor consists of three coupled differential equations that describe the motion of a system in a simplified model of atmospheric convection.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import LorenzAttractor\n&gt;&gt;&gt; pendulum = LorenzAttractor(np.linspace(0, 20, 1000))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     _ = ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('LorenzAttractor.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Lorenz attractor differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= \\sigma (y - x), \\\\ \\dot{y} &amp;= x (\\rho - z) - y, \\\\ \\dot{z} &amp;= x y - \\beta z. \\end{align*} \\] <p>with the parameters of the system are as follows: $ sigma$ is the Prandtl number, which describes the ratio of momentum diffusivity to thermal diffusivity, while  rho $ is the Rayleigh number, which describes the difference in temperature between the top and bottom of the fluid layer. Finally, the $ beta $ is a geometric factor related to the physical dimensions of the system.</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>rho</code> <code>float</code> <p>The rho parameter of the Lorenz attractor. Defaults to 28.0.</p> <code>28.0</code> <code>sigma</code> <code>float</code> <p>The sigma parameter of the Lorenz attractor. Defaults to 10.0.</p> <code>10.0</code> <code>beta</code> <code>float</code> <p>The beta parameter of the Lorenz attractor. Defaults to 8/3.</p> <code>8 / 3</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of the Lorenz attractor. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class LorenzAttractor(OscillatorsFunc3D):\n    r\"\"\"Lorenz Attractor differential equation.\n\n    The Lorenz attractor is a set of differential equations that exhibit chaotic\n    behavior. The Lorenz attractor consists of three coupled differential\n    equations that describe the motion of a system in a simplified model of atmospheric\n    convection.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import LorenzAttractor\n        &gt;&gt;&gt; pendulum = LorenzAttractor(np.linspace(0, 20, 1000))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('LorenzAttractor.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Lorenz attractor differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= \\sigma (y - x), \\\\\n        \\dot{y} &amp;= x (\\rho - z) - y, \\\\\n        \\dot{z} &amp;= x y - \\beta z.\n        \\end{align*}\n        $$\n\n        with the parameters of the system are as follows: $ \\sigma$ is the Prandtl\n        number, which describes the ratio of momentum diffusivity to thermal\n        diffusivity, while  \\rho $ is the Rayleigh number, which describes\n        the difference in temperature between the top and bottom of the fluid layer.\n        Finally, the $ \\beta $ is a geometric factor related to the physical dimensions\n        of the system.\n\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        rho (float, optional): The rho parameter of the Lorenz attractor. Defaults to\n            28.0.\n        sigma (float, optional): The sigma parameter of the Lorenz attractor. Defaults\n            to 10.0.\n        beta (float, optional): The beta parameter of the Lorenz attractor. Defaults to\n            8/3.\n        velocity (bool, optional): Whether to return the velocity of the Lorenz\n            attractor. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        rho: float = 28.0,\n        sigma: float = 10.0,\n        beta: float = 8 / 3,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.rho = rho\n        self.sigma = sigma\n        self.beta = beta\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Lorenz attractor.\"\"\"\n        return {\"rho\": self.rho, \"sigma\": self.sigma, \"beta\": self.beta}\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Lorenz attractor.\"\"\"\n        return [1.0, 1.0, 1.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of the Lorenz attractor.\n\n        Args:\n            initial_state (list[float]): The initial state of the Lorenz attractor.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of the Lorenz attractor.\n        \"\"\"\n        x, y, z = initial_state\n        x_dot = self.sigma * (y - x)\n        y_dot = x * (self.rho - z) - y\n        z_dot = x * y - self.beta * z\n        return x_dot, y_dot, z_dot\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/chaotic/oscillators/#rossler-attractor","title":"R\u00f6ssler Attractor","text":"<p>Roessler Attractor differential equation.</p> <p>The Roessler attractor is a set of differential equations that exhibit chaotic behavior. The Roessler attractor consists of three coupled differential equations that describe the motion of a system in a simplified model of atmospheric convection.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import RoesslerAttractor\n&gt;&gt;&gt; pendulum = RoesslerAttractor(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y, z = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     _ = ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('RoesslerAttractor.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Roessler attractor differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= -y - z, \\\\ \\dot{y} &amp;= x + a y, \\\\ \\dot{z} &amp;= b + z (x - c). \\end{align*} \\] Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class RoesslerAttractor(OscillatorsFunc3D):\n    r\"\"\"Roessler Attractor differential equation.\n\n    The Roessler attractor is a set of differential equations that exhibit chaotic\n    behavior. The Roessler attractor consists of three coupled differential equations\n    that describe the motion of a system in a simplified model of atmospheric\n    convection.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import RoesslerAttractor\n        &gt;&gt;&gt; pendulum = RoesslerAttractor(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y, z = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], \"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     _ = ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('RoesslerAttractor.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Roessler attractor differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= -y - z, \\\\\n        \\dot{y} &amp;= x + a y, \\\\\n        \\dot{z} &amp;= b + z (x - c).\n        \\end{align*}\n        $$\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        a (float, optional): The a parameter of the Roessler attractor. Defaults to 0.2.\n        b (float, optional): The b parameter of the Roessler attractor. Defaults to 0.2.\n        c (float, optional): The c parameter of the Roessler attractor. Defaults to 5.7.\n        velocity (bool, optional): Whether to return the velocity of the Roessler\n            attractor. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        a: float = 0.2,\n        b: float = 0.2,\n        c: float = 5.7,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Roessler attractor.\"\"\"\n        return {\"a\": self.a, \"b\": self.b, \"c\": self.c}\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Roessler attractor.\"\"\"\n        return [0.1, 0.0, 0.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of the Roessler attractor.\n\n        Args:\n            initial_state (list[float]): The initial state of the Roessler attractor.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of the Roessler\n                attractor.\n        \"\"\"\n        x, y, z = initial_state\n        x_dot = -y - z\n        y_dot = x + self.a * y\n        z_dot = self.b + z * (x - self.c)\n        return x_dot, y_dot, z_dot\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/chaotic/oscillators/#duffing-oscillator","title":"Duffing Oscillator","text":"<p>Duffing Oscillator differential equation.</p> <p>The Duffing oscillator is a simple physical system that exhibits chaotic behavior. The Duffing oscillator consists of a mass attached to a spring and a damper. The motion of the mass is influenced by the spring constant, the damping coefficient, and the nonlinearity of the system. The Duffing oscillator exhibits chaotic behavior when the nonlinearity of the system is increased.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import DuffingOscillator\n&gt;&gt;&gt; pendulum = DuffingOscillator(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y = pendulum.to_position\n&gt;&gt;&gt; t = pendulum.t\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; (line,) = ax.plot([], [], lw=1, alpha=0.6)\n&gt;&gt;&gt; (dots,) = ax.plot([], [], \"ro\", markersize=2)\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     dots.set_data([], [])\n...     _ = ax.set_title(\"\")\n...     return line, dots\n&gt;&gt;&gt; def update(frame: int) -&gt; Tuple[Line2D, Line2D]:\n...     line.set_data(x[:frame], y[:frame])\n...     dots.set_data(x[:frame], y[:frame])\n...     ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n...     return line, dots\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('DuffingOscillator.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>The Duffing oscillator differential equation is defined as:</p> \\[ \\begin{align*} \\ddot{x} + \\delta \\dot{x} + \\alpha x + \\beta x^3 &amp;= \\gamma \\cos(\\omega t), \\\\ \\dot{x} &amp;= y. \\end{align*} \\] Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class DuffingOscillator(OscillatorsFunc2D):\n    r\"\"\"Duffing Oscillator differential equation.\n\n    The Duffing oscillator is a simple physical system that exhibits chaotic behavior.\n    The Duffing oscillator consists of a mass attached to\n    a spring and a damper. The motion of the mass is influenced by the spring constant,\n    the damping coefficient, and the nonlinearity of the system. The Duffing oscillator\n    exhibits chaotic behavior when the nonlinearity of the system is increased.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import DuffingOscillator\n        &gt;&gt;&gt; pendulum = DuffingOscillator(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y = pendulum.to_position\n        &gt;&gt;&gt; t = pendulum.t\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; (line,) = ax.plot([], [], lw=1, alpha=0.6)\n        &gt;&gt;&gt; (dots,) = ax.plot([], [], \"ro\", markersize=2)\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     dots.set_data([], [])\n        ...     _ = ax.set_title(\"\")\n        ...     return line, dots\n        &gt;&gt;&gt; def update(frame: int) -&gt; Tuple[Line2D, Line2D]:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     dots.set_data(x[:frame], y[:frame])\n        ...     ax.set_title(f\"t = {t[frame]:.2f} seconds\")\n        ...     return line, dots\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('DuffingOscillator.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        The Duffing oscillator differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\ddot{x} + \\delta \\dot{x} + \\alpha x + \\beta x^3 &amp;= \\gamma \\cos(\\omega t), \\\\\n        \\dot{x} &amp;= y.\n        \\end{align*}\n        $$\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        alpha (float, optional): The alpha parameter of the Duffing oscillator.\n            Defaults to -1.0.\n        beta (float, optional): The beta parameter of the Duffing oscillator.\n            Defaults to 1.0.\n        delta (float, optional): The delta parameter of the Duffing oscillator.\n            Defaults to 0.2.\n        gamma (float, optional): The gamma parameter of the Duffing oscillator.\n            Defaults to 0.3.\n        omega (float, optional): The omega parameter of the Duffing oscillator.\n            Defaults to 1.2.\n        velocity (bool, optional): Whether to return the velocity of the Duffing\n            oscillator. Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        time_format: str = \"seconds\",\n        alpha: float = -1.0,\n        beta: float = 1.0,\n        delta: float = 0.2,\n        gamma: float = 0.3,\n        omega: float = 1.2,\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n        self.alpha = alpha\n        self.beta = beta\n        self.delta = delta\n        self.gamma = gamma\n        self.omega = omega\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of the Duffing oscillator.\"\"\"\n        return {\n            \"alpha\": self.alpha,\n            \"beta\": self.beta,\n            \"delta\": self.delta,\n            \"gamma\": self.gamma,\n            \"omega\": self.omega,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of the Duffing oscillator.\"\"\"\n        return [0.0, 1.0]\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,\n    ) -&gt; tuple[float, float]:\n        \"\"\"Return the equation of motion of the Duffing oscillator.\n\n        Args:\n            initial_state (list[float]): The initial state of the Duffing oscillator.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float]: The equation of motion of the Duffing oscillator.\n        \"\"\"\n        x, y = initial_state\n        x_dot = y\n        y_dot = (\n            self.gamma * np.cos(self.omega * t)\n            - self.alpha * x\n            - self.beta * x**3\n            - self.delta * y\n        )\n        return x_dot, y_dot\n\n    @property\n    def to_position(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the position of the Duffing oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 0], y[:, 1]\n\n    @property\n    def to_velocity(self) -&gt; UniversalArrayTuple:\n        \"\"\"Return the velocity of the Duffing oscillator.\"\"\"\n        y = self.solve()\n        return y[:, 2], y[:, 3]\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/chaotic/oscillators/#chuas-circuit","title":"Chua's Circuit","text":"<p>Chua's Circuit differential equation.</p> <p>Chua's circuit is a simple physical system that exhibits chaotic behavior. It consists of a set of nonlinear differential equations that describe the evolution of the system's state over time. The behavior of the system is influenced by its nonlinear components and the values of its circuit elements.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n&gt;&gt;&gt; from umf.functions.chaotic.oscillators import ChuaSCircuit\n&gt;&gt;&gt; circuit = ChuaSCircuit(np.linspace(0, 100, 1000))\n&gt;&gt;&gt; x, y, z = circuit.to_position\n&gt;&gt;&gt; t = circuit.t\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(projection=\"3d\")\n&gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n&gt;&gt;&gt; (point,) = ax.plot([], [], [], marker=\"o\", markersize=2, color=\"red\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n&gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n&gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n&gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n&gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n&gt;&gt;&gt; def init() -&gt; tuple:\n...     line.set_data([], [])\n...     line.set_3d_properties([])\n...     point.set_data([], [])\n...     point.set_3d_properties([])\n...     ax.set_title(\"\")\n...     return line, point\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     line.set_data(x[:frame], y[:frame])\n...     line.set_3d_properties(z[:frame])\n...     point.set_data([x[frame]], [y[frame]])\n...     point.set_3d_properties([z[frame]])\n...     ax.set_title(f\"Current Time: {t[frame]:.2f} seconds\")\n...     return line, point\n&gt;&gt;&gt; ani = FuncAnimation(\n...     fig=fig, func=update,\n...     init_func=init,\n...     frames=len(t),\n...     interval=10,\n...     blit=True\n... )\n&gt;&gt;&gt; ani.save('ChuaSCircuit.gif', writer=PillowWriter(fps=10))\n</code></pre> Notes <p>Chua's Circuit differential equation is defined as:</p> \\[ \\begin{align*} \\dot{x} &amp;= \\alpha \\left( y - x - m_0 x + 0.5 \\left( \\lvert x + 1 \\rvert - \\lvert x - 1 \\rvert \\right) \\right), \\\\ \\dot{y} &amp;= x - y + z, \\\\ \\dot{z} &amp;= -\\beta y. \\end{align*} \\] <p>with \\(\\alpha\\) as a parameter related to the system's linear components, \\(\\beta\\) as a parameter related to the system's damping factor, and \\(m_0\\) as a parameter that determines the slope of the piecewise-linear function within the interval \\(([-1, 1])\\).</p> <p>Parameters:</p> Name Type Description Default <code>*time_points</code> <code>UniversalArray</code> <p>The array of time points at which the oscillator's state is evaluated.</p> required <code>time_format</code> <code>str</code> <p>The time format. Defaults to \"seconds\".</p> <code>'seconds'</code> <code>alpha</code> <code>float</code> <p>The alpha parameter of Chua's circuit. Defaults to 15.6.</p> <code>15.6</code> <code>beta</code> <code>float</code> <p>The beta parameter of Chua's circuit. Defaults to 28.0.</p> <code>28.0</code> <code>m0</code> <code>float</code> <p>The m0 parameter of Chua's circuit. Defaults to -1.143.</p> <code>-1.143</code> <code>m1</code> <code>float</code> <p>The m1 parameter of Chua's circuit. Defaults to -0.714.</p> <code>-0.714</code> <code>R</code> <code>float</code> <p>The resistance of Chua's circuit. Defaults to 220.0.</p> <code>220.0</code> <code>C1</code> <code>float</code> <p>The capacitance of Chua's circuit. Defaults to 1.0e-6.</p> <code>1e-06</code> <code>C2</code> <code>float</code> <p>The capacitance of Chua's circuit. Defaults to 1.0e-6.</p> <code>1e-06</code> <code>L</code> <code>float</code> <p>The inductance of Chua's circuit. Defaults to 1.0e-3.</p> <code>0.001</code> <code>velocity</code> <code>bool</code> <p>Whether to return the velocity of Chua's circuit. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/chaotic/oscillators.py</code> Python<pre><code>class ChuaSCircuit(OscillatorsFunc3D):\n    r\"\"\"Chua's Circuit differential equation.\n\n    Chua's circuit is a simple physical system that exhibits chaotic behavior. It\n    consists of a set of nonlinear differential equations that describe the evolution\n    of the system's state over time. The behavior of the system is influenced by its\n    nonlinear components and the values of its circuit elements.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation, PillowWriter\n        &gt;&gt;&gt; from umf.functions.chaotic.oscillators import ChuaSCircuit\n        &gt;&gt;&gt; circuit = ChuaSCircuit(np.linspace(0, 100, 1000))\n        &gt;&gt;&gt; x, y, z = circuit.to_position\n        &gt;&gt;&gt; t = circuit.t\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(projection=\"3d\")\n        &gt;&gt;&gt; (line,) = ax.plot([], [], [], lw=0.5)\n        &gt;&gt;&gt; (point,) = ax.plot([], [], [], marker=\"o\", markersize=2, color=\"red\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"X\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"Y\")\n        &gt;&gt;&gt; _ = ax.set_zlabel(\"Z\")\n        &gt;&gt;&gt; _ = ax.set_xlim(min(x) - 0.5, max(x) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(min(y) - 0.5, max(y) + 0.5)\n        &gt;&gt;&gt; _ = ax.set_zlim(min(z) - 0.5, max(z) + 0.5)\n        &gt;&gt;&gt; def init() -&gt; tuple:\n        ...     line.set_data([], [])\n        ...     line.set_3d_properties([])\n        ...     point.set_data([], [])\n        ...     point.set_3d_properties([])\n        ...     ax.set_title(\"\")\n        ...     return line, point\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     line.set_data(x[:frame], y[:frame])\n        ...     line.set_3d_properties(z[:frame])\n        ...     point.set_data([x[frame]], [y[frame]])\n        ...     point.set_3d_properties([z[frame]])\n        ...     ax.set_title(f\"Current Time: {t[frame]:.2f} seconds\")\n        ...     return line, point\n        &gt;&gt;&gt; ani = FuncAnimation(\n        ...     fig=fig, func=update,\n        ...     init_func=init,\n        ...     frames=len(t),\n        ...     interval=10,\n        ...     blit=True\n        ... )\n        &gt;&gt;&gt; ani.save('ChuaSCircuit.gif', writer=PillowWriter(fps=10))\n\n    Notes:\n        Chua's Circuit differential equation is defined as:\n\n        $$\n        \\begin{align*}\n        \\dot{x} &amp;= \\alpha \\left( y - x - m_0 x + 0.5 \\left( \\lvert x + 1 \\rvert -\n        \\lvert x - 1 \\rvert \\right) \\right), \\\\\n        \\dot{y} &amp;= x - y + z, \\\\\n        \\dot{z} &amp;= -\\beta y.\n        \\end{align*}\n        $$\n\n        with $\\alpha$ as a parameter related to the system's linear components, $\\beta$\n        as a parameter related to the system's damping factor, and $m_0$ as a parameter\n        that determines the slope of the piecewise-linear function within the interval\n        $([-1, 1])$.\n\n    Args:\n        *time_points (UniversalArray): The array of time points at which the\n            oscillator's state is evaluated.\n        time_format (str, optional): The time format. Defaults to \"seconds\".\n        alpha (float, optional): The alpha parameter of Chua's circuit. Defaults to\n            15.6.\n        beta (float, optional): The beta parameter of Chua's circuit. Defaults to 28.0.\n        m0 (float, optional): The m0 parameter of Chua's circuit. Defaults to -1.143.\n        m1 (float, optional): The m1 parameter of Chua's circuit. Defaults to -0.714.\n        R (float, optional): The resistance of Chua's circuit. Defaults to 220.0.\n        C1 (float, optional): The capacitance of Chua's circuit. Defaults to 1.0e-6.\n        C2 (float, optional): The capacitance of Chua's circuit. Defaults to 1.0e-6.\n        L (float, optional): The inductance of Chua's circuit. Defaults to 1.0e-3.\n        velocity (bool, optional): Whether to return the velocity of Chua's circuit.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *t: UniversalArray,\n        alpha: float = 15.6,\n        beta: float = 28.0,\n        m0: float = -1.143,\n        m1: float = -0.714,\n        R: float = 220.0,\n        C1: float = 1.0e-6,\n        C2: float = 1.0e-6,\n        L: float = 1.0e-3,\n        time_format: str = \"seconds\",\n        velocity: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*t, time_format=time_format, velocity=velocity)\n\n        self.alpha = alpha\n        self.beta = beta\n        self.m0 = m0\n        self.m1 = m1\n        self.R = R\n        self.C1 = C1\n        self.C2 = C2\n        self.L = L\n\n    @property\n    def __initial_configuration__(self) -&gt; dict[str, float]:\n        \"\"\"Return the initial configuration of Chua's circuit.\"\"\"\n        return {\n            \"alpha\": self.alpha,\n            \"beta\": self.beta,\n            \"m0\": self.m0,\n            \"m1\": self.m1,\n            \"R\": self.R,\n            \"C1\": self.C1,\n            \"C2\": self.C2,\n            \"L\": self.L,\n        }\n\n    @property\n    def initial_state(self) -&gt; list[float]:\n        \"\"\"Return the initial state of Chua's circuit.\"\"\"\n        return [0.1, 0.0, 0.0]  # Small perturbation from zero\n\n    def equation_of_motion(\n        self,\n        initial_state: list[float],\n        t: UniversalArray,  # noqa: ARG002\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Return the equation of motion of Chua's circuit.\n\n        Args:\n            initial_state (list[float]): The initial state of Chua's circuit.\n            t (UniversalArray): The time array.\n\n        Returns:\n            tuple[float, float, float]: The equation of motion of Chua's circuit.\n        \"\"\"\n        x, y, z = initial_state\n\n        # Nonlinear function of Chua's circuit\n        h = self.m1 * x + 0.5 * (self.m0 - self.m1) * (abs(x + 1) - abs(x - 1))\n\n        # Chua's Circuit differential equations\n        x_dot = self.alpha * (y - x - h)\n        y_dot = x - y + z\n        z_dot = -self.beta * y\n        return x_dot, y_dot, z_dot\n</code></pre> Phase Space Trajectory"},{"location":"modules/functions/distributions/continuous_2pi_interval/","title":"2\ud835\uded1 Interval","text":""},{"location":"modules/functions/distributions/continuous_2pi_interval/#von-mises-distribution","title":"Von Mises Distribution","text":"<p>von Mises distribution.</p> <p>The von Mises distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... VonMisesDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n&gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n&gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The von Mises distribution is defined as follows for probability density:</p> \\[ f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class VonMisesDistribution(Continuous2PiInterval):\n    r\"\"\"von Mises distribution.\n\n    The von Mises distribution is a continuous probability distribution on the\n    circle. It is a close approximation to the wrapped normal distribution,\n    which is the circular analogue of the normal distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... VonMisesDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n        &gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n        &gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n\n\n    Notes:\n        The von Mises distribution is defined as follows for probability density:\n\n        $$\n        f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n        $$\n\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.\n\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the von Mises distribution.\"\"\"\n        return np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n            2 * np.pi * special.i0(self.kappa)\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the von Mises distribution.\"\"\"\n\n        def _mode() -&gt; float | tuple[float, float]:\n            \"\"\"Mode of the von Mises distribution.\"\"\"\n            return self.mu\n\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=1 - special.i1(self.kappa) / special.i0(self.kappa),\n            mode=_mode(),\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_2pi_interval/#wrapped-asymmetric-laplace-distribution","title":"Wrapped Asymmetric Laplace Distribution","text":"<p>Wrapped asymmetric Laplace distribution.</p> <p>The wrapped (asymmetric) Laplace distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... WrappedAsymLaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.5,\n... kappa=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.7,\n... kappa=0.7,\n... ).__eval__\n&gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.9,\n... kappa=0.9,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The wrapped Laplace distribution is defined as follows for probability density:</p> \\[ \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;= \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt] &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases} {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }} \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.<sup>1</sup></p> <ol> <li> <p>Wrapped asymmetric Laplace distribution. (2022, January 24). In Wikipedia. en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class WrappedAsymLaplaceDistribution(Continuous2PiInterval):\n    r\"\"\"Wrapped asymmetric Laplace distribution.\n\n    The wrapped (asymmetric) Laplace distribution is a continuous probability\n    distribution on the circle. It is a close approximation to the wrapped normal\n    distribution, which is the circular analogue of the normal distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... WrappedAsymLaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.5,\n        ... kappa=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.7,\n        ... kappa=0.7,\n        ... ).__eval__\n        &gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.9,\n        ... kappa=0.9,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The wrapped Laplace distribution is defined as follows for probability\n        density:\n\n        $$\n        \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;=\n        \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt]\n        &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases}\n        {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }}\n        \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned}\n        $$\n\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.[^1]\n\n        [^1]: Wrapped asymmetric Laplace distribution. (2022, January 24).\n            _In Wikipedia._\n            https://en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution\n\n    Args:\n        x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        lambda_: The scale parameter of the distribution.\n        kappa: The concentration of the distribution around mu.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        lambda_: float = 1,\n        kappa: float = 1,\n    ) -&gt; None:\n        r\"\"\"Initialize a wrapped Laplace distribution.\n\n        Args:\n            *x (UniversalArray): The points at which to evaluate the distribution.\n            mu (float): The mean of the distribution. Defaults to 0.\n            lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n            kappa (float): The concentration of the distribution around mu.\n                Defaults to 1.\n        \"\"\"\n        super().__init__(*x, mu=mu, kappa=kappa)\n        self.lambda_ = lambda_\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\n        part_1 = (\n            self.kappa\n            * self.lambda_\n            / (self.kappa**2 + 1)\n            * (\n                np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n                / (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n                - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n                / (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n            )\n        )\n        part_2 = (\n            self.kappa\n            * self.lambda_\n            / (self.kappa**2 + 1)\n            * (\n                np.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n                / (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n                - np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n                / (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n            )\n        )\n\n        # Combine the two parts\n        return np.where(self._x &gt;= self.mu, part_1, part_2)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the wrapped Laplace distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=1\n            - self.lambda_**2\n            / np.sqrt(\n                (1 / self.kappa**2 + self.lambda_**2)\n                * (self.kappa**2 + self.lambda_**2),\n            ),\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_bounded_interval/","title":"Bounded Interval","text":""},{"location":"modules/functions/distributions/continuous_bounded_interval/#kumaraswamy-distribution","title":"Kumaraswamy Distribution","text":"<p>Kumaraswamy distribution.</p> <p>The Kumaraswamy distribution is a continuous probability distribution with support on the interval [0, 1]. It is a generalization of the beta distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n&gt;&gt;&gt; plt.close()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"KumaraswamyDistribution-cml.png\",\n... dpi=300,\n... transparent=True\n... )\n</code></pre> Notes <p>The Kumaraswamy distribution is generally defined for the PDF as:</p> \\[ f(x; a, b) = abx^{a-1}(1-x^a)^{b-1} \\] <p>where \\(a, b &gt; 0\\) and \\(0 \\leq x \\leq 1\\). The CDF is given by:</p> \\[ F(x; a, b) = 1 - (1 - x^a)^b \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>a</code> <code>float</code> <p>The first shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>b</code> <code>float</code> <p>The second shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>class KumaraswamyDistribution(ContinuousBoundedInterval):\n    r\"\"\"Kumaraswamy distribution.\n\n    The Kumaraswamy distribution is a continuous probability distribution with\n    support on the interval [0, 1]. It is a generalization of the beta\n    distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; plt.close()\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"KumaraswamyDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True\n        ... )\n\n    Notes:\n        The Kumaraswamy distribution is generally defined for the PDF as:\n\n        $$\n        f(x; a, b) = abx^{a-1}(1-x^a)^{b-1}\n        $$\n\n        where $a, b &gt; 0$ and $0 \\leq x \\leq 1$. The CDF is given by:\n\n        $$\n        F(x; a, b) = 1 - (1 - x^a)^b\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        a (float): The first shape parameter, which must be positive. Default is 1.\n        b (float): The second shape parameter, which must be positive. Default is 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        a: float = 1,\n        b: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the Kumaraswamy distribution.\"\"\"\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotAPositiveNumberError(msg, a)\n        if b &lt;= 0:\n            msg = \"b\"\n            raise NotAPositiveNumberError(msg, b)\n        super().__init__(*x, start=0, end=1, cumulative=cumulative)\n        self.a = a\n        self.b = b\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n\n        Returns:\n            UniversalArray: The value of the probability density function of the\n                Kumaraswamy distribution.\n        \"\"\"\n        return (\n            self.a\n            * self.b\n            * self._x ** (self.a - 1)\n            * (1 - self._x**self.a) ** (self.b - 1)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n\n        Returns:\n            UniversalArray: The value of the cumulative distribution function of the\n                Kumaraswamy distribution.\n        \"\"\"  # noqa: E501\n        return 1 - (1 - self._x**self.a) ** self.b\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Calculate the summary statistics of the Kumaraswamy distribution.\n\n        Returns:\n            SummaryStatisticsAPI: The summary statistics of the Kumaraswamy\n                distribution.\n        \"\"\"\n        mode = (\n            (self.a - 1) / (self.a + self.b - 2) if self.a &gt; 1 and self.b &gt; 1 else None\n        )\n        mean = (self.b * gamma(1 + 1 / self.a) * gamma(self.a - 1)) / (\n            self.a * gamma(self.a + self.b)\n        )\n        return SummaryStatisticsAPI(\n            mean=mean,\n            mode=mode,\n            variance=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/","title":"Semi Infinite Interval","text":""},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#rayleigh-distribution","title":"Rayleigh Distribution","text":"<p>Rayleigh distribution.</p> <p>The Rayleigh distribution is a continuous probability distribution that is commonly used in statistics to model the magnitude of a vector whose components are independent and identically distributed Gaussian random variables with zero mean. It is also used to describe the distribution of the magnitude of the sum of independent, identically distributed Gaussian random variables with zero mean and equal variance.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rayleigh distribution is generally defined for the PDF as:</p> \\[ f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>where \\(\\sigma\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class RayleighDistribution(SemiContinuousWSigma):\n    r\"\"\"Rayleigh distribution.\n\n    The Rayleigh distribution is a continuous probability distribution that is commonly\n    used in statistics to model the magnitude of a vector whose components are\n    independent and identically distributed Gaussian random variables with zero mean.\n    It is also used to describe the distribution of the magnitude of the sum of\n    independent, identically distributed Gaussian random variables with zero mean\n    and equal variance.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rayleigh distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n\n        where $\\sigma$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return self._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.sqrt(np.pi / 2) * self.sigma,\n            variance=(4 - np.pi) / 2 * self.sigma**2,\n            mode=self.sigma,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#weibull-distribution","title":"Weibull Distribution","text":"<p>Weibull distribution.</p> <p>The Weibull distribution is a continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The Weibull distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n... x,\n... lambda_=1,\n... k=0.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n... x,\n... lambda_=2,\n... k=1.0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n... x,\n... lambda_=3,\n... k=1.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Weibull distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}     \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>where \\(\\lambda\\) is the scale parameter and \\(k\\) is the shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> required <code>k</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class WeibullDistribution(SemiContinuous):\n    r\"\"\"Weibull distribution.\n\n    The Weibull distribution is a continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The Weibull distribution has\n    applications in various fields, such as finance, biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n        ... x,\n        ... lambda_=1,\n        ... k=0.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n        ... x,\n        ... lambda_=2,\n        ... k=1.0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n        ... x,\n        ... lambda_=3,\n        ... k=1.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Weibull distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}\n            \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n\n        where $\\lambda$ is the scale parameter and $k$ is the shape parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda (float): Scale parameter. Defaults to 1.\n        k (float): Shape parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        lambda_: float = 1.0,\n        k: float = 1.0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if lambda_ &lt; 0:\n            msg = \"lambda_\"\n            raise NotAPositiveNumberError(msg, lambda_)\n        if k &lt;= 0:\n            msg = \"k\"\n            raise NotLargerThanZeroError(msg, k)\n\n        super().__init__(*x, cumulative=cumulative)\n        self.lambda_ = lambda_\n        self.k = k\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.k\n            / self.lambda_\n            * (self._x / self.lambda_) ** (self.k - 1)\n            * np.exp(-((self._x / self.lambda_) ** self.k))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.lambda_ * gamma(1 + 1 / self.k),\n            variance=self.lambda_**2\n            * (gamma(1 + 2 / self.k) - gamma(1 + 1 / self.k) ** 2),\n            mode=self.lambda_ * (self.k - 1) ** (1 / self.k) if self.k &gt; 1 else 0,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#log-normal-distribution","title":"Log-Normal Distribution","text":"<p>Log-normal distribution.</p> <p>The log-normal distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The log-normal distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The log-normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class LogNormalDistribution(SemiContinuousWSigma):\n    r\"\"\"Log-normal distribution.\n\n    The log-normal distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The log-normal distribution has\n    applications in various fields, such as finance, biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The log-normal distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self._x * self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.exp(self.mu + self.sigma**2 / 2),\n            variance=(np.exp(self.sigma**2) - 1) * np.exp(2 * self.mu + self.sigma**2),\n            mode=np.exp(self.mu - self.sigma**2),\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#chi-squared-distribution","title":"Chi-Squared Distribution","text":"<p>Chi-square distribution.</p> <p>The chi-square distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the sum of the squares of independent standard normal random variables. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The chi-square distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n... x,\n... k=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n... x,\n... k=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n... x,\n... k=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The chi-square distribution is generally defined for the PDF as:</p> \\[ f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2) \\] <p>and for the CDF as:</p> \\[ F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2) \\] <p>where \\(k\\) is the degrees of freedom.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>k</code> <code>float</code> <p>Degrees of freedom. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class ChiSquaredDistribution(SemiContinuous):\n    r\"\"\"Chi-square distribution.\n\n    The chi-square distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the sum of the squares of\n    independent standard normal random variables. It is a transformation of the normal\n    distribution, where the logarithm of the variable is normally distributed. The\n    chi-square distribution has applications in various fields, such as finance,\n    biology, and engineering.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n        ... x,\n        ... k=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n        ... x,\n        ... k=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n        ... x,\n        ... k=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The chi-square distribution is generally defined for the PDF as:\n\n        $$\n        f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2)\n        $$\n\n        where $k$ is the degrees of freedom.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        k (float): Degrees of freedom. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        k: float = 1.0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if k &lt;= 0:\n            raise NotLargerThanZeroError(k)\n\n        super().__init__(*x, cumulative=cumulative)\n        self.k = k\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (2 ** (self.k / 2) * gamma(self.k / 2))\n            * self._x ** (self.k / 2 - 1)\n            * np.exp(-self._x / 2)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.k,\n            variance=2 * self.k,\n            mode=self.k - 2 if self.k &gt; 2 else 0,  # noqa: PLR2004\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#dagum-distribution","title":"Dagum Distribution","text":"<p>Dagum distribution.</p> <p>The Dagum distribution is a continuous probability distribution that is defined on the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is characterized by its shape, scale, and shape parameters. The Dagum distribution is used in various fields, including economics, finance, and engineering, to model data that is non-negative and skewed to the right. It has a probability density function (PDF) and a cumulative distribution function (CDF) that can be used to calculate various statistical measures, such as mean, variance, and mode.</p> Notes <p>The Dagum distribution is generally defined for the PDF as:</p> \\[ f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{(p+1)/p}} \\] <p>and for the CDF as:</p> \\[ F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p} \\] <p>where \\(p\\) is the shape parameter, \\(a\\) is the scale parameter, and \\(b\\) is the shape parameter.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... DagumDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>a</code> <code>float</code> <p>Scale parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>NotLargerThanZeroError</code> <p>If p, a, or b is not larger than 0.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class DagumDistribution(ContinuousPure):\n    r\"\"\"Dagum distribution.\n\n    The Dagum distribution is a continuous probability distribution that is defined on\n    the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is\n    characterized by its shape, scale, and shape parameters. The Dagum distribution is\n    used in various fields, including economics, finance, and engineering, to model\n    data that is non-negative and skewed to the right. It has a probability density\n    function (PDF) and a cumulative distribution function (CDF) that can be used to\n    calculate various statistical measures, such as mean, variance, and mode.\n\n    Notes:\n        The Dagum distribution is generally defined for the PDF as:\n\n        $$\n        f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b}\n        x\\right)^{p}\\right]^{(p+1)/p}}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p}\n        $$\n\n        where $p$ is the shape parameter, $a$ is the scale parameter, and $b$ is the\n        shape parameter.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... DagumDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        p (float): Shape parameter. Must be greater than 0. Defaults to 1.\n        a (float): Scale parameter. Must be greater than 0. Defaults to 1.\n        b (float): Shape parameter. Must be greater than 0. Defaults to 1.\n\n    Raises:\n        NotLargerThanZeroError: If p, a, or b is not larger than 0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        p: float = 1.0,\n        a: float = 1.0,\n        b: float = 1.0,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if p &lt;= 0:\n            msg = \"p\"\n            raise NotLargerThanZeroError(msg, p)\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotLargerThanZeroError(msg, a)\n        if b &lt;= 0:\n            msg = \"b\"\n            raise NotLargerThanZeroError(msg, b)\n        super().__init__(*x)\n        self.p = p\n        self.a = a\n        self.b = b\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.p\n            * self.a**self.p\n            / (\n                self._x ** (self.p + 1)\n                * (1 + (self.a / self.b) ** self.p * self._x**self.p)\n                ** ((self.p + 1) / self.p)\n            )\n        )\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.a\n            * gamma((self.p - 1) / self.p)\n            * gamma((self.p + 1) / self.p)\n            / gamma(self.p / self.p),\n            variance=self.a**2\n            * (\n                gamma((self.p - 2) / self.p)\n                * gamma((self.p + 1) / self.p)\n                / gamma(self.p / self.p)\n                - (\n                    self.a\n                    * gamma((self.p - 1) / self.p)\n                    * gamma((self.p + 1) / self.p)\n                    / gamma(self.p / self.p)\n                )\n                ** 2\n            ),\n            mode=self.a\n            * ((self.p / self.b) ** (1 / self.p))\n            * ((self.p - 1) / self.p) ** (1 / self.p),\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_variable_support/","title":"Variable Support","text":""},{"location":"modules/functions/distributions/continuous_variable_support/#generalized-extreme-value-distribution","title":"Generalized Extreme-Value Distribution","text":"<p>Generalized extreme value distribution.</p> <p>The generalized extreme value distribution is a family of continuous probability distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet and Weibull families also known as type I, II and III extreme value distributions. The generalized extreme value distribution is also sometimes referred to as the Fisher-Tippett distribution or the extreme value type I distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedExtremeValueDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized extreme value distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right] \\exp \\left[ - \\exp \\left( - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized extreme value distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0.0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedExtremeValueDistribution(ContinuousMixed):\n    r\"\"\"Generalized extreme value distribution.\n\n    The generalized extreme value distribution is a family of continuous probability\n    distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet\n    and Weibull families also known as type I, II and III extreme value distributions.\n    The generalized extreme value distribution is also sometimes referred to as the\n    Fisher-Tippett distribution or the extreme value type I distribution.\n\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedExtremeValueDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n\n    Notes:\n        The generalized extreme value distribution is defined as follows for probability\n        density function:\n\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta\n        \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma}\n        \\right) \\right] \\exp \\left[ - \\exp \\left( -\n        \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n        The generalized extreme value distribution is defined as follows for cumulative\n        distribution function:\n\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x -\n        \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right]\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        zeta (float): Shape parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    @property\n    def t_factor(self) -&gt; UniversalArray:\n        \"\"\"Factor of the t-distribution.\"\"\"\n        if self.zeta == 0:\n            return np.exp(-self._x - self.mu) / self.sigma\n        return np.exp(-((1 + self.zeta * self._x) ** (-1 / self.zeta))) / self.sigma\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\n        return self.t_factor**self.zeta * np.exp(-self.t_factor)\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\n        return np.exp(-self.t_factor)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the gen. extreme value distribution.\"\"\"\n        if self.zeta != 0 and self.zeta &lt; 1:\n            mean = self.mu + self.sigma * (gamma(1 - self.zeta) - 1) / self.zeta\n        elif self.zeta == 0:\n            mean = self.mu + self.sigma * np.euler_gamma\n        else:\n            mean = np.inf\n\n        if self.zeta != 0 and self.zeta &lt; 0.5:  # noqa: PLR2004\n            variance = (\n                self.sigma**2\n                * (gamma(1 - 2 * self.zeta) - gamma(1 - self.zeta) ** 2)\n                / self.zeta**2\n            )\n        elif self.zeta == 0:\n            variance = self.sigma**2 * np.pi**2 / 6\n        else:\n            variance = np.inf\n\n        if self.zeta != 0:\n            mode = self.mu + self.sigma * (1 - self.zeta ** (-1)) ** (-1 / self.zeta)\n        else:\n            mode = self.mu\n        return SummaryStatisticsAPI(\n            mean=mean,\n            variance=variance,\n            mode=mode,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_variable_support/#generalized-pareto-distribution","title":"Generalized Pareto Distribution","text":"<p>Generalized Pareto distribution.</p> <p>The generalized Pareto distribution is a family of continuous probability distributions that includes the exponential, Weibull, and uniform distributions. The generalized Pareto distribution is often used to model the tails of another distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized Pareto distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta - 1} &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized Pareto distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\begin{cases} 1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if } \\zeta \\neq 0 \\\\ 1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedParetoDistribution(ContinuousMixed):\n    r\"\"\"Generalized Pareto distribution.\n\n    The generalized Pareto distribution is a family of continuous probability\n    distributions that includes the exponential, Weibull, and uniform distributions.\n    The generalized Pareto distribution is often used to model the tails of another\n    distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The generalized Pareto distribution is defined as follows for probability\n        density function:\n\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta -\n        1} &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if }\n        \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n        The generalized Pareto distribution is defined as follows for cumulative\n        distribution function:\n\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if }\n        \\zeta \\neq 0 \\\\\n        1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        zeta (float): Shape parameter. Defaults to 0.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        zeta: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the generalized Pareto distribution.\"\"\"\n        if (min_x := np.min(x)) &lt; 0:\n            msg = \"*x\"\n            raise NotAPositiveNumberError(msg, number=float(min_x))\n        super().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\n        if self.zeta == 0:\n            return np.exp(-(self._x - self.mu) / self.sigma)\n        return (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n            -1 / (self.zeta + 1)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\n        if self.zeta == 0:\n            return 1 - np.exp(-(self._x - self.mu) / self.sigma)\n        return 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n            -1 / self.zeta\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the generalized Pareto distribution.\"\"\"\n        SummaryStatisticsAPI(\n            mean=self.mu + self.sigma / (1 - self.zeta) if self.zeta &lt; 1 else np.inf,\n            variance=(\n                self.sigma**2 / (1 - self.zeta) ** 2 / (1 - 2 * self.zeta)\n                if self.zeta &lt; 0.5  # noqa: PLR2004\n                else np.inf\n            ),\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/","title":"Whole Line Support","text":""},{"location":"modules/functions/distributions/continuous_whole_line_support/#generalized-normal-distribution","title":"Generalized Normal Distribution","text":"<p>Generalized normal distribution.</p> <p>The generalized normal distribution is a probability distribution that extends the normal distribution to incorporate an additional shape parameter, allowing for greater flexibility in modeling a wider range of data distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedNormalDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}   \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2} \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha}, \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma \\left(\\frac{1}{\\alpha}\\right)}\\right) \\] <p>where \\(\\alpha\\) is the shape parameter, \\(\\beta\\) is the scale parameter, and \\(\\mu\\) is the location parameter plus \\(\\Gamma\\) as the gamma function. The PDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha, \\beta &gt; 0\\). The CDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha &gt; 0\\) and rquires the unnormalized lower incomplete gamma function.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GeneralizedNormalDistribution(ContinuousWBeta):\n    r\"\"\"Generalized normal distribution.\n\n    The generalized normal distribution is a probability distribution that extends the\n    normal distribution to incorporate an additional shape parameter, allowing for\n    greater flexibility in modeling a wider range of data distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedNormalDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The generalized normal distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}\n          \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2}\n        \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha},\n        \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma\n        \\left(\\frac{1}{\\alpha}\\right)}\\right)\n        $$\n\n        where $\\alpha$ is the shape parameter, $\\beta$ is the scale parameter, and\n        $\\mu$ is the location parameter plus $\\Gamma$ as the gamma function.\n        The PDF is defined for $x \\in \\mathbb{R}$ and $\\alpha, \\beta &gt; 0$.\n        The CDF is defined for $x \\in \\mathbb{R}$ and $\\alpha &gt; 0$ and rquires the\n        unnormalized lower incomplete gamma function.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        alpha (float): Shape parameter. Defaults to 1.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        alpha: float = 1,\n        beta: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if beta &lt; 0:\n            msg = \"beta\"\n            raise NotAPositiveNumberError(msg, beta)\n        if alpha &lt;= 0:\n            msg = \"alpha\"\n            raise NotLargerThanZeroError(msg, alpha)\n\n        super().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            self.beta\n            / (2 * self.alpha * gamma(1.0 / self.beta))\n            * np.exp(-(np.abs((self._x - self.mu) / self.alpha) ** self.beta))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 + np.sign(self._x - self.mu) * (\n            1 / (2 * gamma(1 / self.beta))\n        ) * gammainc(\n            1 / self.beta,\n            np.abs((self._x - self.mu) / self.alpha) ** self.beta,\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.alpha**2 * gamma(3 / self.beta) / gamma(1 / self.beta),\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#gaussian-distribution","title":"Gaussian Distribution","text":"<p>Gaussian distribution.</p> <p>The Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GaussianDistribution(ContinuousWSigma):\n    r\"\"\"Gaussian distribution.\n\n    The Gaussian distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gaussian distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.sigma**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#skew-gaussian-distribution","title":"Skew Gaussian Distribution","text":"<p>Skew Gaussian distribution.</p> <p>The Skew Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions with skewness.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... SkewGaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=0,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=1,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=-1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Skew Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation, and \\(\\alpha\\) is the skewness.</p> <p>The CDF is not available in closed form.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Skewness. Defaults to 0.</p> <code>0</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class SkewGaussianDistribution(ContinuousWSigma):\n    r\"\"\"Skew Gaussian distribution.\n\n    The Skew Gaussian distribution is a continuous probability distribution that is\n    widely used in statistics to describe the normal distributions with skewness.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... SkewGaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=-1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Skew Gaussian distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n        \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right]\n        $$\n\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation, and $\\alpha$ is the\n        skewness.\n\n        The CDF is not available in closed form.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        alpha (float): Skewness. Defaults to 0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        alpha: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / (self.sigma * np.sqrt(2 * np.pi))\n            * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n            * (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=self.sigma**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#laplace-distribution","title":"Laplace Distribution","text":"<p>Laplace distribution.</p> <p>The Laplace distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Laplace distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu) \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right) \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LaplaceDistribution(ContinuousWBeta):\n    r\"\"\"Laplace distribution.\n\n    The Laplace distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Laplace distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu)\n        \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right)\n        $$\n\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return np.array(\n            0.5\n            + 0.5\n            * np.sign(self._x - self.mu)\n            * (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=2 * self.beta**2,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#logistic-distribution","title":"Logistic Distribution","text":"<p>Logistic distribution.</p> <p>The logistic distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Logistic distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)} \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LogisticDistribution(ContinuousWBeta):\n    r\"\"\"Logistic distribution.\n\n    The logistic distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Logistic distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x -\n        \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)}\n        $$\n\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        return np.array(\n            1\n            / self.beta\n            * np.exp(-(self._x - self.mu) / self.beta)\n            / (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu,\n            variance=(np.pi**2 * self.beta**2) / 3,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#voigt-distribution","title":"Voigt Distribution","text":"<p>Voigt distribution.</p> <p>The Voigt distribution is a continuous probability distribution that is widely used in physics and spectroscopy to describe the line shape of spectral lines. It is a convolution of a Gaussian distribution and a Lorentzian distribution, and is useful for modeling the effects of both natural and instrumental broadening on spectral lines.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... VoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Voigt distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>which can be further simplified to:</p> \\[ V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}} \\] <p>with \\(\\operatorname {Re} [w(z)\\) as the real part of the Faddeeva function and \\(z\\) as:</p> \\[ z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation and \\(\\gamma\\) is the Lorentzian width.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>gamma</code> <code>float</code> <p>Lorentzian width. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class VoigtDistribution(ContinuousWSigma):\n    r\"\"\"Voigt distribution.\n\n    The Voigt distribution is a continuous probability distribution that is widely used\n    in physics and spectroscopy to describe the line shape of spectral lines. It is a\n    convolution of a Gaussian distribution and a Lorentzian distribution, and is useful\n    for modeling the effects of both natural and instrumental broadening on spectral\n    lines.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... VoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Voigt distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n\n        which can be further simplified to:\n\n        $$\n        V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}}\n        $$\n\n        with $\\operatorname {Re} [w(z)$ as the real part of the Faddeeva function and\n        $z$ as:\n\n        $$\n        z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation and $\\gamma$ is the\n        Lorentzian width.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        gamma (float): Lorentzian width. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        sigma: float = 1,\n        gamma: float = 1,\n        mu: float = 0,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if sigma &lt; 0:\n            msg = \"sigma\"\n            raise NotAPositiveNumberError(msg, sigma)\n        if gamma &lt; 0:\n            msg = \"gamma\"\n            raise NotAPositiveNumberError(msg, gamma)\n\n        super().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\n        self.gamma = gamma\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Return the probability density function.\"\"\"\n        z = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\n        return np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=0,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#cauchy-distribution","title":"Cauchy Distribution","text":"<p>Cauchy distribution.</p> <p>The Cauchy distribution is a continuous probability distribution that has no mean or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n... x,\n... gamma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n... x,\n... gamma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n... x,\n... gamma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cauchy distribution is defined as:</p> \\[ f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 + \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]} \\] <p>where \\(x_0\\) is the location parameter and \\(\\gamma\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Cauchy distribution is:</p> \\[ F(x | x_0, \\gamma) = \\frac{1}{\\pi} \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>gamma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class CauchyDistribution(ContinuousDistributionBase):\n    r\"\"\"Cauchy distribution.\n\n    The Cauchy distribution is a continuous probability distribution that has no mean\n    or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n        ... x,\n        ... gamma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n        ... x,\n        ... gamma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n        ... x,\n        ... gamma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Cauchy distribution is defined as:\n\n        $$\n        f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 +\n        \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]}\n        $$\n\n        where $x_0$ is the location parameter and $\\gamma$ is the scale parameter.\n\n        The cumulative distribution function (CDF) of the Cauchy distribution is:\n\n        $$\n        F(x | x_0, \\gamma) = \\frac{1}{\\pi}\n        \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2}\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        gamma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        gamma: float = 1,\n        cumulative: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if gamma &lt;= 0:\n            msg = \"gamma must be positive\"\n            raise ValueError(msg)\n        self.gamma = gamma\n        super().__init__(*x, mu=mu, cumulative=cumulative)\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.nan,\n            variance=np.nan,\n            mode=self.mu,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#gumbel-distribution","title":"Gumbel Distribution","text":"<p>Gumbel distribution.</p> <p>The Gumbel distribution is a continuous probability distribution that is used to model the distribution of the maximum (or the minimum) of a number of samples of various distributions. It is a two-parameter family of curves, with the location parameter \\(\\mu\\) controlling the location of the distribution and the scale parameter \\(\\beta\\) controlling the spread of the distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n... x,\n... mu=0,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n... x,\n... mu=5,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n... x,\n... mu=10,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gumbel distribution is defined as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}} \\] <p>where \\(\\mu\\) is the location parameter and \\(\\beta\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Gumbel distribution is:</p> \\[ F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GumbelDistribution(ContinuousWBeta):\n    r\"\"\"Gumbel distribution.\n\n    The Gumbel distribution is a continuous probability distribution that is used to\n    model the distribution of the maximum (or the minimum) of a number of samples of\n    various distributions. It is a two-parameter family of curves, with the location\n    parameter $\\mu$ controlling the location of the distribution and the scale\n    parameter $\\beta$ controlling the spread of the distribution.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n        ... x,\n        ... mu=0,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n        ... x,\n        ... mu=5,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n        ... x,\n        ... mu=10,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gumbel distribution is defined as:\n\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta}\n        e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}}\n        $$\n\n        where $\\mu$ is the location parameter and $\\beta$ is the scale parameter.\n\n        The cumulative distribution function (CDF) of the Gumbel distribution is:\n\n        $$\n        F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}}\n        $$\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return (\n            1\n            / self.beta\n            * np.exp(\n                -(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n                / self.beta,\n            )\n        )\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.mu + self.beta * np.euler_gamma,\n            variance=(np.pi**2 / 6) * self.beta**2,\n            mode=self.mu + self.beta * np.log(np.log(3)),\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#exponential-distribution","title":"Exponential Distribution","text":"<p>Exponential distribution.</p> <p>The exponential distribution is a continuous probability distribution that describes the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is a one-parameter family of curves, with the rate parameter \\(\\lambda\\) controlling the shape of the distribution. The exponential distribution is widely used in reliability theory, queueing theory, and other fields.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n... x,\n... lambda_=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n... x,\n... lambda_=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n... x,\n... lambda_=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The exponential distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda) = \\lambda e^{-\\lambda x} \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda) = 1 - e^{-\\lambda x} \\] <p>where \\(\\lambda\\) is the rate parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda_</code> <code>float</code> <p>Rate parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class ExponentialDistribution(ContinuousWLambda):\n    r\"\"\"Exponential distribution.\n\n    The exponential distribution is a continuous probability distribution that\n    describes the time between events in a Poisson process, where events occur\n    continuously and independently at a constant average rate. It is a one-parameter\n    family of curves, with the rate parameter $\\lambda$ controlling the shape of the\n    distribution. The exponential distribution is widely used in reliability theory,\n    queueing theory, and other fields.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n        ... x,\n        ... lambda_=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n        ... x,\n        ... lambda_=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n        ... x,\n        ... lambda_=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The exponential distribution is generally defined for the PDF as:\n\n        $$\n        f(x | \\lambda) = \\lambda e^{-\\lambda x}\n        $$\n\n        and for the CDF as:\n\n        $$\n        F(x | \\lambda) = 1 - e^{-\\lambda x}\n        $$\n\n        where $\\lambda$ is the rate parameter.\n\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda_ (float): Rate parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; np.ndarray:\n        \"\"\"Return the probability density function.\"\"\"\n        return self.lambda_ * np.exp(-self.lambda_ * self._x)\n\n    def cumulative_distribution_function(self) -&gt; np.ndarray:\n        \"\"\"Return the cumulative distribution function.\"\"\"\n        return 1 - np.exp(-self.lambda_ * self._x)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Return the summary statistics.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=1 / self.lambda_,\n            variance=1 / self.lambda_**2,\n            mode=0,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/discrete_finite_support/","title":"Finite Support","text":""},{"location":"modules/functions/distributions/discrete_finite_support/#bernoulli-distribution","title":"Bernoulli Distribution","text":"<p>Bernoulli distribution.</p> <p>The Bernoulli distribution is a discrete distribution with two possible outcomes, 0 and 1. It is the simplest discrete distribution. It is a special case of the binomial distribution where a single trial is conducted (n=1).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BernoulliDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bernoulli distribution is defined as follows:</p> \\[ f(x;p) = p^x (1-p)^{1-x} \\] <p>where \\(x \\in \\{0, 1\\}\\) and \\(p \\in [0, 1]\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BernoulliDistribution(DiscreteP):\n    r\"\"\"Bernoulli distribution.\n\n    The Bernoulli distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is the simplest discrete distribution. It is a\n    special case of the binomial distribution where a single trial is\n    conducted (n=1).\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BernoulliDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bernoulli distribution is defined as follows:\n\n        $$\n        f(x;p) = p^x (1-p)^{1-x}\n        $$\n\n        where $x \\in \\{0, 1\\}$ and $p \\in [0, 1]$.\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n    \"\"\"\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\n        return self.p**self._x * (self.q) ** (1 - self._x)\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Bernoulli distribution.\"\"\"\n\n        def _mode() -&gt; float | tuple[float, float]:\n            \"\"\"Mode of the Bernoulli distribution.\"\"\"\n            threshold = 0.5\n            if self.p &gt; threshold:\n                return 1\n            return 0 if self.p &lt; threshold else (0, 1)\n\n        return SummaryStatisticsAPI(\n            mean=self.p,\n            variance=self.p * self.q,\n            mode=_mode(),\n            doc=self.__doc__,\n        )\n</code></pre> Probability Mass Function"},{"location":"modules/functions/distributions/discrete_finite_support/#binomial-distribution","title":"Binomial Distribution","text":"<p>Binomial distribution.</p> <p>The binomial distribution is a discrete distribution with two possible outcomes, 0 and 1. It is a generalization of the Bernoulli distribution where \\(n\\) trials are conducted.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n&gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n&gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The binomial distribution is defined as follows for probability mass function:</p> \\[ f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\).</p> <p>The binomial distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\). This expression is also known as the regularized incomplete beta function.</p> \\[ F(x;n,p) = I_{1-p}(n-k, k+1) \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> required <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BinomialDistribution(DiscreteP):\n    r\"\"\"Binomial distribution.\n\n    The binomial distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is a generalization of the Bernoulli distribution\n    where $n$ trials are conducted.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The binomial distribution is defined as follows for probability mass function:\n\n        $$\n        f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n\n        The binomial distribution is defined as follows for cumulative distribution\n        function:\n\n        $$\n        F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        This expression is also known as the regularized incomplete beta function.\n\n        $$\n        F(x;n,p) = I_{1-p}(n-k, k+1)\n        $$\n\n\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n        cumulative: If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n        \"\"\"Initialize the Binomial distribution.\"\"\"\n        super().__init__(*x, p=p, cumulative=cumulative)\n        self.n = np.full_like(self._x, self._x[-1])\n        self.k = self._x\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Binomial distribution.\"\"\"\n        return (\n            combinations(self.n, self.k) * self.p**self.k * self.q ** (self.n - self.k)\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\n        return np.array(\n            [\n                np.sum(\n                    [\n                        combinations(self.n[i], k)\n                        * self.p**k\n                        * self.q ** (self.n[i] - k)\n                        for k in range(self.k[i] + 1)\n                    ],\n                )\n                for i in range(len(self._x))\n            ],\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Binomial distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=self.n.max() * self.p,\n            variance=self.n.max() * self.p * self.q,\n            mode=math.ceil((self.n.max() + 1) * self.p) - 1,\n            doc=self.__doc__,\n        )\n</code></pre> <code>n = np.full_like(self._x, self._x[-1])</code> <code>instance-attribute</code> \u00b6 Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/discrete_infinite_support/","title":"Infinite Support","text":""},{"location":"modules/functions/distributions/discrete_infinite_support/#boltzmann-distribution","title":"Boltzmann Distribution","text":"<p>Boltzmann distribution.</p> <p>The Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of energy among particles in a system at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... BoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n&gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n&gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n&gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Boltzmann distribution is defined for the probability mass function as:</p> \\[ F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right) \\] <p>where \\(p_i\\) is the probability of a system being in state \\(i\\), \\(p_j\\) is the probability of a system being in state \\(j\\), \\(\\varepsilon_i\\) is the energy of state \\(i\\), \\(\\varepsilon_j\\) is the energy of state \\(j\\), \\(k\\) is the Boltzmann constant, and \\(T\\) is the temperature.</p> Info <p>For simplicity, the exponentianal term of the Boltzmann factor \\(k\\) is simpflified from  \\(1.380649 \\times 10^{-23}\\) to 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>energy_i</code> <code>float</code> <p>The energy of state \\(i\\).</p> required <code>energy_j</code> <code>float</code> <p>The energy of state \\(j\\).</p> required <code>temperature</code> <code>float</code> <p>The temperature of the system.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class BoltzmannDistribution(DiscretePure):\n    r\"\"\"Boltzmann distribution.\n\n    The Boltzmann distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of energy among particles\n    in a system at a given temperature in statistical mechanics and thermodynamics.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... BoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n        &gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n        &gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n        &gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Boltzmann distribution is defined for the probability mass function as:\n\n        $$\n        F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac\n        {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right)\n        $$\n\n        where $p_i$ is the probability of a system being in state $i$, $p_j$ is the\n        probability of a system being in state $j$, $\\varepsilon_i$ is the energy of\n        state $i$, $\\varepsilon_j$ is the energy of state $j$, $k$ is the Boltzmann\n        constant, and $T$ is the temperature.\n\n    Info:\n        For simplicity, the exponentianal term of the Boltzmann factor $k$ is\n        simpflified from  $1.380649 \\times 10^{-23}$ to 1.\n\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        energy_i (float): The energy of state $i$.\n        energy_j (float): The energy of state $j$.\n        temperature (float): The temperature of the system.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        energy_i: float,\n        energy_j: float,\n        k: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Boltzmann distribution.\"\"\"\n        if energy_i == energy_j:\n            msg = \"'energy_i' and 'energy_j' cannot be equal.\"\n            raise ValueError(msg)\n        if energy_i &lt; 0:\n            raise NotLargerThanZeroError(\n                var_number=\"energy_i\",\n                number=energy_i,\n            )\n        if energy_j &lt; 0:\n            raise NotLargerThanZeroError(\n                var_number=\"energy_j\",\n                number=energy_j,\n            )\n        if (min_temp := float(np.min(x))) &lt;= 0:\n            raise NotLargerThanZeroError(\n                var_number=\"temperature\",\n                number=min_temp,\n            )\n        super().__init__(*x)\n        self.energy_i = energy_i\n        self.energy_j = energy_j\n        self.temperature = self._x\n        self.k = k\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\n        return np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Boltzmann distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Mass Function"},{"location":"modules/functions/distributions/discrete_infinite_support/#maxwell-boltzmann-distribution","title":"Maxwell-Boltzmann Distribution","text":"<p>Maxwell-Boltzmann distribution.</p> <p>The Maxwell-Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the speeds of particles in a gas at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n... x,\n... a=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n... x,\n... a=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n... x,\n... a=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"MaxwellBoltzmannDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The Maxwell-Boltzmann distribution is defined for the PMF as follows:</p> \\[ F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}} \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>where \\(x\\) is the speed of a particle, \\(a\\) is the most probable speed of \\(a\\), \\(\\pi\\) is the constant pi, and \\(a\\) is a parametrization.</p> <p>The Maxwell-Boltzmann distribution is defined for the CDF as follows:</p> \\[ F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right) -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>For more informtation about the Maxwell-Boltzmann distribution, see also en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>a(float)</code> <p>A parametrization for the Co-Factors of the Maxwell-Boltzmann distribution.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class MaxwellBoltzmannDistribution(DiscretePure):\n    r\"\"\"Maxwell-Boltzmann distribution.\n\n    The Maxwell-Boltzmann distribution is a discrete probability distribution with\n    discrete infinite support. It is used to describe the distribution of the speeds of\n    particles in a gas at a given temperature in statistical mechanics and\n    thermodynamics.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"MaxwellBoltzmannDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Notes:\n        The Maxwell-Boltzmann distribution is defined for the PMF as follows:\n\n        $$\n        F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}}\n        \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n\n        where $x$ is the speed of a particle, $a$ is the most probable speed of $a$,\n        $\\pi$ is the constant pi, and $a$ is a parametrization.\n\n        The Maxwell-Boltzmann distribution is defined for the CDF as follows:\n\n        $$\n        F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right)\n        -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp\n        \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n\n        For more informtation about the Maxwell-Boltzmann distribution, see also\n        https://en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution\n\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        a(float): A parametrization for the Co-Factors of the Maxwell-Boltzmann\n            distribution.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n        \"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\n        if a &lt;= 0:\n            msg = \"a\"\n            raise NotAPositiveNumberError(msg, a)\n        super().__init__(*x, cumulative=cumulative)\n        self.a = a\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\n        return (\n            np.sqrt(2 / np.pi)\n            * (self._x**2 / self.a**3)\n            * np.exp(-(self._x**2) / (2 * self.a**2))\n        )\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\n        return erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n            2 / np.pi,\n        ) * self._x / self.a * np.exp(-(self._x**2) / (2 * self.a**2))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Maxwell-Boltzmann distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=2 * np.sqrt(2 / np.pi) * self.a,\n            variance=(self.a**2 * (3 * np.pi - 8)) / (np.pi),\n            mode=np.sqrt(2) * self.a,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/discrete_infinite_support/#gaus-kuzmin-distribution","title":"Gaus Kuzmin Distribution","text":"<p>Gaus-Kuzmin distribution.</p> <p>The Gaus-Kuzmin distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaus-Kuzmin distribution is defined for the PMF as follows:</p> \\[ F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right] \\] <p>where \\(k\\) is the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>The Gaus-Kuzmin distribution is defined for the CDF as follows:</p> \\[ F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right) \\] <p>For more information about the Gaus-Kuzmin distribution, see also en.wikipedia.org/wiki/Gauss-Kuzmin_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class GausKuzminDistribution(DiscretePure):\n    r\"\"\"Gaus-Kuzmin distribution.\n\n    The Gaus-Kuzmin distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of the number of steps\n    taken by a random walker on a line before reaching a given distance from the origin.\n\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Gaus-Kuzmin distribution is defined for the PMF as\n        follows:\n\n        $$\n        F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right]\n        $$\n\n        where $k$ is the number of steps taken by a random walker on a line before\n        reaching a given distance from the origin.\n\n        The Gaus-Kuzmin distribution is defined for the CDF as follows:\n\n        $$\n        F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right)\n        $$\n\n        For more information about the Gaus-Kuzmin distribution, see also\n        &lt;https://en.wikipedia.org/wiki/Gauss-Kuzmin_distribution&gt;\n\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n    \"\"\"\n\n    def probability_mass_function(self) -&gt; UniversalArray:\n        \"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\n        return -np.log2(1 - 1 / (self._x + 1) ** 2)\n\n    def cumulative_distribution_function(self) -&gt; UniversalArray:\n        \"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\n        return 1 - np.log2((self._x + 2) / (self._x + 1))\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Gaus-Kuzmin distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=np.inf,\n            variance=np.inf,\n            mode=1,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/","title":"Distribution (Discrete)","text":""},{"location":"modules/functions/distributions/mixed_discrete_continuous/#crystal-ball-distribution","title":"Crystal Ball Distribution","text":"<p>Crystal Ball distribution.</p> <p>The Crystal Ball distribution, which is sometimes also called the Crystal Ball function, is a continuous but asymmetric probability distribution on the real line.[^1] This type of function is often used in physics to model the invariant mass of a particle or system of particles, especially when there is a known background contribution.[^2]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... CrystalBallDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n&gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n&gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Crystal Ball distribution is defined as follows for probability density</p> \\[ f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{ \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }} \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha \\end{cases}} \\] <p>with:</p> \\[ A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right| \\] \\[ N={\\frac  {1}{\\sigma (C+D)}} \\] \\[ C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}} \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf} \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right) \\] <p>See also: www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/ crystalball.html</p> <p>About the Normalization</p> <p>The normalization constant \\(N\\) might be not correct implemented because for the zero-division case \\(n=1\\) the normalization constant \\(N\\) is set to one to achieve a optical match with the reference figures of <sup>1</sup>.</p> <ol> <li> <p>Crystal Ball function. (2020, November 27). In Wikipedia. en.wikipedia.org/wiki/Crystal_Ball_function \u21a9</p> </li> <li> <p>Tomasz Skwarnicki, A study of the radiative CASCADE transitions between _ the Upsilon-Prime and Upsilon resonances_, PHD-Thesis, DESY-F31-86-02, Apr. 1986\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the Gaussian region.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the Gaussian region.</p> <code>1</code> <code>n</code> <code>float</code> <p>The power of the power-law region.</p> <code>1</code> <code>alpha</code> <code>float</code> <p>: The location of the transition between the Gaussian and power-law regions.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class CrystalBallDistribution(ContinuousWSigma):\n    r\"\"\"Crystal Ball distribution.\n\n    The Crystal Ball distribution, which is sometimes also called the Crystal\n    Ball function, is a continuous but asymmetric probability distribution on the real\n    line.[^1] This type of function is often used in physics to model the invariant\n    mass of a particle or system of particles, especially when there is a known\n    background contribution.[^2]\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... CrystalBallDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n        &gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n        &gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n\n\n    Notes:\n        The Crystal Ball distribution is defined as follows for probability density\n        [^2]:\n\n        $$\n        f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp\n        \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{\n        \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot\n        \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }}\n        \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha\n        \\end{cases}}\n        $$\n\n        with:\n\n        $$\n        A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp\n        \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n\n        $$\n        B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right|\n        $$\n\n        $$\n        N={\\frac  {1}{\\sigma (C+D)}}\n        $$\n\n        $$\n        C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}}\n        \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n\n        $$\n        D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf}\n        \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right)\n        $$\n\n        See also: https://www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/\n        crystalball.html\n\n        !!! warning \"About the Normalization\"\n            The normalization constant $N$ might be not correct implemented because\n            for the zero-division case $n=1$ the normalization constant $N$ is set to\n            one to achieve a optical match with the reference figures of [^2].\n\n        [^1]: Tomasz Skwarnicki, _A study of the radiative CASCADE transitions between_\n            _ the Upsilon-Prime and Upsilon resonances_, **PHD-Thesis**, DESY-F31-86-02,\n            Apr. 1986\n        [^2]: Crystal Ball function. (2020, November 27). _In Wikipedia._\n            https://en.wikipedia.org/wiki/Crystal_Ball_function\n\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the Gaussian region.\n        sigma (float): The standard deviation of the Gaussian region.\n        n (float): The power of the power-law region.\n        alpha (float):: The location of the transition between the Gaussian and\n            power-law regions.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        n: float = 1,\n        alpha: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Crystal Ball distribution.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma)\n\n        if n &lt;= 0:\n            raise NotLargerThanZeroError(number=n)\n\n        if alpha &lt; 0:\n            raise NotLargerThanZeroError(number=alpha)\n\n        self.n = n\n        self.alpha = alpha\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n        _a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n            -(self.alpha**2) / 2,\n        )\n        _b = self.n / abs(self.alpha) - abs(self.alpha)\n        if self.n == 1:\n            _n = self.n\n        else:\n            _c = self.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n            _d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n            _n = 1 / (self.sigma * (_c + _d))\n        return np.where(\n            (self._x - self.mu) / self.sigma &gt; -self.alpha,\n            _n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n            _n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Crystal Ball distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> <code>n = n</code> <code>instance-attribute</code> \u00b6 Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#pearson-type-vii-distribution","title":"Pearson Type VII Distribution","text":"<p>Pearson VII distribution.</p> <p>The Pearson VII distribution is a continuous probability distribution on the real line. It is a generalization of the Student's t-distribution and the Cauchy distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PearsonVIIDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n&gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n&gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n&gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n&gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n&gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pearson VII distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)} {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+ \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}} \\] <p><sup>1</sup> Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.     Journal of Applied Crystalography, 31(3), 474-476.     doi.org/10.1107/S0021889897011047</p> <p>See also: en.wikipedia.org/wiki/Pearson_distribution and www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>p</code> <code>float</code> <p>The shape parameter of the distribution.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PearsonVIIDistribution(ContinuousWSigma):\n    r\"\"\"Pearson VII distribution.\n\n    The Pearson VII distribution is a continuous probability distribution on the real\n    line. It is a generalization of the Student's t-distribution and the Cauchy\n    distribution. This function becomes popular for X-ray diffraction data analysis.[^1]\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PearsonVIIDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n        &gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n        &gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n        &gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n        &gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n        &gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Pearson VII distribution is defined as follows for probability density\n        [^1]:\n\n        $$\n        f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)}\n        {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+\n        \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}}\n        $$\n\n        [^1] Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.\n            Journal of Applied Crystalography, 31(3), 474-476.\n            https://doi.org/10.1107/S0021889897011047\n\n        See also: https://en.wikipedia.org/wiki/Pearson_distribution and\n        https://www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc\n\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution.\n        sigma (float): The standard deviation of the distribution.\n        p (float): The shape parameter of the distribution.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        mu: float = 0,\n        sigma: float = 1,\n        p: float = 1,\n    ) -&gt; None:\n        \"\"\"Initialize the Pearson VII distribution.\"\"\"\n        super().__init__(*x, mu=mu, sigma=sigma)\n        self.p = p\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Pearson VII distribution.\"\"\"\n        return (\n            gammaln(self.p / 2)\n            / (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n            * (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n        )\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Pearson VII distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#asymmetric-raman-lineshape-distribution","title":"Asymmetric Raman Lineshape Distribution","text":"<p>Asymmetric Raman lineshape distribution.</p> <p>The Asymmetric Raman lineshape distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for Raman spectroscopy data analysis.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... AsymmetricRamanLineshape\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Asymmetric Raman lineshape distribution is defined as follows for probability density [^1]:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma)) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\) and the damped sigmoidal term \\(p(x)\\):</p> \\[ p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right) \\] <p>[^1] Korepanov, V, I.and Sedlovets, D. M. (2018),     An asymmetric fitting function for condensed-phase Raman spectroscopy,     Analyst RSC, 2674-2679 (143)     dx.doi.org/10.1039/C8AN00710A</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class AsymmetricRamanLineshape(ContinousAsymmetricPseudo):\n    r\"\"\"Asymmetric Raman lineshape distribution.\n\n    The Asymmetric Raman lineshape distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for Raman spectroscopy data analysis.\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... AsymmetricRamanLineshape\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Asymmetric Raman lineshape distribution is defined as follows for\n        probability density [^1]:\n\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot\n        p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma))\n        $$\n\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$ and the\n        damped sigmoidal term $p(x)$:\n\n        $$\n        p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot\n        \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right)\n        $$\n\n        [^1] Korepanov, V, I.and Sedlovets, D. M. (2018),\n            An asymmetric fitting function for condensed-phase Raman spectroscopy,\n            Analyst RSC, 2674-2679 (143)\n            http://dx.doi.org/10.1039/C8AN00710A\n\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\n        p = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n            -((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n        )\n        return (1 - self.eta) * GaussianDistribution(\n            self._x * p,\n            mu=self.mu,\n            sigma=self.sigma,\n        ).probability_density_function() + self.eta * LorentzianDistribution(\n            self._x * p,\n            mu=self.mu,\n            gamma=self.sigma,\n        ).probability_density_function()\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Asym. Raman lineshape distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#modified-doniach-sunjic-distribution","title":"Modified Doniach-Sunjic Distribution","text":"<p>Doniach-Sunjic distribution.</p> <p>The Doniach-Sunjic distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for XPS/AES data analysis. See also: www.casaxps.com</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... ModifiedDoniachSunjicDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"ModifiedDoniachSunjicDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Warning <p>The Doniach-Sunjic distribution as defined for casaxps is not the same as used in the current implementation. In the current implementation, the damping factor is included into the lorentzian model.</p> Notes <p>The Doniach-Sunjic distribution is defined as follows for probability density:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma)) \\] <p>with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal is defined as:</p> \\[ p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\ 0 &amp; \\text{if } x \\geq \\mu \\end{cases} \\] <p>and the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: www.casaxps.com/help_manual/line_shapes.htm</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class ModifiedDoniachSunjicDistribution(ContinousAsymmetricPseudo):\n    r\"\"\"Doniach-Sunjic distribution.\n\n    The Doniach-Sunjic distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for XPS/AES data analysis. See also:\n    http://www.casaxps.com\n\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... ModifiedDoniachSunjicDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"ModifiedDoniachSunjicDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n\n    Warning:\n        The Doniach-Sunjic distribution as defined for **casaxps** is not the same as\n        used in the current implementation. In the current implementation, the damping\n        factor is included into the lorentzian model.\n\n    Notes:\n        The Doniach-Sunjic distribution is defined as follows for probability density:\n\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma))\n        $$\n\n        with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal\n        is defined as:\n\n        $$\n        p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot\n        \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\\n        0 &amp; \\text{if } x \\geq \\mu \\end{cases}\n        $$\n\n        and the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: http://www.casaxps.com/help_manual/line_shapes.htm\n\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\n\n    def probability_density_function(self) -&gt; UniversalArray:\n        \"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\n        p = np.where(\n            self._x &lt; self.mu,\n            np.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n            0,\n        )\n        return (1 - self.eta) * GaussianDistribution(\n            self._x,\n            mu=self.mu,\n            sigma=self.sigma,\n        ).probability_density_function() + self.eta * LorentzianDistribution(\n            self._x * p,\n            mu=self.mu,\n            gamma=self.sigma,\n        ).probability_density_function()\n\n    @property\n    def __summary__(self) -&gt; SummaryStatisticsAPI:\n        \"\"\"Summary statistics of the Doniach-Sunjic distribution.\"\"\"\n        return SummaryStatisticsAPI(\n            mean=None,\n            variance=None,\n            mode=None,\n            doc=self.__doc__,\n        )\n</code></pre> Probability Density Function"},{"location":"modules/functions/hyperbolic/angle/","title":"Angle Functions","text":""},{"location":"modules/functions/hyperbolic/angle/#angle-function","title":"Angle Function","text":"<p>Compute the angle between two vectors in the hyperbolic plane.</p> <p>The hyperbolic angle function computes the angle between two vectors in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n&gt;&gt;&gt; vector1 = np.array([1, 0])\n&gt;&gt;&gt; vector2 = np.array([0, 1])\n&gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n&gt;&gt;&gt; haf.result\narray(1.57079633)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n&gt;&gt;&gt; vector1 = np.array([1, 0])\n&gt;&gt;&gt; vector2 = np.array([0, 1])\n&gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n&gt;&gt;&gt; angle = haf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.quiver(\n...     0, 0, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1,\n...     color='r', label='Vector 1'\n... )\n&gt;&gt;&gt; _ = ax.quiver(\n...     0, 0, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1,\n...     color='b', label='Vector 2'\n... )\n&gt;&gt;&gt; _ = ax.set_xlim(-1.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-1.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; _ = plt.title(f'Angle: {angle:.2f} radians')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"AngleFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The angle between two vectors \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ \\theta = \\cos^{-1}\\left(\\frac{x_1 x_2 + y_1 y_2}{\\sqrt{x_1^2 + y_1^2} \\sqrt{x_2^2 + y_2^2}}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_angle</p> <p>Parameters:</p> Name Type Description Default <code>*vectors</code> <code>UniversalArray</code> <p>The coordinates of the two vectors in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/angle.py</code> Python<pre><code>class AngleFunction(HyperbolicFunction):\n    r\"\"\"Compute the angle between two vectors in the hyperbolic plane.\n\n    The hyperbolic angle function computes the angle between two vectors in the\n    hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n        &gt;&gt;&gt; vector1 = np.array([1, 0])\n        &gt;&gt;&gt; vector2 = np.array([0, 1])\n        &gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n        &gt;&gt;&gt; haf.result\n        array(1.57079633)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.angle import AngleFunction\n        &gt;&gt;&gt; vector1 = np.array([1, 0])\n        &gt;&gt;&gt; vector2 = np.array([0, 1])\n        &gt;&gt;&gt; haf = AngleFunction(vector1, vector2)()\n        &gt;&gt;&gt; angle = haf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.quiver(\n        ...     0, 0, vector1[0], vector1[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='r', label='Vector 1'\n        ... )\n        &gt;&gt;&gt; _ = ax.quiver(\n        ...     0, 0, vector2[0], vector2[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='b', label='Vector 2'\n        ... )\n        &gt;&gt;&gt; _ = ax.set_xlim(-1.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-1.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; _ = plt.title(f'Angle: {angle:.2f} radians')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"AngleFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The angle between two vectors $(x_1, y_1)$ and $(x_2, y_2)$ in the hyperbolic\n        plane is given by:\n\n        $$\n        \\theta = \\cos^{-1}\\left(\\frac{x_1 x_2 + y_1 y_2}{\\sqrt{x_1^2 + y_1^2}\n        \\sqrt{x_2^2 + y_2^2}}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_angle\n\n    Args:\n        *vectors (UniversalArray): The coordinates of the two vectors in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *vectors: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic angle function.\"\"\"\n        super().__init__(*vectors)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Compute the angle between two vectors in the hyperbolic plane.\n\n        Returns:\n            float: The angle between the two vectors in radians.\n        \"\"\"\n        x1, y1 = self._x[0]\n        x2, y2 = self._x[1]\n        dot_product = x1 * x2 + y1 * y2\n        norm1 = np.sqrt(x1**2 + y1**2)\n        norm2 = np.sqrt(x2**2 + y2**2)\n        return np.arccos(dot_product / (norm1 * norm2))\n</code></pre> Angle Function"},{"location":"modules/functions/hyperbolic/area/","title":"Area Functions","text":""},{"location":"modules/functions/hyperbolic/area/#area-function","title":"Area Function","text":"<p>Calculate the area of a polygon in the hyperbolic plane.</p> <p>The hyperbolic area function calculates the area of a polygon in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n&gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n&gt;&gt;&gt; haf = AreaFunction(*vertices)()\n&gt;&gt;&gt; haf.result\narray(0.5)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n&gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n&gt;&gt;&gt; haf = AreaFunction(*vertices)()\n&gt;&gt;&gt; area = haf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; polygon = plt.Polygon(vertices, closed=True, fill=None, edgecolor='r')\n&gt;&gt;&gt; _ = ax.add_patch(polygon)\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Area: {area:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"AreaFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The area of a polygon in the hyperbolic plane is given by:</p> \\[ A = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right| \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_area</p> <p>Parameters:</p> Name Type Description Default <code>*vertices</code> <code>UniversalArray</code> <p>The coordinates of the vertices of the polygon in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/area.py</code> Python<pre><code>class AreaFunction(HyperbolicFunction):\n    r\"\"\"Calculate the area of a polygon in the hyperbolic plane.\n\n    The hyperbolic area function calculates the area of a polygon in the hyperbolic\n    plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n        &gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n        &gt;&gt;&gt; haf = AreaFunction(*vertices)()\n        &gt;&gt;&gt; haf.result\n        array(0.5)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.area import AreaFunction\n        &gt;&gt;&gt; vertices = np.array([(0, 0), (1, 0), (0, 1)])\n        &gt;&gt;&gt; haf = AreaFunction(*vertices)()\n        &gt;&gt;&gt; area = haf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; polygon = plt.Polygon(vertices, closed=True, fill=None, edgecolor='r')\n        &gt;&gt;&gt; _ = ax.add_patch(polygon)\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Area: {area:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"AreaFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The area of a polygon in the hyperbolic plane is given by:\n\n        $$\n        A = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_area\n\n    Args:\n        *vertices (UniversalArray): The coordinates of the vertices of the polygon in\n            the hyperbolic plane.\n    \"\"\"\n\n    def __init__(self, *vertices: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic area function.\"\"\"\n        super().__init__(*vertices)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Calculate the area of a polygon in the hyperbolic plane.\n\n        Returns:\n            float: The area of the polygon in the hyperbolic plane.\n        \"\"\"\n        n = len(self._x)\n        area = 0.0\n        for i in range(n):\n            x1, y1 = self._x[i]\n            x2, y2 = self._x[(i + 1) % n]\n            area += x1 * y2 - x2 * y1\n        return 0.5 * np.abs(area)\n</code></pre> Area Function"},{"location":"modules/functions/hyperbolic/distance/","title":"Distance Functions","text":""},{"location":"modules/functions/hyperbolic/distance/#distance-function","title":"Distance Function","text":"<p>Calculate the hyperbolic distance between two points in the hyperbolic plane.</p> <p>The hyperbolic distance function calculates the distance between two points in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n&gt;&gt;&gt; hdf.result\narray(2.89838887)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n&gt;&gt;&gt; distance = hdf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"DistanceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The hyperbolic distance between two points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_distance</p> <p>Parameters:</p> Name Type Description Default <code>*points</code> <code>UniversalArray</code> <p>The coordinates of the two points in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/distance.py</code> Python<pre><code>class DistanceFunction(HyperbolicFunction):\n    r\"\"\"Calculate the hyperbolic distance between two points in the hyperbolic plane.\n\n    The hyperbolic distance function calculates the distance between two points in the\n    hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n        &gt;&gt;&gt; hdf.result\n        array(2.89838887)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.distance import DistanceFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hdf = DistanceFunction(point1, point2)()\n        &gt;&gt;&gt; distance = hdf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"DistanceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The hyperbolic distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ in the\n        hyperbolic plane is given by:\n\n        $$\n        d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_distance\n\n    Args:\n        *points (UniversalArray): The coordinates of the two points in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *points: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic distance function.\"\"\"\n        super().__init__(*points)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Calculate the hyperbolic distance between two points in the hyperbolic plane.\n\n        Returns:\n            float: The hyperbolic distance between the two points.\n        \"\"\"\n        x1, y1 = self._x[0].astype(np.float64)\n        x2, y2 = self._x[1].astype(np.float64)\n        return np.asarray(\n            np.arccosh(1 + ((x2 - x1) ** 2 + (y2 - y1) ** 2) / (2 * y1 * y2))\n        )\n</code></pre> Distance Function"},{"location":"modules/functions/hyperbolic/geodesic/","title":"Geodesic Functions","text":""},{"location":"modules/functions/hyperbolic/geodesic/#geodesic-function","title":"Geodesic Function","text":"<p>Determine the shortest path between two points in the hyperbolic plane.</p> <p>The hyperbolic geodesic function determines the shortest path between two points in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n&gt;&gt;&gt; hgf.result\narray(2.89838887)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n&gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n&gt;&gt;&gt; point2 = np.array([1, 1])\n&gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n&gt;&gt;&gt; distance = hgf.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n&gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n&gt;&gt;&gt; _ = ax.set_aspect('equal')\n&gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"GeodesicFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The hyperbolic geodesic between two points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) in the hyperbolic plane is given by:</p> \\[ d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right) \\] <p>Reference: en.wikipedia.org/wiki/Hyperbolic_geodesic</p> <p>Parameters:</p> Name Type Description Default <code>*points</code> <code>UniversalArray</code> <p>The coordinates of the two points in the hyperbolic plane.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/geodesic.py</code> Python<pre><code>class GeodesicFunction(HyperbolicFunction):\n    r\"\"\"Determine the shortest path between two points in the hyperbolic plane.\n\n    The hyperbolic geodesic function determines the shortest path between two points\n    in the hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n        &gt;&gt;&gt; hgf.result\n        array(2.89838887)\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.geodesic import GeodesicFunction\n        &gt;&gt;&gt; point1 = np.array([0.1, 0.1])\n        &gt;&gt;&gt; point2 = np.array([1, 1])\n        &gt;&gt;&gt; hgf = GeodesicFunction(point1, point2)()\n        &gt;&gt;&gt; distance = hgf.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _ = ax.plot([point1[0], point2[0]], [point1[1], point2[1]], 'ro-')\n        &gt;&gt;&gt; _ = ax.set_xlim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_ylim(-0.5, 1.5)\n        &gt;&gt;&gt; _ = ax.set_aspect('equal')\n        &gt;&gt;&gt; _ = plt.title(f'Distance: {distance:.2f}')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"GeodesicFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The hyperbolic geodesic between two points $(x_1, y_1)$ and $(x_2, y_2)$ in the\n        hyperbolic plane is given by:\n\n        $$\n        d = \\cosh^{-1}\\left(1 + \\frac{(x_2 - x_1)^2 + (y_2 - y_1)^2}{2 y_1 y_2}\\right)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Hyperbolic_geodesic\n\n    Args:\n        *points (UniversalArray): The coordinates of the two points in the hyperbolic\n            plane.\n    \"\"\"\n\n    def __init__(self, *points: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic geodesic function.\"\"\"\n        super().__init__(*points)\n\n    @property\n    def __eval__(self) -&gt; float:\n        \"\"\"Determine the shortest path between two points in the hyperbolic plane.\n\n        Returns:\n            float: The length of the geodesic between the two points.\n        \"\"\"\n        x1, y1 = self._x[0]\n        x2, y2 = self._x[1]\n        return np.arccosh(1 + ((x2 - x1) ** 2 + (y2 - y1) ** 2) / (2 * y1 * y2))\n</code></pre> Geodesic Function"},{"location":"modules/functions/hyperbolic/isometry/","title":"Isometry Functions","text":""},{"location":"modules/functions/hyperbolic/isometry/#isometry-function","title":"Isometry Function","text":"<p>Apply an isometry transformation to a point in the hyperbolic plane.</p> <p>The hyperbolic isometry function applies isometries (transformations that preserve distances) in the hyperbolic plane.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n&gt;&gt;&gt; point = np.array([1, 1], dtype=float)\n&gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]], dtype=float)\n&gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n&gt;&gt;&gt; hif.result\narray([2., 2.])\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Visualization Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n&gt;&gt;&gt; point = np.array([1, 1])\n&gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]])\n&gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n&gt;&gt;&gt; transformed_point = hif.result\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; _  = ax.quiver(\n...     0, 0, point[0], point[1], angles='xy', scale_units='xy', scale=1,\n...     color='r', label='Original Point'\n... )\n&gt;&gt;&gt; _  = ax.quiver(\n...     0, 0, transformed_point[0], transformed_point[1], angles='xy',\n...     scale_units='xy', scale=1, color='b', label='Transformed Point'\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; _  = ax.set_xlim(-1.5, 2.5)\n&gt;&gt;&gt; _  = ax.set_ylim(-1.5, 2.5)\n&gt;&gt;&gt; ax.set_aspect('equal')\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; _  = plt.title('Hyperbolic Isometry Transformation')\n&gt;&gt;&gt; plt.grid()\n&gt;&gt;&gt; plt.savefig(\"IsometryFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>An isometry transformation in the hyperbolic plane is represented by a 2x2 matrix. The transformation is applied to a point \\((x, y)\\) in the hyperbolic plane to obtain a new point \\((x', y')\\).</p> <p>Reference: en.wikipedia.org/wiki/Isometry</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>UniversalArray</code> <p>The point (x, y) to be transformed and the 2x2 isometry matrix.</p> <code>()</code> Source code in <code>umf/functions/hyperbolic/isometry.py</code> Python<pre><code>class IsometryFunction(HyperbolicFunction):\n    r\"\"\"Apply an isometry transformation to a point in the hyperbolic plane.\n\n    The hyperbolic isometry function applies isometries (transformations that preserve\n    distances) in the hyperbolic plane.\n\n    Examples:\n        &gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n        &gt;&gt;&gt; point = np.array([1, 1], dtype=float)\n        &gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]], dtype=float)\n        &gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n        &gt;&gt;&gt; hif.result\n        array([2., 2.])\n\n        &gt;&gt;&gt; # Visualization Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from umf.functions.hyperbolic.isometry import IsometryFunction\n        &gt;&gt;&gt; point = np.array([1, 1])\n        &gt;&gt;&gt; matrix = np.array([[1, 1], [1, 1]])\n        &gt;&gt;&gt; hif = IsometryFunction(point, matrix)()\n        &gt;&gt;&gt; transformed_point = hif.result\n        &gt;&gt;&gt; fig, ax = plt.subplots()\n        &gt;&gt;&gt; _  = ax.quiver(\n        ...     0, 0, point[0], point[1], angles='xy', scale_units='xy', scale=1,\n        ...     color='r', label='Original Point'\n        ... )\n        &gt;&gt;&gt; _  = ax.quiver(\n        ...     0, 0, transformed_point[0], transformed_point[1], angles='xy',\n        ...     scale_units='xy', scale=1, color='b', label='Transformed Point'\n        ... )\n\n        &gt;&gt;&gt; _  = ax.set_xlim(-1.5, 2.5)\n        &gt;&gt;&gt; _  = ax.set_ylim(-1.5, 2.5)\n        &gt;&gt;&gt; ax.set_aspect('equal')\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; _  = plt.title('Hyperbolic Isometry Transformation')\n        &gt;&gt;&gt; plt.grid()\n        &gt;&gt;&gt; plt.savefig(\"IsometryFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        An isometry transformation in the hyperbolic plane is represented by a 2x2\n        matrix. The transformation is applied to a point $(x, y)$ in the hyperbolic\n        plane to obtain a new point $(x', y')$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Isometry\n\n    Args:\n        *args (UniversalArray): The point (x, y) to be transformed and the 2x2 isometry\n            matrix.\n    \"\"\"\n\n    def __init__(self, *args: UniversalArray) -&gt; None:\n        \"\"\"Initialize the hyperbolic isometry function.\"\"\"\n        super().__init__(*args)\n\n    @property\n    def __eval__(self) -&gt; np.ndarray:\n        \"\"\"Apply an isometry transformation to a point in the hyperbolic plane.\n\n        Returns:\n            np.ndarray: The transformed point (x', y').\n        \"\"\"\n        point = self._x[0].astype(np.float64)\n        matrix = self._x[1].astype(np.float64)\n        return np.dot(matrix, point)\n</code></pre> Isometry Function"},{"location":"modules/functions/optimization/bowl_shaped/","title":"Bowl Shaped","text":""},{"location":"modules/functions/optimization/bowl_shaped/#perm-beta-d-function","title":"Perm Beta D function","text":"<p>Perm Beta D function.</p> <p>The Perm Beta D function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm Beta D function is defined as:</p> \\[     f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +     \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 0.5\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermBetaDFunction(OptFunction):\n    r\"\"\"Perm Beta D function.\n\n    The Perm Beta D function is a D-dimensional function with multimodal structure\n    and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Perm Beta D function is defined as:\n\n        $$\n            f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +\n            \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n\n        with constant $\\beta = 0.5$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Perm Beta D function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        beta = 0.5\n\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = sum(\n                (j**i + beta) * ((self._x[j - 1] / j) ** i - 1)\n                for j in range(1, self.dimension + 1)\n            )\n            outer_sum += inner_sum**2\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Perm Beta D function.\n\n        Returns:\n            MinimaAPI: Minima of the Perm Beta D function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#trid-function","title":"Trid Function","text":"<p>Trid function.</p> <p>The Trid function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Trid function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class TridFunction(OptFunction):\n    r\"\"\"Trid function.\n\n    The Trid function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Trid function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1}\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/trid.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Trid function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = (self._x[i - 1] - 1) ** 2 - self._x[i - 1] * self._x[i - 2]\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Trid function.\n\n        Returns:\n            MinimaAPI: Minima of the Trid function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-self.dimension * (self.dimension + 4) * (self.dimension - 1) / 6,\n            x=tuple(i * (self.dimension + 1 - i) for i in range(1, self.dimension + 1)),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sum-squares-function","title":"Sum Squares Function","text":"<p>Sum squares function.</p> <p>The Sum squares function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum squares function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D i x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumSquaresFunction(OptFunction):\n    r\"\"\"Sum squares function.\n\n    The Sum squares function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sum squares function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D i x_i^2\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumsqu.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sum squares function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = i * self._x[i - 1] ** 2\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sum squares function.\n\n        Returns:\n            MinimaAPI: Minima of the Sum squares function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sum-of-different-power-function","title":"Sum of Different Power Function","text":"<p>Sum of different powers function.</p> <p>The Sum of different powers function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... SumOfDifferentPowersFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum of different powers function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>_Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumOfDifferentPowersFunction(OptFunction):\n    r\"\"\"Sum of different powers function.\n\n    The Sum of different powers function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... SumOfDifferentPowersFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sum of different powers function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1}\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        _Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sum of different powers function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n\n        for i in range(1, self.dimension + 1):\n            inner_sum = abs(self._x[i - 1]) ** (i + 1)\n            outer_sum += inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sum of different powers function.\n\n        Returns:\n            MinimaAPI: Minima of the Sum of different powers function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#zirilli-function","title":"Zirilli Function","text":"<p>Zirilli function.</p> <p>The Zirilli function is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zirilli function is defined as:</p> \\[     f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2 \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class ZirilliFunction(OptFunction):\n    r\"\"\"Zirilli function.\n\n    The Zirilli function is a 2D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zirilli function is defined as:\n\n        $$\n            f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2\n        $$\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Zirilli\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Zirilli function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 0.25 * x_1**4 - 0.5 * x_1**2 + 0.1 * x_1 + 0.5 * x_2**2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zirilli function.\n\n        Returns:\n            MinimaAPI: Minima of the Zirilli function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-0.352386073800034,\n            x=(-1.046680576580755, 0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sphere-function","title":"Sphere Function","text":"<p>Sphere function.</p> <p>The Sphere function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sphere function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SphereFunction(OptFunction):\n    r\"\"\"Sphere function.\n\n    The Sphere function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n        &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Sphere function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D x_i^2\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n\n        Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/spheref.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Sphere function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return np.sum(np.power(self._x, 2), axis=0)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Sphere function.\n\n        Returns:\n            MinimaAPI: Minima of the Sphere function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#rotated-hyper-ellipsoid-function","title":"Rotated Hyper-Ellipsoid Function","text":"<p>Rotated hyper-ellipse function.</p> <p>The Rotated hyper-ellipse function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... RotatedHyperEllipseFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rotated hyper-ellipse function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2 \\] <p>with \\(D\\) the dimension of the input and \\(a_{ij}\\) the rotation matrix. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class RotatedHyperEllipseFunction(OptFunction):\n    r\"\"\"Rotated hyper-ellipse function.\n\n    The Rotated hyper-ellipse function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... RotatedHyperEllipseFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rotated hyper-ellipse function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2\n        $$\n\n        with $D$ the dimension of the input and $a_{ij}$ the rotation matrix. The\n        hypercube of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/rothyp.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"RotatedHyperEllipse\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rotated hyper-ellipse function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        outer_sum = np.zeros(self._x[0].shape)\n        for i in range(self.dimension):\n            inner_sum = np.zeros(self._x[0].shape)\n            for j in range(i + 1):\n                inner_sum += self._x[j] ** 2\n            outer_sum = outer_sum + inner_sum\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Rotated hyper-ellipse function.\n\n        Returns:\n            MinimaAPI: Minima of the Rotated hyper-ellipse function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre> <p>Reference: Original implementation can be found here</p>"},{"location":"modules/functions/optimization/bowl_shaped/#bohachevsky-function-type-1","title":"Bohachevsky Function Type 1","text":"<p>Bohachevsky function type 1.</p> <p>The Bohachevsky function type 1 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 1 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType1(OptFunction):\n    r\"\"\"Bohachevsky function type 1.\n\n    The Bohachevsky function type 1 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 1 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType1\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 1 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2\n            + 2 * x_2**2\n            - 0.3 * np.cos(3 * np.pi * x_1)\n            - 0.4 * np.cos(4 * np.pi * x_2)\n            + 0.7\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 1.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 1.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#bohachevsky-function-type-2","title":"Bohachevsky Function Type 2","text":"<p>Bohachevsky function tye 2.</p> <p>The Bohachevsky function type 2 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 2 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType2(OptFunction):\n    r\"\"\"Bohachevsky function tye 2.\n\n    The Bohachevsky function type 2 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 2 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType2\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 2 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2\n            + 2 * x_2**2\n            - 0.3 * np.cos(3 * np.pi * x_1) * np.cos(4 * np.pi * x_2)\n            + 0.3\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 2.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 2.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#bochachevsky-function-type-3","title":"Bochachevsky Function Type 3","text":"<p>Bohachevsky function type 3.</p> <p>The Bohachevsky function type 3 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 3 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType3(OptFunction):\n    r\"\"\"Bohachevsky function type 3.\n\n    The Bohachevsky function type 3 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bohachevsky function type 3 is defined as:\n\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"BohachevskyType3\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bohachevsky function type 3 at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            x_1**2 + 2 * x_2**2 - 0.3 * np.cos(3 * np.pi * x_1 + 4 * np.pi * x_2) + 0.3\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Bohachevsky function type 3.\n\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 3.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/","title":"Drops Steps","text":""},{"location":"modules/functions/optimization/drops_steps/#de-jong-n-5-function","title":"De Jong N. 5 Function","text":"<p>De Jong N.5 Function.</p> <p>The De Jong N.5 function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n&gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The De Jong N.5 function is defined as:</p> \\[     f(x, y) = \\left(         0.0002 + \\sum_{i=1}^{25}         \\frac{1}{             i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6         }     \\right)^{-1} \\] <p>where</p> \\[     a = \\left(         \\begin{matrix}         -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\         -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32         \\end{matrix}         \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  adddimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Elements of the matrix a, which has to become are 2-dimensional with shape (2, 25). Defaults to None.</p> <code>None</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class DeJongN5Function(OptFunction):\n    r\"\"\"De Jong N.5 Function.\n\n    The De Jong N.5 function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n        &gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The De Jong N.5 function is defined as:\n\n        $$\n            f(x, y) = \\left(\n                0.0002 + \\sum_{i=1}^{25}\n                \\frac{1}{\n                    i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6\n                }\n            \\right)^{-1}\n        $$\n\n        where\n\n        $$\n            a = \\left(\n                \\begin{matrix}\n                -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\\n                -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32\n                \\end{matrix}\n                \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/dejong5.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             adddimensional.\n        A (UniversalArray, optional): Elements of the matrix a, which has to become are\n            2-dimensional with shape (2, 25). Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        A: UniversalArray | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"De Jong N.5\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n        if A is None:\n            row_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\n            row_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\n            self.a_matrix = np.vstack((row_1, row_2))\n        elif A.shape != (2, 25):\n            msg = \"The shape of a has to be (2, 25).\"\n            raise ValueError(msg)\n        else:\n            self.a_matrix = A\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the De Jong N.5 function.\n\n        Returns:\n            UniversalArray: The value of the De Jong N.5 function.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        a_1 = self.a_matrix[0, :]\n        a_2 = self.a_matrix[1, :]\n\n        sum_ = np.zeros_like(x_1)\n\n        for i in range(25):\n            sum_ += 1 / ((i + 1) + (x_1 - a_1[i]) ** 6 + (x_2 - a_2[i]) ** 6)\n\n        return (0.0002 + sum_) ** -1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the De Jong N.5 function.\n\n        Returns:\n            MinimaAPI: The minima of the De Jong N.5 function.\n        \"\"\"\n        return MinimaAPI(f_x=0.0, x=(0.0, 0.0))\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/#easom-function","title":"Easom Function","text":"<p>Easom Function.</p> <p>The Easom function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Easom function is defined as:</p> \\[     f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2     - \\left(y-\\pi\\right)^2\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class EasomFunction(OptFunction):\n    r\"\"\"Easom Function.\n\n    The Easom function is a two-dimensional function with a single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Easom function is defined as:\n\n        $$\n            f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2\n            - \\left(y-\\pi\\right)^2\\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/easom.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Easom\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Easom function.\n\n        Returns:\n            UniversalArray: The value of the Easom function.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        return np.array(\n            -np.cos(x_1)\n            * np.cos(x_2)\n            * np.exp(-((x_1 - np.pi) ** 2) - (x_2 - np.pi) ** 2),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Easom function.\n\n        Returns:\n            MinimaAPI: The minima of the Easom function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-1.0,\n            x=np.array([np.pi, np.pi]),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/#michalewicz-function","title":"Michalewicz Function","text":"<p>Michalewicz Function.</p> <p>The Michalewicz function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Michalewicz function is defined as:</p> \\[     f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>m</code> <code>int</code> <p>The m parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class MichalewiczFunction(OptFunction):\n    r\"\"\"Michalewicz Function.\n\n    The Michalewicz function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n        &gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Michalewicz function is defined as:\n\n        $$\n            f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/michal.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        m (int, optional): The m parameter. Defaults to 10.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n        self.m = m\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Michalewicz function.\n\n        Returns:\n            UniversalArray: The value of the Michalewicz function.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n\n        for i, x_i in enumerate(self._x, start=1):\n            sum_ += np.sin(x_i) * np.sin((i * x_i**2) / np.pi) ** (2 * self.m)\n\n        return -sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Michalewicz function.\n\n         The minima of the Michalewicz function is not unique and depends on the\n            m parameter and dimensionality of the function.\n\n        Returns:\n            MinimaAPI: The minima of the Michalewicz function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-1.8013,\n            x=(2.20, 1.57),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/","title":"Many Local Minima","text":""},{"location":"modules/functions/optimization/many_local_minima/#ackley-function","title":"Ackley Function","text":"<p>Ackley function.</p> <p>The Ackley function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Ackley function is defined as:</p> \\[     f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}       \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)       \\right) + e + \\alpha \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>alpha</code> <code>float</code> <p>Scaling factor. Default is 20.0.</p> <code>20.0</code> <code>beta</code> <code>float</code> <p>Scaling factor. Default is 0.2.</p> <code>0.2</code> <code>gamma</code> <code>float</code> <p>Scaling factor. Default is 2.0 * np.pi.</p> <code>2.0 * pi</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class AckleyFunction(OptFunction):\n    r\"\"\"Ackley function.\n\n    The Ackley function is a multi-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Ackley function is defined as:\n\n        $$\n            f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}\n              \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)\n              \\right) + e + \\alpha\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/ackley.html).\n\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        alpha (float): Scaling factor. Default is 20.0.\n        beta (float): Scaling factor. Default is 0.2.\n        gamma (float): Scaling factor. Default is 2.0 * np.pi.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        alpha: float = 20.0,\n        beta: float = 0.2,\n        gamma: float = 2.0 * np.pi,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n        self._alpha = alpha\n        self._beta = beta\n        self._gamma = gamma\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Ackley function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_1 = np.zeros_like(self._x[0])\n        sum_2 = np.zeros_like(self._x[0])\n\n        for _i, _x in enumerate(self._x, start=1):\n            # Calculate sum of squares of x values\n            sum_1 += _x**2\n            # Calculate sum of cosines of x values\n            sum_2 += np.cos(self._gamma * _x)\n\n        # Calculate exponential terms\n        terms_1 = -self._alpha * np.exp(-self._beta * np.sqrt(1 / _i * sum_1))\n        terms_2 = -np.exp(1 / _i * sum_2)\n\n        # Calculate Ackley function value\n        terms_3 = np.e + self._alpha\n        return terms_1 + terms_2 + terms_3\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Ackley function.\"\"\"\n        return MinimaAPI(f_x=0.0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#bukin-function-n-6","title":"Bukin Function N. 6","text":"<p>Bukin function number 6.</p> <p>The Bukin function number 6 is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n&gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bukin function number 6 is defined as:</p> \\[     f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +     0.01 \\left| x + 10 \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class BukinN6Function(OptFunction):\n    r\"\"\"Bukin function number 6.\n\n    The Bukin function number 6 is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n        &gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Bukin function number 6 is defined as:\n\n        $$\n            f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +\n            0.01 \\left| x + 10 \\right|\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/bukin6.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Bukin\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Bukin function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = 100 * np.sqrt(np.abs(x_2 - 0.01 * x_1**2))\n        term_2 = 0.01 * np.abs(x_1 + 10)\n\n        return term_1 + term_2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(-10.0, 1.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#cross-in-tray-function","title":"Cross-in-Tray Function","text":"<p>Cross-in-tray function.</p> <p>The Cross-in-tray function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cross-in-tray function is defined as:</p> \\[     f(x) = -0.0001 \\cdot \\left( \\left| \\sin(x_1) \\sin(x_2)     \\exp \\left( \\left| 100 - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right) \\right|     + 1 \\right)^{0.1} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class CrossInTrayFunction(OptFunction):\n    r\"\"\"Cross-in-tray function.\n\n    The Cross-in-tray function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Cross-in-tray function is defined as:\n\n        $$\n            f(x) = -0.0001 \\cdot \\left( \\left| \\sin(x_1) \\sin(x_2)\n            \\exp \\left( \\left| 100 - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right) \\right|\n            + 1 \\right)^{0.1}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/crossit.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Cross-in-tray\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Cross-in-tray function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(x_1) * np.sin(x_2)\n        term_2 = np.exp(np.abs(100 - np.sqrt(x_1**2 + x_2**2) / np.pi))\n        return -0.0001 * np.abs(term_1 * term_2 + 1) ** 0.1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-2.06261,\n            x=tuple(\n                np.array([1.34941, 1.34941]),\n                np.array([-1.34941, -1.34941]),\n                np.array([1.34941, -1.34941]),\n                np.array([-1.34941, 1.34941]),\n            ),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#drop-wave-function","title":"Drop Wave Function","text":"<p>Drop-wave function.</p> <p>The Drop-wave function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Drop-wave function is defined as:</p> \\[     f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)     / (0.5(x_1^2 + x_2^2) + 2) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class DropWaveFunction(OptFunction):\n    r\"\"\"Drop-wave function.\n\n    The Drop-wave function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Drop-wave function is defined as:\n\n        $$\n            f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)\n            / (0.5(x_1^2 + x_2^2) + 2)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/drop.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Drop-wave\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Drop-wave function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = 12 * np.sqrt(x_1**2 + x_2**2)\n        term_2 = 0.5 * (x_1**2 + x_2**2) + 2\n\n        return -((1 + np.cos(term_1)) / term_2)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=-1.0, x=tuple(0.0, 0.0))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#egg-holder-function","title":"Egg Holder Function","text":"<p>Egg-holder function.</p> <p>The Egg-holder function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n&gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Egg-holder function is defined as:</p> \\[     f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}     + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1     - (x_2 + 47) \\right|} \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class EggHolderFunction(OptFunction):\n    r\"\"\"Egg-holder function.\n\n    The Egg-holder function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n        &gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Egg-holder function is defined as:\n\n        $$\n            f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}\n            + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1\n            - (x_2 + 47) \\right|} \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/egg.html).\n\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Egg-holder\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Egg-holder function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sqrt(np.abs(x_2 + 47 + x_1 / 2))\n        term_2 = np.sqrt(np.abs(x_1 - (x_2 + 47)))\n\n        return -(x_2 + 47) * np.sin(term_1) - x_1 * np.sin(term_2)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=-959.6407, x=tuple(512, 404.2319))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#griewank-function","title":"Griewank Function","text":"<p>Griewank function.</p> <p>The Griewank function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Griewank function is defined as:</p> \\[     f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos     \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GriewankFunction(OptFunction):\n    r\"\"\"Griewank function.\n\n    The Griewank function is a multi-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Griewank function is defined as:\n\n        $$\n            f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos\n            \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/griewank.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Griewank function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n        for i, x_i in enumerate(self._x, start=1):\n            sum_ += 1 / 4000 * x_i**2\n            if i == 1:\n                prod_ = np.cos(x_i / np.sqrt(i))\n            prod_ *= np.cos(x_i / np.sqrt(i))\n\n        return sum_ - prod_ + 1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#holder-table-function","title":"Holder Table Function","text":"<p>Holder table function.</p> <p>The Holder table function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Holder table function is defined as:</p> \\[     f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /     \\pi \\right| \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class HolderTableFunction(OptFunction):\n    r\"\"\"Holder table function.\n\n    The Holder table function is a two-dimensional function with many local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Holder table function is defined as:\n\n        $$\n            f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /\n            \\pi \\right| \\right|\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/holder.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Holder table\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Holder table function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(x_1) * np.cos(x_2)\n        term_2 = np.abs(1 - np.sqrt(x_1**2 + x_2**2) / np.pi)\n        term_3 = np.exp(term_2)\n\n        return -np.abs(term_1 * term_3)\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-19.2085,\n            x=tuple(\n                np.array([8.05502, 9.66459]),\n                np.array([8.05502, -9.66459]),\n                np.array([-8.05502, 9.66459]),\n                np.array([-8.05502, -9.66459]),\n            ),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#langermann-function","title":"Langermann Function","text":"<p>Langermann function.</p> <p>The Langermann function is a multi-dimensional function with many unevenly distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Langermann function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}     (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi     \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right) \\] <p>with the constants :math:<code>c_i</code> and the :math:<code>a_{ij}</code> given by:</p> \\[     c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =     \\left\\{ 3, 5, 2, 1, 7 \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Matrix of constants :math:<code>a_{ij}</code>. The numbers of rows has to be equal to the number of input data, respectively, dimensions. Defaults to :math:<code>a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}</code>.</p> <code>None</code> <code>c</code> <code>UniversalArray</code> <p>Vector of constants :math:<code>c_i</code>. Defaults to :math:<code>c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}</code>.</p> <code>None</code> <code>m</code> <code>int</code> <p>Number of local minima. Defaults to 5.</p> <code>5</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LangermannFunction(OptFunction):\n    r\"\"\"Langermann function.\n\n    The Langermann function is a multi-dimensional function with many unevenly\n    distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Langermann function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}\n            (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi\n            \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right)\n        $$\n\n        with the constants :math:`c_i` and the :math:`a_{ij}` given by:\n\n        $$\n            c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =\n            \\left\\{ 3, 5, 2, 1, 7 \\right\\}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/langer.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        A (UniversalArray, optional): Matrix of constants :math:`a_{ij}`. The numbers\n            of rows has to be equal to the number of input data, respectively,\n            dimensions. Defaults to :math:`a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}`.\n        c (UniversalArray, optional): Vector of constants :math:`c_i`. Defaults to\n            :math:`c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}`.\n        m (int, optional): Number of local minima. Defaults to 5.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        A: UniversalArray = None,\n        c: UniversalArray = None,\n        m: int = 5,\n    ) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n        if A is None:\n            A = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\n\n        if c is None:\n            c = np.array([1, 2, 5, 2, 3], dtype=float)\n\n        if len(x) != A.shape[0]:\n            msg = \"Dimension of x must match number of rows in A.\"\n            raise ValueError(msg)\n\n        if len(A.shape) != __2d__:\n            msg = (\n                \"A must be two dimensional array. In case of one input the  \"\n                \"array must lool like 'np.array([[...]])'. \"\n            )\n            raise ValueError(\n                msg,\n            )\n        if A.shape[1] != m:\n            raise MatchLengthError(_object=\"A\", _target=\"m\")\n\n        if len(c) != m:\n            raise MatchLengthError(_object=\"C\", _target=\"m\")\n\n        if len(c.shape) != __1d__:\n            msg = \"c must be one dimensional array.\"\n            raise ValueError(msg)\n\n        self.a_matrix = A\n        self._c = c\n        self._m = m\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Langermann function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        outer_sum = np.zeros_like(self._x[0])\n        for i in range(self._m):\n            inner_sum = np.zeros_like(self._x[0])\n            for j, _x in enumerate(self._x):\n                inner_sum += (_x - self.a_matrix[j, i]) ** 2\n            outer_sum += (\n                self._c[i] * np.exp(-inner_sum / np.pi) * np.cos(np.pi * inner_sum)\n            )\n        return outer_sum\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(\n                np.array([self.a_matrix[0, i], self.a_matrix[1, i]])\n                for i in range(self._m)\n            ),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#levy-function","title":"Levy Function","text":"<p>Levy function.</p> <p>The Levy function is a multi-dimensional function with many local and harmonic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy function is defined as:</p> \\[     f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[     1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]     + \\left( w_d - 1 \\right)^2 \\left[     1 + \\sin^2( 2 \\pi w_d ) \\right] \\] <p>with the :math:<code>w_i</code> given by:</p> \\[     w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in     \\left\\{ 1, \\dots, d \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyFunction(OptFunction):\n    r\"\"\"Levy function.\n\n    The Levy function is a multi-dimensional function with many local and harmonic\n    distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Levy function is defined as:\n\n        $$\n            f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[\n            1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]\n            + \\left( w_d - 1 \\right)^2 \\left[\n            1 + \\sin^2( 2 \\pi w_d ) \\right]\n        $$\n\n        with the :math:`w_i` given by:\n\n        $$\n            w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in\n            \\left\\{ 1, \\dots, d \\right\\}\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Levy function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n\n        term_1 = np.sin(np.pi * (1 + (1 / 4) * (self._x[0] - 1))) ** 2\n\n        if len(self._x) == 1:\n            return term_1\n\n        for i in range(1, len(self._x) - 1):\n            term_2 = (1 + (1 / 4) * (self._x[i] - 1)) ** 2\n            term_3 = 1 + 10 * np.sin(np.pi * (1 + (1 / 4) * (self._x[i] - 1)) + 1) ** 2\n            sum_ += term_2 * term_3\n\n        term_4 = (1 + (1 / 4) * (self._x[-1] - 1)) ** 2\n        term_5 = (1 + np.sin(2 * np.pi * (1 + (1 / 4) * (self._x[-1] - 1)))) ** 2\n        sum_ += term_4 * term_5\n        return term_1 + sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([1.0]) for _ in range(len(self._x))),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#levy-function-n-13","title":"Levy Function N. 13","text":"<p>Levy N. 13 function.</p> <p>The Levy N. 13 function is a two-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy N. 13 function is defined as:</p> \\[     f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1     + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1     + \\sin^2( 2 \\pi x_2 ) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyN13Function(OptFunction):\n    r\"\"\"Levy N. 13 function.\n\n    The Levy N. 13 function is a two-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Levy N. 13 function is defined as:\n\n        $$\n            f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 2 \\pi x_2 ) \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy13.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Levy N. 13\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Levy N. 13 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n\n        term_1 = np.sin(3 * np.pi * x_1) ** 2\n        term_2 = (x_1 - 1) ** 2\n        term_3 = 1 + np.sin(3 * np.pi * x_2) ** 2\n        term_4 = (x_2 - 1) ** 2\n        term_5 = 1 + np.sin(2 * np.pi * x_2) ** 2\n        return term_1 + term_2 * term_3 + term_4 * term_5\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(1.0, 1.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#rastrigin-function","title":"Rastrigin Function","text":"<p>Rastrigin function.</p> <p>The Rastrigin function is a multi-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n&gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rastrigin function is defined as:</p> \\[     f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class RastriginFunction(OptFunction):\n    r\"\"\"Rastrigin function.\n\n    The Rastrigin function is a multi-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n        &gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rastrigin function is defined as:\n\n        $$\n            f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rastr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rastrigin function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        sum_ = np.zeros_like(self._x[0])\n        for x_i in self._x:\n            sum_ += x_i**2 - 10 * np.cos(2 * np.pi * x_i)\n        return 10 * len(self._x) + sum_\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([0.0]) for _ in range(len(self._x))),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schaffer-function-n-2","title":"Schaffer Function N. 2","text":"<p>Schaffer N. 2 function.</p> <p>The Schaffer N. 2 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 2 function is defined as:</p> \\[     f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|     \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN2Function(OptFunction):\n    r\"\"\"Schaffer N. 2 function.\n\n    The Schaffer N. 2 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schaffer N. 2 function is defined as:\n\n        $$\n            f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|\n            \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer2.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Schaffer N. 2\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schaffer N. 2 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            0.5\n            + (np.sin(np.abs(x_1**2 + x_2**2)) ** 2 - 0.5)\n            / (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\n\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schaffer-function-n-4","title":"Schaffer Function N. 4","text":"<p>Schaffer N. 4 function.</p> <p>The Schaffer N. 4 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 4 function is defined as:</p> \\[     f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }     { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN4Function(OptFunction):\n    r\"\"\"Schaffer N. 4 function.\n\n    The Schaffer N. 4 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schaffer N. 4 function is defined as:\n\n        $$\n            f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }\n            { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer4.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Schaffer N. 4\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schaffer N. 4 function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            0.5\n            + (np.sin(np.sqrt(x_1**2 + x_2**2)) ** 2 - 0.5)\n            / (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schwefel-function","title":"Schwefel Function","text":"<p>Schwefel function.</p> <p>The Schwefel function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schwefel function is defined as:</p> \\[     f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin     \\left( \\sqrt{ \\left| x_i \\right| } \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchwefelFunction(OptFunction):\n    r\"\"\"Schwefel function.\n\n    The Schwefel function is a multi-dimensional function with a\n    single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Schwefel function is defined as:\n\n        $$\n            f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin\n            \\left( \\sqrt{ \\left| x_i \\right| } \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schwef.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Schwefel function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        return 418.9829 * len(self._x) - np.sum(\n            self._x * np.sin(np.sqrt(np.abs(self._x))),\n            axis=0,\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(420.968746, 420.968746),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#shubert-function","title":"Shubert Function","text":"<p>Shubert function.</p> <p>The Shubert function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Shubert function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +     \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class ShubertFunction(OptFunction):\n    r\"\"\"Shubert function.\n\n    The Shubert function is a two-dimensional function with a\n    single global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Shubert function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +\n            \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/shubert.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Shubert\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Shubert function at x.\n\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return np.sum(\n            np.array(\n                [\n                    i * np.cos((i + 1) * x_1 + i) + i * np.cos((i + 1) * x_2 + i)\n                    for i in range(1, 6)\n                ],\n            ),\n            axis=0,\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the function.\"\"\"\n        return MinimaAPI(f_x=-186.7309, x=(-7.708309818, -0.800371886))\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/","title":"Plate Shaped","text":""},{"location":"modules/functions/optimization/plate_shaped/#booth-function","title":"Booth Function","text":"<p>Booth Function.</p> <p>The Booth function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Booth function is defined as:</p> \\[     f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class BoothFunction(OptFunction):\n    r\"\"\"Booth Function.\n\n    The Booth function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Booth function is defined as:\n\n        $$\n            f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/booth.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            msg = f\"Expected 2 arguments, but got {len(x)}.\"\n            raise ValueError(msg)\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Booth function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (x_1 + 2 * x_2 - 7) ** 2 + (2 * x_1 + x_2 - 5) ** 2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Booth function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(1.0, 3.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#matyas-function","title":"Matyas Function","text":"<p>Matyas Function.</p> <p>The Matyas function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Matyas function is defined as:</p> \\[     f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class MatyasFunction(OptFunction):\n    r\"\"\"Matyas Function.\n\n    The Matyas function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Matyas function is defined as:\n\n        $$\n            f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/matya.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Matyas\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the Matyas function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 0.26 * (x_1**2 + x_2**2) - 0.48 * x_1 * x_2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Matyas function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#mccormick-function","title":"McCormick Function","text":"<p>McCormick Function.</p> <p>The McCormick function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n&gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The McCormick function is defined as:</p> \\[     f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class McCormickFunction(OptFunction):\n    r\"\"\"McCormick Function.\n\n    The McCormick function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n        &gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The McCormick function is defined as:\n\n        $$\n            f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/mccorm.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the McCormick function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return np.sin(x_1 + x_2) + (x_1 - x_2) ** 2 - 1.5 * x_1 + 2.5 * x_2 + 1\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the McCormick function.\"\"\"\n        return MinimaAPI(\n            f_x=-1.9133,\n            x=(-0.54719, -1.54719),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#power-sum-function","title":"Power Sum Function","text":"<p>Power Sum Function.</p> <p>The Power Sum function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Power Sum function is defined as:</p> \\[     f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class PowerSumFunction(OptFunction):\n    r\"\"\"Power Sum Function.\n\n    The Power Sum function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Power Sum function is defined as:\n\n        $$\n            f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/powersum.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Power Sum\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Evaluate the Power Sum function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return x_1**2 + x_2**2 + x_1**4 + x_2**4\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Power Sum function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=(0.0, 0.0),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#zakharov-function","title":"Zakharov Function","text":"<p>Zakharov Function.</p> <p>The Zakharov function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zakharov function is defined as:</p> \\[     f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2     + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZakharovFunction(OptFunction):\n    r\"\"\"Zakharov Function.\n\n    The Zakharov function is a two-dimensional function with a single global\n    minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zakharov function is defined as:\n\n        $$\n            f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2\n            + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zakharov.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArrayTuple:\n        \"\"\"Evaluate the Zakharov function at x.\"\"\"\n        sum_1 = np.zeros_like(self._x[0])\n        sum_2 = np.zeros_like(self._x[0])\n\n        for i in range(self.dimension):\n            sum_1 += self._x[i] ** 2\n            sum_2 += 0.5 * (i + 1) * self._x[i]\n\n        return sum_1 + sum_2**2 + sum_2**4\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zakharov function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.zeros_like(self.dimension)),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#zettl-function","title":"Zettl Function","text":"<p>Zettl function.</p> <p>The Zettl function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zettl function is defined as:</p> \\[     f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZettlFunction(OptFunction):\n    r\"\"\"Zettl function.\n\n    The Zettl function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Zettl function is defined as:\n\n        $$\n            f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zettl.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            msg = f\"Expected 2 arguments, but got {len(x)}.\"\n            raise ValueError(msg)\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Zettl function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return (\n            self._x[0] ** 2 + self._x[1] ** 2 - 2 * self._x[0]\n        ) ** 2 + 0.25 * self._x[0]\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Zettl function.\n\n        Returns:\n            MinimaAPI: Minima of the Zettl function.\n        \"\"\"\n        return MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/special/","title":"Special","text":""},{"location":"modules/functions/optimization/special/#beale-function","title":"Beale Function","text":"<p>Beale function.</p> <p>The Beale function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n&gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Beale function is defined as:</p> \\[     f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BealeFunction(OptFunction):\n    r\"\"\"Beale function.\n\n    The Beale function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n        &gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Beale function is defined as:\n\n        $$\n            f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/beale.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Beale\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Beale function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        return (\n            (1.5 - x + x * y) ** 2\n            + (2.25 - x + x * y**2) ** 2\n            + (2.625 - x + x * y**3) ** 2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Beale function.\n\n        Returns:\n            MinimaAPI: Minima of the Beale function.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=(0.5))\n</code></pre>"},{"location":"modules/functions/optimization/special/#branin-function","title":"Branin Function","text":"<p>Branin function.</p> <p>The Branin function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(0, 15, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Branin function is defined as:</p> \\[     f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s \\] <p>where</p> \\[     a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BraninFunction(OptFunction):\n    r\"\"\"Branin function.\n\n    The Branin function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(0, 15, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Branin function is defined as:\n\n        $$\n            f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s\n        $$\n\n        where\n\n        $$\n            a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi)\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/branin.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Branin\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Branin function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        a = 1\n        b = 5.1 / (4 * np.pi**2)\n        c = 5 / np.pi\n        r = 6\n        s = 10\n        t = 1 / (8 * np.pi)\n        return a * (y - b * x**2 + c * x - r) ** 2 + s * (1 - t) * np.cos(y) + s\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Branin function.\n\n        Returns:\n            MinimaAPI: Minima of the Branin function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.397887,\n            x=tuple(\n                np.array([-np.pi, 12.275]),\n                np.array([np.pi, 2.275]),\n                np.array([np.pi, 9.42478]),\n                np.array([9.42478, 2.475]),\n            ),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/special/#goldstein-price-function","title":"Goldstein-Price Function","text":"<p>Goldstein-Price function.</p> <p>The Goldstein-Price function is a two-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function is defined as:</p> \\[     f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2     \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)     \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2     \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right) \\] <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceFunction(OptFunction):\n    r\"\"\"Goldstein-Price function.\n\n    The Goldstein-Price function is a two-dimensional function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Goldstein-Price function is defined as:\n\n        $$\n            f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2\n            \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)\n            \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2\n            \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right)\n        $$\n\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Goldstein-Price\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Goldstein-Price function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return (\n            1\n            + (self._x[0] + self._x[1] + 1) ** 2\n            * (\n                19\n                - 14 * self._x[0]\n                + 3 * self._x[0] ** 2\n                - 14 * self._x[1]\n                + 6 * self._x[0] * self._x[1]\n                + 3 * self._x[1] ** 2\n            )\n        ) * (\n            30\n            + (2 * self._x[0] - 3 * self._x[1]) ** 2\n            * (\n                18\n                - 32 * self._x[0]\n                + 12 * self._x[0] ** 2\n                + 48 * self._x[1]\n                - 36 * self._x[0] * self._x[1]\n                + 27 * self._x[1] ** 2\n            )\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Goldstein-Price function.\n\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/functions/optimization/special/#goldstein-price-log-function","title":"Goldstein-Price Log Function","text":"<p>Goldstein-Price function in logarithmic form.</p> <p>The Goldstein-Price function in logarithmic form is a two-dimensional function. In this form, the function offers a better conditioning by using the logarithm.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function in logarithmic form is defined as:</p> <p>$$     f(x, y) = frac{1}{2.427} left[     log left( 1 + left( bar{x}_1 + bar{x}_2 + 1 right)^2     left( 19 - 14 x + 3 bar{x}_1^2 - 14 bar{x}_2 + 6 bar{x}_1 bar{x}_2     + 3 bar{x}_2^2 right) right) + log left( 30 + left( 2 bar{x}_1 - 3     bar{x}_2 right)^2 left( 18 - 32 bar{x}_1 + 12 bar{x}_1^2 + 48     bar{x}_2 - 36 bar{x}_1 bar{x}_2 + 27 y^2 right) right) - 8.683 right]</p> Scdoc<pre><code>\\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n</code></pre> <p>$$</p> <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceLogFunction(OptFunction):\n    r\"\"\"Goldstein-Price function in logarithmic form.\n\n    The Goldstein-Price function in logarithmic form is a two-dimensional function.\n    In this form, the function offers a better conditioning by using the logarithm.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Goldstein-Price function in logarithmic form is defined as:\n\n        $$\n            f(x, y) = \\frac{1}{2.427} \\left[\n            \\log \\left( 1 + \\left( \\bar{x}_1 + \\bar{x}_2 + 1 \\right)^2\n            \\left( 19 - 14 x + 3 \\bar{x}_1^2 - 14 \\bar{x}_2 + 6 \\bar{x}_1 \\bar{x}_2\n            + 3 \\bar{x}_2^2 \\right) \\right) + \\log \\left( 30 + \\left( 2 \\bar{x}_1 - 3\n            \\bar{x}_2 \\right)^2 \\left( 18 - 32 \\bar{x}_1 + 12 \\bar{x}_1^2 + 48\n            \\bar{x}_2 - 36 \\bar{x}_1 \\bar{x}_2 + 27 y^2 \\right) \\right) - 8.683 \\right]\n\n            \\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n        $$\n\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Goldstein-Price\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Goldstein-Price function in logarithmic form at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x_1 = 4 * self._x[0] - 2\n        x_2 = 4 * self._x[1] - 2\n        return (\n            1\n            / 2.427\n            * (\n                np.log(\n                    1\n                    + (x_1 + x_2 + 1) ** 2\n                    * (\n                        19\n                        - 14 * x_1\n                        + 3 * x_1**2\n                        - 14 * x_2\n                        + 6 * x_1 * x_2\n                        + 3 * x_2**2\n                    ),\n                )\n                + np.log(\n                    30\n                    + (2 * x_1 - 3 * x_2) ** 2\n                    * (\n                        18\n                        - 32 * x_1\n                        + 12 * x_1**2\n                        + 48 * x_2\n                        - 36 * x_1 * x_2\n                        + 27 * x_2**2\n                    ),\n                )\n                - 8.683\n            )\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Goldstein-Price function in logarithmic form.\n\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function in logarithmic form.\n        \"\"\"\n        return MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/functions/optimization/special/#himmelblau-function","title":"Himmelblau Function","text":"<p>Himmelblau function.</p> <p>The Himmelblau function is a two-dimensional function with four global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import HimmelblauFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HimmelblauFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HimmelblauFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Himmelblau function is defined as:</p> \\[     f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class HimmelblauFunction(OptFunction):\n    r\"\"\"Himmelblau function.\n\n    The Himmelblau function is a two-dimensional function with four global minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import HimmelblauFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HimmelblauFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HimmelblauFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Himmelblau function is defined as:\n\n        $$\n            f(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/himmel.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"Himmelblau\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Himmelblau function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        x, y = self._x[0], self._x[1]\n        return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Himmelblau function.\n\n        Returns:\n            MinimaAPI: Minima of the Himmelblau function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(\n                np.array([3.0, 2.0]),\n                np.array([-2.805118, 3.131312]),\n                np.array([-3.779310, -3.283186]),\n                np.array([3.584428, -1.848126]),\n            ),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/special/#styblinski-tang-function","title":"Styblinski-Tang Function","text":"<p>Styblinski-Tang function.</p> <p>The Styblinski-Tang function is a D-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Styblinski-Tang function is defined as:</p> \\[     f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right) \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-5, 5]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class StyblinskiTangFunction(OptFunction):\n    r\"\"\"Styblinski-Tang function.\n\n    The Styblinski-Tang function is a D-dimensional function.\n\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Styblinski-Tang function is defined as:\n\n        $$\n            f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right)\n        $$\n\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-5, 5]$ for all $i$.\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/stybtang.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Styblinski-Tang function at x.\n\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\n        return np.array(\n            0.5\n            * sum(\n                (self._x[i - 1] ** 4 - 16 * self._x[i - 1] ** 2 + 5 * self._x[i - 1])\n                for i in range(1, self.dimension + 1)\n            ),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the Styblinski-Tang function.\n\n        Returns:\n            MinimaAPI: Minima of the Styblinski-Tang function.\n        \"\"\"\n        return MinimaAPI(\n            f_x=-39.16616570377142,\n            x=tuple(np.ones(self.dimension) * -2.903534),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/","title":"Valley Shaped","text":""},{"location":"modules/functions/optimization/valley_shaped/#three-hump-camel-function","title":"Three Hump Camel Function","text":"<p>Three-hump camel function.</p> <p>The three-hump camel function is a two-dimensional function with three minima, where one of the minima is a global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The three-hump camel function is defined as:</p> \\[ f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class ThreeHumpCamelFunction(OptFunction):\n    r\"\"\"Three-hump camel function.\n\n    The three-hump camel function is a two-dimensional function with three\n    minima, where one of the minima is a global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The three-hump camel function is defined as:\n\n        $$\n        f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel3.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the three-hump camel function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"ThreeHumpCamel\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the three-hump camel function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return 2 * x_1**2 - 1.05 * x_1**4 + (x_1**6) / 6 + x_1 * x_2 + x_2**2\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the three-hump camel function.\"\"\"\n        return MinimaAPI(\n            f_x=np.array([0.0, 0.0]),\n            x=tuple(np.array([0.0])),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#six-hump-camel-function","title":"Six Hump Camel Function","text":"<p>Six-hump camel function.</p> <p>The six-hump camel function is a two-dimensional function with six minima, where two of them are global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The six-hump camel function is defined as:</p> \\[ f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class SixHumpCamelFunction(OptFunction):\n    r\"\"\"Six-hump camel function.\n\n    The six-hump camel function is a two-dimensional function with six\n    minima, where two of them are global minima.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The six-hump camel function is defined as:\n\n        $$\n        f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel6.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the six-hump camel function.\"\"\"\n        if len(x) != __2d__:\n            raise OutOfDimensionError(\n                function_name=\"SixHumpCamel\",\n                dimension=__2d__,\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate the six-hump camel function at x.\"\"\"\n        x_1 = self._x[0]\n        x_2 = self._x[1]\n        return (\n            (4 - 2.1 * x_1**2 + (x_1**4) / 3) * x_1**2\n            + x_1 * x_2\n            + (-4 + 4 * x_2**2) * x_2**2\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the minima of the six-hump camel function.\"\"\"\n        return MinimaAPI(\n            f_x=-1.031628453489877,\n            x=tuple(np.array([0.0898, -0.7126], [-0.0898, 0.7126])),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#dixon-price-function","title":"Dixon-Price Function","text":"<p>Dixon-Price function.</p> <p>The Dixon-Price function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Dixon-Price function is defined as:</p> \\[ f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class DixonPriceFunction(OptFunction):\n    r\"\"\"Dixon-Price function.\n\n    The Dixon-Price function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Dixon-Price function is defined as:\n\n        $$\n        f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/dixonpr.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the Dixon-Price function.\"\"\"\n        if len(x) &lt; __2d__:\n            raise TooSmallDimensionError(\n                function_name=\"DixonPrice\",\n                dimension=__2d__,\n                len_x=len(x),\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Dixon-Price function at x.\"\"\"\n        x = self._x\n\n        return (x[0] - 1) ** 2 + sum(\n            (i + 1) * (x[i] - x[i - 1] ** 2) ** 2 for i in range(1, len(x))\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the zero function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([2 ** (-i) for i in range(1, len(self._x) + 1)])),\n        )\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#rosenbrock-function","title":"Rosenbrock Function","text":"<p>Rosenbrock function.</p> <p>The Rosenbrock function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rosenbrock function is defined as:</p> \\[ f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class RosenbrockFunction(OptFunction):\n    r\"\"\"Rosenbrock function.\n\n    The Rosenbrock function is a multi-dimensional function with a single\n    global minimum.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n\n    Notes:\n        The Rosenbrock function is defined as:\n\n        $$\n        f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right]\n        $$\n\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rosen.html).\n\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray) -&gt; None:\n        \"\"\"Initialize the Rosenbrock function.\"\"\"\n        if len(x) &lt; __2d__:\n            raise TooSmallDimensionError(\n                function_name=\"Rosenbrock\",\n                dimension=__2d__,\n                len_x=len(x),\n            )\n        super().__init__(*x)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Evaluate Rosenbrock function at x.\"\"\"\n        x = self._x\n\n        return np.array(\n            sum(\n                100 * (x[i + 1] - x[i] ** 2) ** 2 + (1 - x[i]) ** 2\n                for i in range(len(x) - 1)\n            ),\n        )\n\n    @property\n    def __minima__(self) -&gt; MinimaAPI:\n        \"\"\"Return the zero function.\"\"\"\n        return MinimaAPI(\n            f_x=0.0,\n            x=tuple(np.array([1.0 for _ in range(len(self._x))])),\n        )\n</code></pre>"},{"location":"modules/functions/others/support_functions/","title":"Supporting Functions","text":""},{"location":"modules/functions/others/support_functions/#support-functions","title":"Support Functions","text":"<p>Info</p> <p>Please note that the following functions in the module are not meant to be used directly, as they are used by other functions within the module. The goal of <code>useful-math-functions</code> is to minimize the use of third-party dependencies in its functions. However, certain functions are utilized by multiple other functions, and are therefore implemented in the <code>support_functions</code> module to avoid duplicating code. Additionally, some functions still require the <code>scipy</code> package in order to be fully executed.</p> <p>Compute the Faddeeva function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def wofz(z: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Compute the Faddeeva function for a given complex argument.\"\"\"\n    return np.exp(-(z**2)) * numeric_erfc(-1j * z)\n</code></pre> <p>Compute the complementary error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def erfc(z: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Compute the complementary error function for a given complex argument.\"\"\"\n    return 1 - erf(z)\n</code></pre> <p>Compute the complementary error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def numeric_erfc(z: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Compute the complementary error function for a given complex argument.\"\"\"\n    return 1 - numeric_erf(z)\n</code></pre> <p>Return the error function of x.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def erf(x: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Return the error function of x.\"\"\"\n    return np.vectorize(math.erf)(x)\n</code></pre> <p>Compute the error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def numeric_erf(z: UniversalArray) -&gt; UniversalArray:\n    \"\"\"Compute the error function for a given complex argument.\"\"\"\n    z = np.asarray(z)\n    sign: UniversalArray = np.sign(z)\n    z = sign * z\n    t = 1 / (1 + 0.5 * z)\n    result = 1 - t * np.exp(\n        -(z**2)\n        - 1.26551223\n        + 1.00002368 * t\n        + 0.37409196 * t**2\n        + 0.09678418 * t**3\n        - 0.18628806 * t**4\n        + 0.27886807 * t**5\n        - 1.13520398 * t**6\n        + 1.48851587 * t**7\n        - 0.82215223 * t**8\n        + 0.17087277 * t**9,\n    )\n    return sign * result\n</code></pre> <p>Return the gamma function of x using the Lanczos approximation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> required <code>batch_size</code> <code>int</code> <p>The batch size for the Lanczos approximation. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The gamma function of x using the Lanczos approximation.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def gamma(x: UniversalArray, batch_size: int = 100) -&gt; UniversalArray:\n    \"\"\"Return the gamma function of x using the Lanczos approximation.\n\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        batch_size (int): The batch size for the Lanczos approximation. Defaults to 100.\n\n    Returns:\n        UniversalArray: The gamma function of x using the Lanczos approximation.\n    \"\"\"\n\n    # Define the coefficients of the Lanczos approximation\n    def _gamma(x: UniversalArray) -&gt; UniversalArray:\n        \"\"\"Return the gamma function of x using the Lanczos approximation.\"\"\"\n        g = 7\n        p: list[float] = [\n            0.99999999999980993,\n            676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7,\n        ]\n\n        if np.any(np.less(x, 0.5)):\n            return np.pi / (np.sin(np.pi * x) * _gamma(1 - x))\n        x = x - 1\n        a = p[0] + np.sum([p[i] / (x + i) for i in range(1, len(p))], axis=0)\n        t = x + g + 0.5\n        return np.sqrt(2 * np.pi) * np.power(t, x + 0.5) * np.exp(-t) * a\n\n    y: UniversalArray = np.zeros_like(x)\n\n    for i in range(0, len(x), batch_size):\n        y[i : i + batch_size] = _gamma(x[i : i + batch_size])\n    return y\n</code></pre> <p>Return the number of combinations of n things taken k at a time.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | ndarray</code> <p>The number of things.</p> required <code>k</code> <code>int | ndarray</code> <p>The number of things taken at a time.</p> required <p>Returns:</p> Type Description <code>int | ndarray</code> <p>int | np.ndarray: The number of combinations of n things taken k at a time.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def combinations(n: int | np.ndarray, k: int | np.ndarray) -&gt; int | np.ndarray:\n    \"\"\"Return the number of combinations of n things taken k at a time.\n\n    Args:\n        n (int | np.ndarray): The number of things.\n        k (int | np.ndarray): The number of things taken at a time.\n\n    Returns:\n        int | np.ndarray: The number of combinations of n things taken k at a time.\n    \"\"\"\n    n = np.array(n, dtype=int)\n    k = np.array(k, dtype=int)\n    if n.ndim == 0:\n        return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n    c: np.ndarray = np.zeros_like(n)\n    for i in np.ndindex(n.shape):\n        c[i] = math.factorial(n[i]) // (\n            math.factorial(k[i]) * math.factorial(n[i] - k[i])\n        )\n    return c\n</code></pre>"},{"location":"modules/functions/theory/pathological/","title":"Pathological","text":""},{"location":"modules/functions/theory/pathological/#weierstrass-function","title":"Weierstrass Function","text":"<p>Weierstrass function.</p> <p>The Weierstrass function is a famous example of a real-valued function that is continuous everywhere but differentiable nowhere. It is defined by an infinite series that oscillates too wildly to settle down to a smooth curve.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import WeierstrassFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n&gt;&gt;&gt; wf = WeierstrassFunction(x, n=20, a=0.5, b=30)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...             -3 + zoom_factor / 1.3, 3 - zoom_factor/ 1.3\n...         )\n...     ax.set_ylim(\n...             -2.5 + zoom_factor / 2.5, 2.5 - zoom_factor / 5\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('WeierstrassFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Weierstrass function is a prototypical example of a pathological function in mathematical analysis. Its definition challenges the intuition that a continuous function must be smooth.</p> \\[ W(x) = \\sum_{n=0}^{n_1} a^n \\cos(b^n \\pi x) \\] <p>with constraints \\(0 &lt; a &lt; 1\\) and \\(ab &gt; 1 + 3\\pi/2\\).</p> <p>Reference: en.wikipedia.org/wiki/Weierstrass_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Weierstrass function is evaluated.</p> <code>()</code> <code>n</code> <code>int</code> <p>The upper limit of the summation. Defaults to 10.</p> <code>10</code> <code>a</code> <code>float</code> <p>A parameter of the function that controls the amplitude of oscillations. Must be in the range (0, 1). Defaults to 0.9.</p> <code>0.9</code> <code>b</code> <code>float</code> <p>A parameter of the function that controls the frequency of oscillations. Must satisfy the condition a * b &gt; (1 + 3 * np.pi / 2). Defaults to 7.</p> <code>7</code> <p>Raises:</p> Type Description <code>NotInRangesError</code> <p>If \\(a\\) is not in the range \\((0, 1)\\).</p> <code>NotLargerThanAnyError</code> <p>If \\(a * b\\) is not larger than \\((1 + 3 * np.pi / 2)\\).</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class WeierstrassFunction(PathologicalWithCoefficients):\n    r\"\"\"Weierstrass function.\n\n    The Weierstrass function is a famous example of a real-valued function that is\n    continuous everywhere but differentiable nowhere. It is defined by an infinite\n    series that oscillates too wildly to settle down to a smooth curve.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import WeierstrassFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n        &gt;&gt;&gt; wf = WeierstrassFunction(x, n=20, a=0.5, b=30)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...             -3 + zoom_factor / 1.3, 3 - zoom_factor/ 1.3\n        ...         )\n        ...     ax.set_ylim(\n        ...             -2.5 + zoom_factor / 2.5, 2.5 - zoom_factor / 5\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('WeierstrassFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Weierstrass function is a prototypical example of a pathological\n        function in mathematical analysis. Its definition challenges the\n        intuition that a continuous function must be smooth.\n\n        $$\n        W(x) = \\sum_{n=0}^{n_1} a^n \\cos(b^n \\pi x)\n        $$\n\n        with constraints $0 &lt; a &lt; 1$ and $ab &gt; 1 + 3\\pi/2$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Weierstrass_function\n\n    Args:\n        *x (UniversalArray): Input values for which the Weierstrass function is\n            evaluated.\n        n (int, optional): The upper limit of the summation. Defaults to 10.\n        a (float, optional): A parameter of the function that controls the amplitude of\n            oscillations. Must be in the range (0, 1). Defaults to 0.9.\n        b (float, optional): A parameter of the function that controls the frequency\n            of oscillations. Must satisfy the condition a * b &gt; (1 + 3 * np.pi / 2).\n            Defaults to 7.\n\n    Raises:\n        NotInRangesError: If $a$ is not in the range $(0, 1)$.\n        NotLargerThanAnyError: If $a * b$ is not larger than $(1 + 3 * np.pi / 2)$.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        n: int = 10,\n        a: float = 0.9,\n        b: float = 7,\n    ) -&gt; None:\n        \"\"\"Initialize the Weierstrass function.\"\"\"\n        if not 0 &lt; a &lt; 1:\n            raise NotInRangesError(var_number=\"a\", number=a, ranges=(0, 1))\n\n        if a * b &lt;= (1 + 3 * np.pi / 2):\n            raise NotLargerThanAnyError(\n                var_number=\"a * b\",\n                number=a * b,\n                minimum=(1 + 3 * np.pi / 2),\n            )\n        super().__init__(*x, n_0=0, n_1=n, a=a, b=b)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Weierstrass function.\n\n        Returns:\n            UniversalArray: The Weierstrass function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(self.n_0, self.n_1 + 1):\n            result += self.a**n * np.cos(self.b**n * np.pi * self._x)\n        return result\n</code></pre>"},{"location":"modules/functions/theory/pathological/#riemann-function","title":"Riemann Function","text":"<p>Riemann Function.</p> <p>The Riemann function is a mathematical function that is defined as the sum of a series of terms. Each term in the series is calculated using the Riemann zeta function and the sine function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import RiemannFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n&gt;&gt;&gt; rf = RiemannFunction(x, n=20)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, rf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...         -3 + zoom_factor / 1.3, 3 - zoom_factor / 1.3\n...         )\n...     ax.set_ylim(\n...             -2.5 + zoom_factor / 5, 2.5 - zoom_factor / 5\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('RiemannFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Riemann function is a mathematical function that is defined as the sum of a series of terms. Each term in the series is calculated using the Riemann zeta function and the sine function.</p> \\[ R(x) = \\sum_{n=1}^{n_1} \\frac{1}{n^2} \\sin(n^2 \\pi x) \\] <p>Reference: en.wikipedia.org/wiki/Riemann_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The input values at which to evaluate the Riemann function.</p> <code>()</code> <code>n</code> <code>int</code> <p>The number of terms to include in the series. Defaults to 100.</p> <code>100</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class RiemannFunction(PathologicalPure):\n    r\"\"\"Riemann Function.\n\n    The Riemann function is a mathematical function that is defined as the sum of\n    a series of terms. Each term in the series is calculated using the\n    Riemann zeta function and the sine function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import RiemannFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100000)\n        &gt;&gt;&gt; rf = RiemannFunction(x, n=20)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, rf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...         -3 + zoom_factor / 1.3, 3 - zoom_factor / 1.3\n        ...         )\n        ...     ax.set_ylim(\n        ...             -2.5 + zoom_factor / 5, 2.5 - zoom_factor / 5\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('RiemannFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Riemann function is a mathematical function that is defined as the sum of\n        a series of terms. Each term in the series is calculated using the\n        Riemann zeta function and the sine function.\n\n        $$\n        R(x) = \\sum_{n=1}^{n_1} \\frac{1}{n^2} \\sin(n^2 \\pi x)\n        $$\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Riemann_function\n\n    Args:\n        *x (UniversalArray): The input values at which to evaluate the Riemann function.\n        n (int, optional): The number of terms to include in the series.\n            Defaults to 100.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n        \"\"\"Initialize the Riemann function.\"\"\"\n        super().__init__(*x, n_0=1, n_1=n)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Riemann function.\n\n        Returns:\n            UniversalArray: The Riemann function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(self.n_0, self.n_1 + 1):\n            result += (1 / n**2) * np.sin(n**2 * np.pi * self._x)\n        return result\n</code></pre>"},{"location":"modules/functions/theory/pathological/#takagi-function","title":"Takagi Function","text":"<p>Takagi Function.</p> <p>The Takagi function is a fractal-like continuous function defined on the real line. It is also known as the Takagi-Landsberg function or the Blancmange function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import TakagiFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 1.5, 100000)\n&gt;&gt;&gt; tf = TakagiFunction(x, n=20)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, tf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 25.0\n...     ax.set_xlim(\n...             -1.5 + zoom_factor / 2.5, 1.5 - zoom_factor / 2.5\n...         )\n...     ax.set_ylim(\n...          0 + zoom_factor / 25, 0.6 - zoom_factor / 25\n...         )\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('TakagiFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Takagi function is defined as the sum of a series of terms. Each term in the series is calculated using the absolute value of the fractional part of the input value raised to a power. It is also known as Blancmange curve.</p> \\[ T(x) = \\sum_{n=0}^{\\infty} \\frac{\\phi(2^n x)}{2^n} \\] <p>where \\((\\phi(x))\\) is the distance from \\((x)\\) to the nearest integer.</p> <p>Reference: en.wikipedia.org/wiki/Takagi_function</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Takagi function will be calculated.</p> <code>()</code> <code>n</code> <code>int</code> <p>Number of iterations to compute the Takagi function. Defaults to 100.</p> <code>100</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class TakagiFunction(PathologicalPure):\n    r\"\"\"Takagi Function.\n\n    The Takagi function is a fractal-like continuous function defined on the real line.\n    It is also known as the Takagi-Landsberg function or the Blancmange function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import TakagiFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 1.5, 100000)\n        &gt;&gt;&gt; tf = TakagiFunction(x, n=20)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, tf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 25.0\n        ...     ax.set_xlim(\n        ...             -1.5 + zoom_factor / 2.5, 1.5 - zoom_factor / 2.5\n        ...         )\n        ...     ax.set_ylim(\n        ...          0 + zoom_factor / 25, 0.6 - zoom_factor / 25\n        ...         )\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('TakagiFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Takagi function is defined as the sum of a series of terms. Each term in the\n        series is calculated using the absolute value of the fractional part of the\n        input value raised to a power. It is also known as Blancmange curve.\n\n        $$\n        T(x) = \\sum_{n=0}^{\\infty} \\frac{\\phi(2^n x)}{2^n}\n        $$\n\n        where $(\\phi(x))$ is the distance from $(x)$ to the nearest integer.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Takagi_function\n\n    Args:\n        *x (UniversalArray): Input values for which the Takagi function will be\n            calculated.\n        n (int, optional): Number of iterations to compute the Takagi function.\n            Defaults to 100.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 100) -&gt; None:\n        \"\"\"Initialize the Takagi function.\"\"\"\n        super().__init__(*x, n_0=0, n_1=n)\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Takagi function.\n\n        Returns:\n            UniversalArray: The Takagi function.\n        \"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(1, self.n_1):\n            result += self.phi(x=2**n * self._x) / 2**n\n        return result\n\n    @staticmethod\n    def phi(x: UniversalArray) -&gt; UniversalArray:\n        \"\"\"Calculate the distance from x to the nearest integer.\"\"\"\n        return np.abs(x - np.round(x))\n</code></pre>"},{"location":"modules/functions/theory/pathological/#mandelbrots-fractal-function","title":"Mandelbrot's Fractal Function","text":"<p>Mandelbrot's Fractal Function.</p> <p>The Mandelbrot set is a famous example of a fractal, a mathematical object that exhibits self-similarity at different scales. It is named after the mathematician Benoit Mandelbrot, who first visualized and defined it in 1980. The set is created by iterating the function f_c(z) = z^2 + c over complex numbers c, where z starts at zero. A complex number c is part of the Mandelbrot set if, when applying this iteration, the absolute value of z does not diverge to infinity no matter how many times the iteration is applied. The beauty of the Mandelbrot set lies in its complex and boundary-defining structure, which reveals an infinitely detailed and varied pattern upon magnification.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import MandelbrotsFractalFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 1000)\n&gt;&gt;&gt; rf = MandelbrotsFractalFunction(x, max_iter=50)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; ax_return= ax.imshow(\n...                rf.result,\n...                cmap='seismic',\n...                extent=(-2, 2, -2, 2),\n...                interpolation='bilinear',\n...               )\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 50.0\n...     ax.set_xlim(-2 , 2 - zoom_factor)\n...     ax.set_ylim(-2 + zoom_factor, 2 - zoom_factor)\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('MandelbrotsFractalFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Mandelbrot set is the set of complex numbers \\(\\(c\\)\\) for which the function \\(\\(f_c(z) = z^2 + c\\)\\) does not diverge when iterated from \\(\\(z = 0\\)\\). The Mandelbrot set is a fractal, meaning that it exhibits self-similarity at different scales.</p> \\[ M = \\{c \\in \\mathbb{C} : \\lim_{n \\to \\infty} |z_n| \\leq 2\\} \\] <p>where \\((z_{n+1} = z_n^2 + c)\\) and \\((z_0 = 0)\\).</p> <p>Reference: en.wikipedia.org/wiki/Mandelbrot_set</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The coordinates in the complex plane where the function will be evaluated.</p> <code>()</code> <code>max_iter</code> <code>int</code> <p>The maximum number of iterations to perform. Defaults to 100.</p> <code>100</code> <code>escape_threshold</code> <code>float</code> <p>The threshold for escaping the fractal region. Defaults to 2.0.</p> <code>2.0</code> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class MandelbrotsFractalFunction(PathologicalPure):\n    r\"\"\"Mandelbrot's Fractal Function.\n\n    The Mandelbrot set is a famous example of a fractal, a mathematical object that\n    exhibits self-similarity at different scales. It is named after the mathematician\n    Benoit Mandelbrot, who first visualized and defined it in 1980. The set is created\n    by iterating the function f_c(z) = z^2 + c over complex numbers c, where z starts\n    at zero. A complex number c is part of the Mandelbrot set if, when applying this\n    iteration, the absolute value of z does not diverge to infinity no matter how many\n    times the iteration is applied. The beauty of the Mandelbrot set lies in its\n    complex and boundary-defining structure, which reveals an infinitely detailed and\n    varied pattern upon magnification.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import MandelbrotsFractalFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 1000)\n        &gt;&gt;&gt; rf = MandelbrotsFractalFunction(x, max_iter=50)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; ax_return= ax.imshow(\n        ...                rf.result,\n        ...                cmap='seismic',\n        ...                extent=(-2, 2, -2, 2),\n        ...                interpolation='bilinear',\n        ...               )\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 50.0\n        ...     ax.set_xlim(-2 , 2 - zoom_factor)\n        ...     ax.set_ylim(-2 + zoom_factor, 2 - zoom_factor)\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('MandelbrotsFractalFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Mandelbrot set is the set of complex numbers $\\(c\\)$ for which the function\n        $\\(f_c(z) = z^2 + c\\)$ does not diverge when iterated from $\\(z = 0\\)$. The\n        Mandelbrot set is a fractal, meaning that it exhibits self-similarity at\n        different scales.\n\n        $$\n        M = \\{c \\in \\mathbb{C} : \\lim_{n \\to \\infty} |z_n| \\leq 2\\}\n        $$\n\n        where $(z_{n+1} = z_n^2 + c)$ and $(z_0 = 0)$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Mandelbrot_set\n\n    Args:\n        *x (UniversalArray): The coordinates in the complex plane where the function\n            will be evaluated.\n        max_iter (int, optional): The maximum number of iterations to perform. Defaults\n            to 100.\n        escape_threshold (float, optional): The threshold for escaping the fractal\n            region. Defaults to 2.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        *x: UniversalArray,\n        max_iter: int = 100,\n        escape_threshold: float = 2.0,\n    ) -&gt; None:\n        \"\"\"Initialize the Mandelbrot's Fractal function.\"\"\"\n        super().__init__(*x, n_0=0, n_1=max_iter)\n        self.escape_threshold = escape_threshold\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Mandelbrot's Fractal function.\n\n        Returns:\n            UniversalArray: The Mandelbrot's Fractal function.\n        \"\"\"\n        height = len(self._x)\n        width = 2 * len(self._x) // 3\n        mandelbrot_set = np.zeros((height, width))\n\n        for i in range(height):\n            for j in range(width):\n                c = complex(self._x[j], self._x[i])\n                z = 0\n                for k in range(self.n_1):\n                    z: complex = z**2 + c\n                    if abs(z) &gt; self.escape_threshold:\n                        mandelbrot_set[i, j] = k\n                        break\n                else:\n                    mandelbrot_set[i, j] = self.n_1\n        return mandelbrot_set\n</code></pre>"},{"location":"modules/functions/theory/pathological/#besicovitch-function","title":"Besicovitch Function","text":"<p>Besicovitch Function.</p> <p>The Besicovitch function is a fractal-like continuous function defined on the real line. It is also known as the Besicovitch-Eggleston function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.theory.pathological import BesicovitchFunction\n&gt;&gt;&gt; x = np.linspace(0, 1, 10000)\n&gt;&gt;&gt; wf = BesicovitchFunction(x, n=30)()\n&gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n&gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n...     zoom_factor = frame / 100\n...     ax.set_xlim(0 + zoom_factor/2 ,1 - zoom_factor/2)\n...     ax.set_ylim(-1 + zoom_factor, 1 - zoom_factor)\n...     return (ax_return,)\n&gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n&gt;&gt;&gt; ani.save('BesicovitchFunction.gif', writer='imagemagick', fps=10)\n</code></pre> Notes <p>The Besicovitch function is a fractal-like continuous function defined on the real line. It is also known as the Besicovitch-Eggleston function.</p> \\[ B(x) = \\sum_{n=1}^{n_1} \\frac{\\sin(\\pi 2^n x)}{\\mu^n} \\] <p>with constraint \\(\\mu \\geq 1\\).</p> <p>Reference: en.wikipedia.org/wiki/Besicovitch</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input values for which the Weierstrass function is evaluated.</p> <code>()</code> <code>n</code> <code>int</code> <p>Number of iterations to compute the Besicovitch function. Defaults to 10.</p> <code>10</code> <code>mu</code> <code>float</code> <p>A parameter of the function that controls the frequency of oscillations. Must satisfy the condition b &gt;= 1. Defaults to 2.</p> <code>2</code> <p>Raises:</p> Type Description <code>NotLargerThanAnyError</code> <p>If \\(\\mu\\) is not larger than 1.</p> Source code in <code>umf/functions/theory/pathological.py</code> Python<pre><code>class BesicovitchFunction(PathologicalPure):\n    r\"\"\"Besicovitch Function.\n\n    The Besicovitch function is a fractal-like continuous function defined on the\n    real line. It is also known as the Besicovitch-Eggleston function.\n\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from matplotlib.animation import FuncAnimation\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.theory.pathological import BesicovitchFunction\n        &gt;&gt;&gt; x = np.linspace(0, 1, 10000)\n        &gt;&gt;&gt; wf = BesicovitchFunction(x, n=30)()\n        &gt;&gt;&gt; fig = plt.figure(figsize=(10, 6))\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; (ax_return,) = ax.plot(x, wf.result)\n        &gt;&gt;&gt; def update(frame: int) -&gt; tuple:\n        ...     zoom_factor = frame / 100\n        ...     ax.set_xlim(0 + zoom_factor/2 ,1 - zoom_factor/2)\n        ...     ax.set_ylim(-1 + zoom_factor, 1 - zoom_factor)\n        ...     return (ax_return,)\n        &gt;&gt;&gt; ani = FuncAnimation(fig, update, frames=np.arange(0, 100), blit=True)\n        &gt;&gt;&gt; ani.save('BesicovitchFunction.gif', writer='imagemagick', fps=10)\n\n    Notes:\n        The Besicovitch function is a fractal-like continuous function defined on the\n        real line. It is also known as the Besicovitch-Eggleston function.\n\n        $$\n        B(x) = \\sum_{n=1}^{n_1} \\frac{\\sin(\\pi 2^n x)}{\\mu^n}\n        $$\n\n        with constraint $\\mu \\geq 1$.\n\n        &gt; Reference: https://en.wikipedia.org/wiki/Besicovitch\n\n    Args:\n        *x (UniversalArray): Input values for which the Weierstrass function is\n            evaluated.\n        n (int, optional): Number of iterations to compute the Besicovitch function.\n            Defaults to 10.\n        mu (float, optional): A parameter of the function that controls the frequency\n            of oscillations. Must satisfy the condition b &gt;= 1. Defaults to 2.\n\n    Raises:\n        NotLargerThanAnyError: If $\\mu$ is not larger than 1.\n    \"\"\"\n\n    def __init__(self, *x: UniversalArray, n: int = 10, mu: float = 2) -&gt; None:\n        \"\"\"Initialize the Besicovitch function.\"\"\"\n        if mu &lt; 1:\n            raise NotLargerThanAnyError(var_number=\"mu\", number=mu, minimum=1)\n        super().__init__(*x, n_0=1, n_1=n)\n        self.mu = mu\n\n    @property\n    def __eval__(self) -&gt; UniversalArray:\n        \"\"\"Calculate the Besicovitch function.\"\"\"\n        result = np.zeros_like(self._x, dtype=float)\n        for n in range(1, self.n_1 + 1):\n            result += np.sin(2**n * np.pi * self._x) / (self.mu**n)\n        return result\n</code></pre>"}]}