{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#useful-math-functions","title":"useful-math-functions","text":"<p><code>useful-math-functions</code> is a collection of useful mathematical functions with a focus on:</p> <ol> <li>ease of use - the functions are designed to be as easy to use as possible</li> <li>pure python - the functions are written in much python as possible and    only use external libraries when necessary</li> <li>documentation - the functions are documented in code itself with:</li> <li>Examples</li> <li>Equations</li> <li>References</li> <li>Links to external resources</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>The package can be installed via pip:</p> Bash<pre><code>pip install useful-math-functions\n</code></pre> <p>and for Visualizations:</p> Bash<pre><code># matplotlib\npip install useful-math-functions[matplotlib]\n# plotly\npip install useful-math-functions[plotly]\n# all visualizations\npip install useful-math-functions[all]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The package can be imported like any other python package:</p> Python<pre><code>from umf.core.create import OptBench\nres = OptBench([\"DeJongN5Function\"], dim=3)\nres.plot_type_3d = \"plot_surface\"\nres.plot()\nres.save_as_image()\n</code></pre> <p></p>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation can be found here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome. For major changes, please open an issue first to discuss what you would like to change.</p>"},{"location":"#license","title":"License","text":"<p>The project is licensed under the MIT license.</p>"},{"location":"docs/","title":"Further Reading","text":""},{"location":"docs/#links","title":"Links","text":"<ul> <li>N-D Test Functions M \u2014 AMPGO 0.1.0 documentation. (n.d.). Infinity77.net.   from infinity77.net/global_optimization/test_functions_nd_M.html</li> <li>Optimization Test Functions and Datasets. (2013). Simon Fraser University,   from www.sfu.ca/~ssurjano/optimization.html</li> </ul>"},{"location":"docs/#books","title":"Books","text":"<ul> <li>Glaeser, G., &amp; Polthier, K. (2010). Bilder Der Mathematik (2<sup>nd</sup> ed.).   Spektrum Akademischer Verlag.</li> <li>Prosperetti, A. (2011). Advanced Mathematics for Applications. Cambridge   University Press.</li> <li>William H. Press, Teukolsky, S. A., Vetterling, W. T., &amp; Flannery, B. P.   (2007). Numerical recipes 3<sup>rd</sup> edition: The art of scientific computing (3<sup>rd</sup>   ed.). Cambridge University Press.</li> </ul>"},{"location":"home/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"home/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"home/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"home/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"home/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"home/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at Anselm.Hahn@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"home/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"home/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"home/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"home/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"home/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"home/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at www.contributor-covenant.org/faq. Translations are available at www.contributor-covenant.org/translations.</p>"},{"location":"home/contributing/","title":"Contribute Guideline","text":"<p>Thank you for considering contributing to <code>useful-math-functions</code>! We welcome contributions from anyone, whether you are an experienced developer or just getting started with open source.</p>"},{"location":"home/contributing/#getting-started","title":"Getting Started","text":"<p>Before you start contributing, please take a moment to review the following resources:</p> <ul> <li>Code of Conduct</li> <li>Contributing Guidelines</li> <li>Issue Tracker</li> <li>Pull Requests</li> </ul>"},{"location":"home/contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are many ways you can contribute to <code>useful-math-functions</code>, including:</p> <ul> <li>Reporting bugs and issues</li> <li>Suggesting new features and improvements</li> <li>Writing documentation</li> <li>Fixing bugs and issues</li> <li>Implementing new features and improvements</li> <li>Reviewing code and pull requests</li> </ul> <p>If you are new to open source or to <code>useful-math-functions</code>, we recommend starting with a small contribution, such as fixing a typo or adding a new test case. This will help you get familiar with the project and the contribution process.</p>"},{"location":"home/contributing/#reporting-bugs-and-issues","title":"Reporting Bugs and Issues","text":"<p>If you encounter a bug or issue with <code>useful-math-functions</code>, please report it on the Issue Tracker. Before you report an issue, please check if it has already been reported by searching the existing issues.</p> <p>When reporting an issue, please include as much detail as possible, such as:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the issue</li> <li>Steps to reproduce the issue</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Screenshots or error messages (if applicable)</li> </ul>"},{"location":"home/contributing/#suggesting-new-features-and-improvements","title":"Suggesting New Features and Improvements","text":"<p>If you have an idea for a new feature or improvement for <code>useful-math-functions</code>, please suggest it on the Issue Tracker. Before you suggest a new feature or improvement, please check if it has already been suggested by searching the existing issues.</p> <p>When suggesting a new feature or improvement, please include as much detail as possible, such as:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the feature or improvement</li> <li>Use cases or examples of how the feature or improvement would be used</li> <li>Any potential drawbacks or limitations</li> </ul>"},{"location":"home/contributing/#writing-documentation","title":"Writing Documentation","text":"<p>If you would like to contribute to the documentation for <code>useful-math-functions</code>, please submit a pull request with your changes. Before you submit a pull request, please make sure your changes are consistent with the existing documentation style and format.</p>"},{"location":"home/contributing/#fixing-bugs-and-issues","title":"Fixing Bugs and Issues","text":"<p>If you would like to fix a bug or issue with <code>useful-math-functions</code>, please follow these steps:</p> <ol> <li>Assign the issue to yourself on the    Issue Tracker.</li> <li>Fork the repository and create a new branch for your changes.</li> <li>Make your changes and write tests to ensure they work as expected.</li> <li>Submit a pull request with your changes.</li> </ol> <p>When submitting a pull request, please include a clear and descriptive title, a detailed description of your changes, and any relevant screenshots or error messages.</p>"},{"location":"home/contributing/#implementing-new-features-and-improvements","title":"Implementing New Features and Improvements","text":"<p>If you would like to implement a new feature or improvement for <code>useful-math-functions</code>, please follow these steps:</p> <ol> <li>Create a new issue on the    Issue Tracker to    discuss your idea.</li> <li>Once your idea has been approved, fork the repository and create a new branch    for your changes.</li> <li>Make your changes and write tests to ensure they work as expected.</li> <li>Submit a pull request with your changes.</li> </ol> <p>When submitting a pull request, please include a clear and descriptive title, a detailed description of your changes, and any relevant screenshots or error messages.</p>"},{"location":"home/contributing/#reviewing-code-and-pull-requests","title":"Reviewing Code and Pull Requests","text":"<p>If you would like to review code or pull requests for <code>useful-math-functions</code>, please follow these guidelines:</p> <ul> <li>Be respectful and constructive in your feedback.</li> <li>Focus on the code and the problem, not the person.</li> <li>Provide specific and actionable feedback.</li> <li>Be open to feedback and willing to make changes.</li> </ul>"},{"location":"home/contributing/#conclusion","title":"Conclusion","text":"<p>We appreciate your interest in contributing to <code>useful-math-functions</code>! If you have any questions or need help getting started, please don't hesitate to reach out to us on the Issue Tracker.</p>"},{"location":"home/license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2023 Anselm Hahn</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"modules/api/data_generation/","title":"Modules","text":"<p>Create math function and plot it.</p>"},{"location":"modules/api/data_generation/#umf.core.create.Borg","title":"<code>Borg</code>","text":"<p>Borg class for functions.</p> <p>About Borg</p> <p>This class is used to create shared states for math functions. It uses the Borg design pattern to ensure that all instances of a math function share the same state. The shared state is stored in the <code>shared_state</code> dictionary, while the shared result and plot are stored in the <code>shared_result</code> and <code>shared_plot</code> dictionaries, respectively.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class Borg:\n\"\"\"Borg class for functions.\n    !!! info \"About Borg\"\n        This class is used to create shared states for math functions. It uses the\n        Borg design pattern to ensure that all instances of a math function share the\n        same state. The shared state is stored in the `shared_state` dictionary, while\n        the shared result and plot are stored in the `shared_result` and `shared_plot`\n        dictionaries, respectively.\n    \"\"\"\nshared_state: ClassVar[dict[str, Any]] = {}\nshared_result: ClassVar[dict[str, Any]] = {}\nshared_plot: ClassVar[dict[str, Any]] = {}\ndef __init__(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nself.__dict__ = self.shared_state\ndef auto_cleanup(self) -&gt; None:\n\"\"\"Auto clean up shared states of math function.\"\"\"\nBorg.shared_state = {} if Borg.shared_state else Borg.shared_state\nBorg.shared_result = {} if Borg.shared_result else Borg.shared_result\nBorg.shared_plot = {} if Borg.shared_plot else Borg.shared_plot\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.Borg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nself.__dict__ = self.shared_state\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.Borg.auto_cleanup","title":"<code>auto_cleanup()</code>","text":"<p>Auto clean up shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def auto_cleanup(self) -&gt; None:\n\"\"\"Auto clean up shared states of math function.\"\"\"\nBorg.shared_state = {} if Borg.shared_state else Borg.shared_state\nBorg.shared_result = {} if Borg.shared_result else Borg.shared_result\nBorg.shared_plot = {} if Borg.shared_plot else Borg.shared_plot\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg","title":"<code>FunctionBorg</code>","text":"<p>             Bases: <code>Borg</code></p> <p>A class that initializes shared states of math functions.</p> <p>Attributes: _x (UniversalArray): Arguments to be passed to the math function. func_name (list[str] | str): Name of the math function(s) to be called. func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments to be     passed to the math function(s), by default None. shared_state (dict[str, Any]): Shared states of math function.</p> <p>Methods: init(*x: UniversalArray, func_name: list[str] | str, func_args: list[dict[str, Any]] | dict[str, Any] | None = None) -&gt; None:     Initializes shared states of math functions. initialize_borg() -&gt; None:     Initialize shared states of math function. return_borg() -&gt; dict[str, Any]:     Return shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class FunctionBorg(Borg):\n\"\"\"A class that initializes shared states of math functions.\n    Attributes:\n    _x (UniversalArray): Arguments to be passed to the math function.\n    func_name (list[str] | str): Name of the math function(s) to be called.\n    func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments to be\n        passed to the math function(s), by default None.\n    shared_state (dict[str, Any]): Shared states of math function.\n    Methods:\n    __init__(*x: UniversalArray, func_name: list[str] | str, func_args: list[dict[str,\n    Any]] | dict[str, Any] | None = None) -&gt; None:\n        Initializes shared states of math functions.\n    initialize_borg() -&gt; None:\n        Initialize shared states of math function.\n    return_borg() -&gt; dict[str, Any]:\n        Return shared states of math function.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nfunc_name: list[str] | str,\nfunc_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n) -&gt; None:\n\"\"\"Initializes shared states of math functions.\n        Args:\n        *x: UniversalArray\n            Arguments to be passed to the math function.\n        func_name: list[str] | str\n            Name of the math function(s) to be called.\n        func_args: list[dict[str, Any]] | dict[str, Any] | None, optional\n            Arguments to be passed to the math function(s), by default None.\n        \"\"\"\nsuper().__init__()\nself._x: tuple[UniversalArray, ...] = x\nfunc_args = func_args or [{} for _ in range(len(func_name))]\nself.func_args = [func_args] if isinstance(func_args, dict) else func_args\nself.func_name = [func_name] if isinstance(func_name, str) else func_name\nself.initialize_borg()\ndef initialize_borg(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nfor name, args in zip(self.func_name, self.func_args, strict=True):\ntry:\nfunc: Callable[[Any], Any] = getattr(core, name)\nexcept AttributeError as exc:\nmsg = f\"Unknown function '{name}'\"\nraise AttributeError(msg) from exc\ntry:\nself.shared_state[name] = func(*self._x, **args)()\nexcept TypeError as exc:\nmsg = f\"Function '{name}' has invalid arguments\"\nraise TypeError(msg) from exc\n@property\ndef return_borg(self) -&gt; dict[str, Any]:\n\"\"\"Return shared states of math function.\"\"\"\nreturn self.shared_state\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.return_borg","title":"<code>return_borg: dict[str, Any]</code>  <code>property</code>","text":"<p>Return shared states of math function.</p>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.__init__","title":"<code>__init__(*x, func_name, func_args=None)</code>","text":"<p>Initializes shared states of math functions.</p> <p>*x: UniversalArray     Arguments to be passed to the math function. func_name: list[str] | str     Name of the math function(s) to be called. func_args: list[dict[str, Any]] | dict[str, Any] | None, optional     Arguments to be passed to the math function(s), by default None.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nfunc_name: list[str] | str,\nfunc_args: list[dict[str, Any]] | dict[str, Any] | None = None,\n) -&gt; None:\n\"\"\"Initializes shared states of math functions.\n    Args:\n    *x: UniversalArray\n        Arguments to be passed to the math function.\n    func_name: list[str] | str\n        Name of the math function(s) to be called.\n    func_args: list[dict[str, Any]] | dict[str, Any] | None, optional\n        Arguments to be passed to the math function(s), by default None.\n    \"\"\"\nsuper().__init__()\nself._x: tuple[UniversalArray, ...] = x\nfunc_args = func_args or [{} for _ in range(len(func_name))]\nself.func_args = [func_args] if isinstance(func_args, dict) else func_args\nself.func_name = [func_name] if isinstance(func_name, str) else func_name\nself.initialize_borg()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.FunctionBorg.initialize_borg","title":"<code>initialize_borg()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def initialize_borg(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nfor name, args in zip(self.func_name, self.func_args, strict=True):\ntry:\nfunc: Callable[[Any], Any] = getattr(core, name)\nexcept AttributeError as exc:\nmsg = f\"Unknown function '{name}'\"\nraise AttributeError(msg) from exc\ntry:\nself.shared_state[name] = func(*self._x, **args)()\nexcept TypeError as exc:\nmsg = f\"Function '{name}' has invalid arguments\"\nraise TypeError(msg) from exc\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench","title":"<code>OptBench</code>","text":"<p>             Bases: <code>FunctionBorg</code>, <code>PlotBorg</code>, <code>SaveBorg</code></p> <p>A class for optimizing and benchmarking mathematical functions.</p> <p>About OptBench</p> <p>This class inherits from the <code>FunctionBorg</code>, <code>PlotBorg</code>, and <code>SaveBorg</code> classes, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # 3D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n&gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n&gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # 2D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench(\n...     [\n...         \"CrystalBallDistribution\",\n...         \"PseudoVoigtDistribution\",\n...         \"AsymmetricRamanLineshape\",\n...     ],\n...     [\n...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n...     ],\n...     start=-10,\n...     stop=10,\n...     step_size=0.1,\n...     dim=2,\n... )\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>list[str] | str</code> <p>Name of the function(s) to optimize and benchmark.</p> required <code>func_args</code> <code>list[dict[str, Any]] | dict[str, Any] | None</code> <p>Arguments  for the function(s). Defaults to None.</p> <code>None</code> <code>start</code> <code>float</code> <p>Start value of the range. Defaults to -5.0.</p> <code>-5.0</code> <code>stop</code> <code>float</code> <p>Stop value of the range. Defaults to 5.0.</p> <code>5.0</code> <code>step_size</code> <code>float | int</code> <p>Step value of the range or number of maximum  steps. Defaults to 0.1.</p> <code>0.1</code> <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either  'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>ValueError</code> <p>Number of dimensions must be greater than 1.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of dimensions.</p> <code>shared_result</code> <code>dict</code> <p>Dictionary containing arrays for plotting and saving.</p> <p>Methods:</p> Name Description <code>initializeshared_result</code> <p>Make arrays for plotting, saving and add them to share result.</p> <code>create_range</code> <p>float, stop: float,</p> <code>step_size</code> <p>float, dim: int = 2, mode: str = \"arange\")</p> <code>-&gt; list[UniversalArray] | MeshArray</code> <p>Create range of values for each dimension.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class OptBench(FunctionBorg, PlotBorg, SaveBorg):\n\"\"\"A class for optimizing and benchmarking mathematical functions.\n    !!! info \"About OptBench\"\n        This class inherits from the `FunctionBorg`, `PlotBorg`, and `SaveBorg` classes,\n        which allows it to share state across multiple instances. It defines various\n        properties and methods for managing settings related to plotting, such as the\n        size and resolution of the plot, the axis labels, the color scheme, and the\n        plot style (either Matplotlib or Plotly). It also defines a `plot` method that\n        plots the shared states of a math function using either Matplotlib or Plotly,\n        depending on the value of the `_plot_style` attribute.\n    Examples:\n        &gt;&gt;&gt; # 3D examples\n        &gt;&gt;&gt; from umf.core.create import OptBench\n        &gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n        &gt;&gt;&gt; res.show = False\n        &gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n        &gt;&gt;&gt; res.plot_style = \"matplot\"\n        &gt;&gt;&gt; res.plot()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n        &gt;&gt;&gt; # As plotly\n        &gt;&gt;&gt; res.plot_style = \"plotly\"\n        &gt;&gt;&gt; res.plot()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n        &gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n        &gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n        &gt;&gt;&gt; # 2D examples\n        &gt;&gt;&gt; from umf.core.create import OptBench\n        &gt;&gt;&gt; res = OptBench(\n        ...     [\n        ...         \"CrystalBallDistribution\",\n        ...         \"PseudoVoigtDistribution\",\n        ...         \"AsymmetricRamanLineshape\",\n        ...     ],\n        ...     [\n        ...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n        ...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n        ...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n        ...     ],\n        ...     start=-10,\n        ...     stop=10,\n        ...     step_size=0.1,\n        ...     dim=2,\n        ... )\n        &gt;&gt;&gt; res.show = False\n        &gt;&gt;&gt; res.plot_style = \"matplot\"\n        &gt;&gt;&gt; res.plot_series()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n        &gt;&gt;&gt; # As plotly\n        &gt;&gt;&gt; res.plot_style = \"plotly\"\n        &gt;&gt;&gt; res.plot_series()\n        &gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n    Args:\n        func_name (list[str] | str): Name of the function(s) to optimize and benchmark.\n        func_args (list[dict[str, Any]] | dict[str, Any] | None, optional): Arguments\n             for the function(s). Defaults to None.\n        start (float, optional): Start value of the range. Defaults to -5.0.\n        stop (float, optional): Stop value of the range. Defaults to 5.0.\n        step_size (float | int, optional): Step value of the range or number of maximum\n             steps. Defaults to 0.1.\n        dim (int, optional): Number of dimensions. Defaults to 2.\n        mode (str, optional): Mode for creating the range of values. Must be either\n             'arange' or 'linspace'. Defaults to \"arange\".\n    Raises:\n        ValueError: Mode must be either 'arange' or 'linspace'.\n        ValueError: Number of dimensions must be greater than 1.\n    Attributes:\n        dim (int): Number of dimensions.\n        shared_result (dict): Dictionary containing arrays for plotting and saving.\n    Methods:\n        initializeshared_result(self) -&gt; None:\n            Make arrays for plotting, saving and add them to share result.\n        create_range(start: float, stop: float,\n        step_size: float, dim: int = 2, mode: str = \"arange\")\n        -&gt; list[UniversalArray] | MeshArray:\n            Create range of values for each dimension.\n    \"\"\"\ndef __init__(  # noqa: PLR0913\nself,\nfunc_name: list[str] | str,\nfunc_args: list[dict[str, Any]] | dict[str, Any] | None = None,\nstart: float = -5.0,\nstop: float = 5.0,\nstep_size: float = 0.1,\ndim: int = 2,\nmode: str = \"arange\",\n) -&gt; None:\n\"\"\"Initialize shared states of math functions.\"\"\"\nself.auto_cleanup()\nsuper().__init__(\n*self.create_range(\nstart=start,\nstop=stop,\nstep_size=step_size,\ndim=dim,\nmode=mode,\n),\nfunc_name=func_name,\nfunc_args=func_args,\n)\nself.initializeshared_result()\nsuper(PlotBorg, self).__init__()\nsuper(SaveBorg, self).__init__()\nself.dim = dim\ndef initializeshared_result(self) -&gt; None:\n\"\"\"Make arrays for plotting, saving and add them to share result.\"\"\"\nfor name in self.func_name:\nself.shared_result[name] = np.asarray(\n[*self.shared_state[name].x, self.shared_state[name].result],\ndtype=np.float64,\n)\n@staticmethod\ndef create_range(\nstart: float,\nstop: float,\nstep_size: float,\ndim: int = 2,\nmode: str = \"arange\",\n) -&gt; list[UniversalArray] | MeshArray:\n\"\"\"Create range of values for each dimension.\n        Args:\n            start (float): Start value of range.\n            stop (float): Stop value of range.\n            step_size (float): Step value of range or number of maximum steps.\n            dim (int, optional): Number of dimensions. Defaults to 2.\n            mode (str, optional): Mode for creating the range of values. Must be either\n                'arange' or 'linspace'. Defaults to \"arange\".\n        Raises:\n            ValueError: Mode must be either 'arange' or 'linspace'.\n            TooSmallDimensionError: Number of dimensions must be greater than 1.\n        Returns:\n            list[UniversalArray] | MeshArray: Range of values for each dimension. In\n                case of 2 dimensions, a 1D array is returned. In case of more than 2\n                dimensions, a meshgrid is returned.\n        \"\"\"\nif mode not in {\"arange\", \"linspace\"}:\nmsg = \"Mode must be either 'arange' or 'linspace'\"\nraise ValueError(msg)\nif dim &lt; __2d__:\nraise TooLowDimensionError(min_dimension=__2d__, current_dimension=dim)\nif dim == __2d__:\nreturn [getattr(np, mode)(start, stop, step_size, dtype=np.float64)]\nreturn np.meshgrid(\n*[\ngetattr(np, mode)(start, stop, step_size, dtype=np.float64)\nfor _ in range(dim - 1)\n],\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.__init__","title":"<code>__init__(func_name, func_args=None, start=-5.0, stop=5.0, step_size=0.1, dim=2, mode='arange')</code>","text":"<p>Initialize shared states of math functions.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(  # noqa: PLR0913\nself,\nfunc_name: list[str] | str,\nfunc_args: list[dict[str, Any]] | dict[str, Any] | None = None,\nstart: float = -5.0,\nstop: float = 5.0,\nstep_size: float = 0.1,\ndim: int = 2,\nmode: str = \"arange\",\n) -&gt; None:\n\"\"\"Initialize shared states of math functions.\"\"\"\nself.auto_cleanup()\nsuper().__init__(\n*self.create_range(\nstart=start,\nstop=stop,\nstep_size=step_size,\ndim=dim,\nmode=mode,\n),\nfunc_name=func_name,\nfunc_args=func_args,\n)\nself.initializeshared_result()\nsuper(PlotBorg, self).__init__()\nsuper(SaveBorg, self).__init__()\nself.dim = dim\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.create_range","title":"<code>create_range(start, stop, step_size, dim=2, mode='arange')</code>  <code>staticmethod</code>","text":"<p>Create range of values for each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Start value of range.</p> required <code>stop</code> <code>float</code> <p>Stop value of range.</p> required <code>step_size</code> <code>float</code> <p>Step value of range or number of maximum steps.</p> required <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either 'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>TooSmallDimensionError</code> <p>Number of dimensions must be greater than 1.</p> <p>Returns:</p> Type Description <code>list[UniversalArray] | MeshArray</code> <p>list[UniversalArray] | MeshArray: Range of values for each dimension. In case of 2 dimensions, a 1D array is returned. In case of more than 2 dimensions, a meshgrid is returned.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef create_range(\nstart: float,\nstop: float,\nstep_size: float,\ndim: int = 2,\nmode: str = \"arange\",\n) -&gt; list[UniversalArray] | MeshArray:\n\"\"\"Create range of values for each dimension.\n    Args:\n        start (float): Start value of range.\n        stop (float): Stop value of range.\n        step_size (float): Step value of range or number of maximum steps.\n        dim (int, optional): Number of dimensions. Defaults to 2.\n        mode (str, optional): Mode for creating the range of values. Must be either\n            'arange' or 'linspace'. Defaults to \"arange\".\n    Raises:\n        ValueError: Mode must be either 'arange' or 'linspace'.\n        TooSmallDimensionError: Number of dimensions must be greater than 1.\n    Returns:\n        list[UniversalArray] | MeshArray: Range of values for each dimension. In\n            case of 2 dimensions, a 1D array is returned. In case of more than 2\n            dimensions, a meshgrid is returned.\n    \"\"\"\nif mode not in {\"arange\", \"linspace\"}:\nmsg = \"Mode must be either 'arange' or 'linspace'\"\nraise ValueError(msg)\nif dim &lt; __2d__:\nraise TooLowDimensionError(min_dimension=__2d__, current_dimension=dim)\nif dim == __2d__:\nreturn [getattr(np, mode)(start, stop, step_size, dtype=np.float64)]\nreturn np.meshgrid(\n*[\ngetattr(np, mode)(start, stop, step_size, dtype=np.float64)\nfor _ in range(dim - 1)\n],\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.OptBench.initializeshared_result","title":"<code>initializeshared_result()</code>","text":"<p>Make arrays for plotting, saving and add them to share result.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def initializeshared_result(self) -&gt; None:\n\"\"\"Make arrays for plotting, saving and add them to share result.\"\"\"\nfor name in self.func_name:\nself.shared_result[name] = np.asarray(\n[*self.shared_state[name].x, self.shared_state[name].result],\ndtype=np.float64,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg","title":"<code>PlotBorg</code>","text":"<p>             Bases: <code>Borg</code></p> <p>A singleton class that manages shared settings for plotting math functions.</p> <p>About PlotBorg</p> <p>This class inherits from the <code>Borg</code> class, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>The size of the plot in inches.</p> <code>dpi</code> <code>int</code> <p>The resolution of the plot in dots per inch.</p> <code>axis</code> <code>list[str] | None</code> <p>The labels for the x and y axes.</p> <code>color</code> <code>str | None</code> <p>The color scheme for the plot.</p> <code>cmap</code> <code>str</code> <p>The colormap for the plot.</p> <code>alpha</code> <code>float | None</code> <p>The transparency of the plot.</p> <code>plot_type_3d</code> <code>str</code> <p>The type of 3D plot to use (if any).</p> <code>plot_style</code> <code>str</code> <p>The style of the plot (either \"matplot\" or \"plotly\").</p> <code>show</code> <code>bool</code> <p>Whether to show the plot after it is generated.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class PlotBorg(Borg):\n\"\"\"A singleton class that manages shared settings for plotting math functions.\n    !!! info \"About PlotBorg\"\n        This class inherits from the `Borg` class, which allows it to share state\n        across multiple instances. It defines various properties and methods for\n        managing settings related to plotting, such as the size and resolution of\n        the plot, the axis labels, the color scheme, and the plot style (either\n        Matplotlib or Plotly). It also defines a `plot` method that plots the\n        shared states of a math function using either Matplotlib or Plotly,\n        depending on the value of the `_plot_style` attribute.\n    Attributes:\n        size (tuple[int, int]): The size of the plot in inches.\n        dpi (int): The resolution of the plot in dots per inch.\n        axis (list[str] | None): The labels for the x and y axes.\n        color (str | None): The color scheme for the plot.\n        cmap (str): The colormap for the plot.\n        alpha (float | None): The transparency of the plot.\n        plot_type_3d (str): The type of 3D plot to use (if any).\n        plot_style (str): The style of the plot (either \"matplot\" or \"plotly\").\n        show (bool): Whether to show the plot after it is generated.\n    \"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize shared settings for plotting math functions.\"\"\"\nsuper().__init__()\nself._dpi = GraphSettings().dpi\nself._size = GraphSettings().size\nself._dpi = GraphSettings().dpi\nself._axis = GraphSettings().axis\nself._color = GraphSettings().color\nself._cmap = GraphSettings().cmap\nself._alpha = GraphSettings().alpha\nself._plot_type_3d = \"plot_3d\"\nself._plot_style = \"matplot\"\nself._show = True\n@property\ndef size(self) -&gt; tuple[int, int]:\n\"\"\"Return the size of the plot.\"\"\"\nreturn self._size\n@size.setter\ndef size(self, value: tuple[int, int]) -&gt; None:\n\"\"\"Set the size of the plot.\"\"\"\nself._size = value\n@property\ndef dpi(self) -&gt; int:\n\"\"\"Return the resolution of the plot.\"\"\"\nreturn self._dpi\n@dpi.setter\ndef dpi(self, value: int) -&gt; None:\n\"\"\"Set the resolution of the plot.\"\"\"\nself._dpi = value\n@property\ndef axis(self) -&gt; list[str] | None:\n\"\"\"Return the labels for the x and y axes.\"\"\"\nreturn self._axis\n@axis.setter\ndef axis(self, value: list[str] | None) -&gt; None:\n\"\"\"Set the labels for the x and y axes.\"\"\"\nself._axis = value\n@property\ndef color(self) -&gt; str | None:\n\"\"\"Return the color scheme for the plot.\"\"\"\nreturn self._color\n@color.setter\ndef color(self, value: str | None) -&gt; None:\n\"\"\"Set the color scheme for the plot.\"\"\"\nself._color = value\n@property\ndef cmap(self) -&gt; str:\n\"\"\"Return the colormap for the plot.\"\"\"\nreturn self._cmap\n@cmap.setter\ndef cmap(self, value: str) -&gt; None:\n\"\"\"Set the colormap for the plot.\"\"\"\nself._cmap = value\n@property\ndef alpha(self) -&gt; float | None:\n\"\"\"Return the transparency of the plot.\"\"\"\nreturn self._alpha\n@alpha.setter\ndef alpha(self, value: float | None) -&gt; None:\n\"\"\"Set the transparency of the plot.\"\"\"\nself._alpha = value\n@property\ndef plot_type_3d(self) -&gt; str:\n\"\"\"Return the type of 3D plot to use.\"\"\"\nreturn self._plot_type_3d\n@plot_type_3d.setter\ndef plot_type_3d(self, value: str) -&gt; None:\n\"\"\"Set the type of 3D plot to use.\"\"\"\nself._plot_type_3d = value\n@property\ndef plot_style(self) -&gt; str:\n\"\"\"Return the style of the plot.\"\"\"\nreturn self._plot_style\n@plot_style.setter\ndef plot_style(self, value: str) -&gt; None:\n\"\"\"Set the style of the plot.\"\"\"\nself._plot_style = value\n@property\ndef show(self) -&gt; bool:\n\"\"\"Return whether to show the plot after it is generated.\"\"\"\nreturn self._show\n@show.setter\ndef show(self, value: bool) -&gt; None:\n\"\"\"Set whether to show the plot after it is generated.\"\"\"\nself._show = value\ndef plot(self, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Plot shared states of math function.\n        Info \"About plot\"\n            This method plots the shared states of a math function using either\n            Matplotlib or Plotly, depending on the value of the `_plot_style`\n            attribute. The settings for the plot are determined by the values of various\n            other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n            and `_alpha`.\n        Args:\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\nsettings = GraphSettings(\nsize=self._size,\ndpi=self._dpi,\naxis=self._axis,\ncolor=self._color,\ncmap=self._cmap,\nalpha=self._alpha,\n)\nfor name, x in self.shared_result.items():\nif self._plot_style == \"matplot\":\nself.matplot(*x, title=name, settings=settings, **kwargs)\nelif self._plot_style == \"plotly\":\nself.plotly(*x, title=name, settings=settings, **kwargs)\nelse:\nraise PlotAttributeError(\nchoose=self._plot_style,\nmodes={\"matplot\", \"plotly\"},\nerror_type=\"style\",\n)\ndef plot_series(self, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Plot shared states of math function as series.\n        Info \"About plot_series\"\n            This method plots the shared states of a math function as series using\n            either Matplotlib or Plotly, depending on the value of the `_plot_style`\n            attribute. The settings for the plot are determined by the values of various\n            other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n            and `_alpha`.\n        Args:\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\nsettings = GraphSettings(\nsize=self._size,\ndpi=self._dpi,\naxis=self._axis,\ncolor=self._color,\ncmap=self._cmap,\nalpha=self._alpha,\n)\nlabel = []\nvalues: list[UniversalArray] = []\nfor name, x in self.shared_result.items():\nlabel.append(name)\nvalues.append(x)\nif self._plot_style == \"matplot\":\nplot = ClassicPlot(*values, settings=settings, **kwargs)\nplot.plot_series(label=label)\nif self._show:\nplot.plot_show()\nelif self._plot_style == \"plotly\":\nplot = PlotlyPlot(*values, settings=settings, **kwargs)\nplot.plot_series(label=label)\nif self._show:\nplot.plot_show()\nelse:\nraise PlotAttributeError(\nchoose=self._plot_style,\nmodes={\"matplot\", \"plotly\"},\nerror_type=\"style\",\n)\nself.shared_plot[f\"Series_of_{'-'.join(label)}\"] = plot.plot_return\ndef matplot(\nself,\n*x: UniversalArray,\ntitle: str,\nsettings: GraphSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Plot shared states of math function via matplotlib.\n        Args:\n            *x (UniversalArray): Arrays to plot.\n            title (str): Title of plots (used as key in shared plot).\n            settings (GraphSettings): Settings of plot via `GraphSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n                plot_contour, plot_surface, plot_dashboard.\n        \"\"\"\nplot = ClassicPlot(*x, settings=settings, **kwargs)\ndim = len(x)\nmodes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\nif self._plot_type_3d not in modes:\nraise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\nif dim == __2d__:\nplot.plot_2d()\nelif dim == __3d__:\ngetattr(plot, self._plot_type_3d)()\nelse:\nraise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\nself.shared_plot[title] = plot.plot_return\nif self._show:\nplot.plot_show()\ndef plotly(\nself,\n*x: UniversalArray,\ntitle: str,\nsettings: GraphSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Plot shared states of math function via plotly.\n        Args:\n            *x (UniversalArray): Arrays to plot.\n            title (str): Title of plots (used as key in shared plot).\n            settings (GraphSettings): Settings of plot via `GraphSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n        \"\"\"\nplot = PlotlyPlot(*x, settings=settings, **kwargs)\ndim = len(x)\nmodes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\nif self._plot_type_3d not in modes:\nraise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\nif dim == __2d__:\nplot.plot_2d()\nelif dim == __3d__:\ngetattr(plot, self._plot_type_3d)()\nelse:\nraise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\nself.shared_plot[title] = plot.plot_return\nif self._show:\nplot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.alpha","title":"<code>alpha: float | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the transparency of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.axis","title":"<code>axis: list[str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the labels for the x and y axes.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.cmap","title":"<code>cmap: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the colormap for the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.color","title":"<code>color: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return the color scheme for the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.dpi","title":"<code>dpi: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return the resolution of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_style","title":"<code>plot_style: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the style of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_type_3d","title":"<code>plot_type_3d: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the type of 3D plot to use.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.show","title":"<code>show: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether to show the plot after it is generated.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.size","title":"<code>size: tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Return the size of the plot.</p>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared settings for plotting math functions.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize shared settings for plotting math functions.\"\"\"\nsuper().__init__()\nself._dpi = GraphSettings().dpi\nself._size = GraphSettings().size\nself._dpi = GraphSettings().dpi\nself._axis = GraphSettings().axis\nself._color = GraphSettings().color\nself._cmap = GraphSettings().cmap\nself._alpha = GraphSettings().alpha\nself._plot_type_3d = \"plot_3d\"\nself._plot_style = \"matplot\"\nself._show = True\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.matplot","title":"<code>matplot(*x, title, settings, **kwargs)</code>","text":"<p>Plot shared states of math function via matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to plot.</p> <code>()</code> <code>title</code> <code>str</code> <p>Title of plots (used as key in shared plot).</p> required <code>settings</code> <code>GraphSettings</code> <p>Settings of plot via <code>GraphSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d, plot_contour, plot_surface, plot_dashboard.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def matplot(\nself,\n*x: UniversalArray,\ntitle: str,\nsettings: GraphSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Plot shared states of math function via matplotlib.\n    Args:\n        *x (UniversalArray): Arrays to plot.\n        title (str): Title of plots (used as key in shared plot).\n        settings (GraphSettings): Settings of plot via `GraphSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n            plot_contour, plot_surface, plot_dashboard.\n    \"\"\"\nplot = ClassicPlot(*x, settings=settings, **kwargs)\ndim = len(x)\nmodes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\nif self._plot_type_3d not in modes:\nraise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\nif dim == __2d__:\nplot.plot_2d()\nelif dim == __3d__:\ngetattr(plot, self._plot_type_3d)()\nelse:\nraise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\nself.shared_plot[title] = plot.plot_return\nif self._show:\nplot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot","title":"<code>plot(**kwargs)</code>","text":"<p>Plot shared states of math function.</p> <p>Info \"About plot\"     This method plots the shared states of a math function using either     Matplotlib or Plotly, depending on the value of the <code>_plot_style</code>     attribute. The settings for the plot are determined by the values of various     other attributes, such as <code>_size</code>, <code>_dpi</code>, <code>_axis</code>, <code>_color</code>, <code>_cmap</code>,     and <code>_alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plot(self, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Plot shared states of math function.\n    Info \"About plot\"\n        This method plots the shared states of a math function using either\n        Matplotlib or Plotly, depending on the value of the `_plot_style`\n        attribute. The settings for the plot are determined by the values of various\n        other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n        and `_alpha`.\n    Args:\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\nsettings = GraphSettings(\nsize=self._size,\ndpi=self._dpi,\naxis=self._axis,\ncolor=self._color,\ncmap=self._cmap,\nalpha=self._alpha,\n)\nfor name, x in self.shared_result.items():\nif self._plot_style == \"matplot\":\nself.matplot(*x, title=name, settings=settings, **kwargs)\nelif self._plot_style == \"plotly\":\nself.plotly(*x, title=name, settings=settings, **kwargs)\nelse:\nraise PlotAttributeError(\nchoose=self._plot_style,\nmodes={\"matplot\", \"plotly\"},\nerror_type=\"style\",\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plot_series","title":"<code>plot_series(**kwargs)</code>","text":"<p>Plot shared states of math function as series.</p> <p>Info \"About plot_series\"     This method plots the shared states of a math function as series using     either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code>     attribute. The settings for the plot are determined by the values of various     other attributes, such as <code>_size</code>, <code>_dpi</code>, <code>_axis</code>, <code>_color</code>, <code>_cmap</code>,     and <code>_alpha</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plot_series(self, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Plot shared states of math function as series.\n    Info \"About plot_series\"\n        This method plots the shared states of a math function as series using\n        either Matplotlib or Plotly, depending on the value of the `_plot_style`\n        attribute. The settings for the plot are determined by the values of various\n        other attributes, such as `_size`, `_dpi`, `_axis`, `_color`, `_cmap`,\n        and `_alpha`.\n    Args:\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\nsettings = GraphSettings(\nsize=self._size,\ndpi=self._dpi,\naxis=self._axis,\ncolor=self._color,\ncmap=self._cmap,\nalpha=self._alpha,\n)\nlabel = []\nvalues: list[UniversalArray] = []\nfor name, x in self.shared_result.items():\nlabel.append(name)\nvalues.append(x)\nif self._plot_style == \"matplot\":\nplot = ClassicPlot(*values, settings=settings, **kwargs)\nplot.plot_series(label=label)\nif self._show:\nplot.plot_show()\nelif self._plot_style == \"plotly\":\nplot = PlotlyPlot(*values, settings=settings, **kwargs)\nplot.plot_series(label=label)\nif self._show:\nplot.plot_show()\nelse:\nraise PlotAttributeError(\nchoose=self._plot_style,\nmodes={\"matplot\", \"plotly\"},\nerror_type=\"style\",\n)\nself.shared_plot[f\"Series_of_{'-'.join(label)}\"] = plot.plot_return\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.PlotBorg.plotly","title":"<code>plotly(*x, title, settings, **kwargs)</code>","text":"<p>Plot shared states of math function via plotly.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to plot.</p> <code>()</code> <code>title</code> <code>str</code> <p>Title of plots (used as key in shared plot).</p> required <code>settings</code> <code>GraphSettings</code> <p>Settings of plot via <code>GraphSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_2d, plot_3d,</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def plotly(\nself,\n*x: UniversalArray,\ntitle: str,\nsettings: GraphSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Plot shared states of math function via plotly.\n    Args:\n        *x (UniversalArray): Arrays to plot.\n        title (str): Title of plots (used as key in shared plot).\n        settings (GraphSettings): Settings of plot via `GraphSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_2d, plot_3d,\n    \"\"\"\nplot = PlotlyPlot(*x, settings=settings, **kwargs)\ndim = len(x)\nmodes: set[str] = {\"plot_3d\", \"plot_contour\", \"plot_surface\", \"plot_dashboard\"}\nif self._plot_type_3d not in modes:\nraise PlotAttributeError(choose=self._plot_type_3d, modes=modes)\nif dim == __2d__:\nplot.plot_2d()\nelif dim == __3d__:\ngetattr(plot, self._plot_type_3d)()\nelse:\nraise TooHighDimensionError(max_dimension=__3d__, current_dimension=dim)\nself.shared_plot[title] = plot.plot_return\nif self._show:\nplot.plot_show()\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg","title":"<code>SaveBorg</code>","text":"<p>             Bases: <code>Borg</code></p> <p>Class for saving shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>class SaveBorg(Borg):\n\"\"\"Class for saving shared states of math function.\"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nsuper().__init__()\nself.dpi = GIFSettings().dpi\nself._zoom_start = GIFSettings().zoom_start\nself._zoom_stop = GIFSettings().zoom_stop\nself._elev = GIFSettings().elev\nself._azim = GIFSettings().azim\nself._frames = GIFSettings().frames\nself._interval = GIFSettings().interval\n@property\ndef dpi(self) -&gt; int:\n\"\"\"Return dpi of gif.\"\"\"\nreturn self._dpi\n@dpi.setter\ndef dpi(self, value: int) -&gt; None:\n\"\"\"Set dpi of gif.\"\"\"\nself._dpi = value\n@property\ndef zoom_start(self) -&gt; float:\n\"\"\"Return zoom in of gif.\"\"\"\nreturn self._zoom_start\n@zoom_start.setter\ndef zoom_start(self, value: float) -&gt; None:\n\"\"\"Set zoom in of gif.\"\"\"\nself._zoom_start = value\n@property\ndef zoom_stop(self) -&gt; float:\n\"\"\"Return zoom out of gif.\"\"\"\nreturn self._zoom_stop\n@zoom_stop.setter\ndef zoom_stop(self, value: float) -&gt; None:\n\"\"\"Set zoom out of gif.\"\"\"\nself._zoom_stop = value\n@property\ndef elev(self) -&gt; int:\n\"\"\"Return elevation of gif.\"\"\"\nreturn self._elev\n@elev.setter\ndef elev(self, value: int) -&gt; None:\n\"\"\"Set elevation of gif.\"\"\"\nself._elev = value\n@property\ndef azim(self) -&gt; int:\n\"\"\"Return azimuth of gif.\"\"\"\nreturn self._azim\n@azim.setter\ndef azim(self, value: int) -&gt; None:\n\"\"\"Set azimuth of gif.\"\"\"\nself._azim = value\n@property\ndef frames(self) -&gt; int:\n\"\"\"Return frames of gif.\"\"\"\nreturn self._frames\n@frames.setter\ndef frames(self, value: int) -&gt; None:\n\"\"\"Set frames of gif.\"\"\"\nself._frames = value\n@property\ndef interval(self) -&gt; int:\n\"\"\"Return interval of gif.\"\"\"\nreturn self._interval\ndef save_as_csv(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as csv file.\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for numpy.savetxt.\n        \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_csv(*values, fname=Path(dir_name) / f\"{name}.csv\", **kwargs)\ndef save_as_json(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as json file.\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for json.dump.\n        \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_json(*values, fname=Path(dir_name) / f\"{name}.json\", **kwargs)\ndef save_as_pickle(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as pickle file.\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            **kwargs (Any): Additional arguments for numpy.savez.\n        \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_pickle(*values, fname=Path(dir_name) / f\"{name}.npz\", **kwargs)\ndef save_as_clipboard(self) -&gt; None:\n\"\"\"Save shared states of math function to clipboard.\"\"\"\nraise NotImplementedError\ndef save_as_image(\nself,\ndir_name: str = \".\",\nffomat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as image file.\"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, fig in self.shared_plot.items():\nself.to_image(fig, fname=Path(dir_name) / name, fformat=ffomat, **kwargs)\ndef save_as_gif(\nself,\n*,\ndir_name: str = \".\",\nzoom: bool = True,\nrotate: bool = True,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as gif file.\n        Args:\n            dir_name (str, optional): Directory name to save file. Defaults to '.'.\n            zoom (bool, optional): Whether to save zoom gif. Defaults to True.\n            rotate (bool, optional): Whether to save rotate gif. Defaults to True.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save.\n        \"\"\"\nsettings = GIFSettings(\ndpi=self._dpi,\nzoom_start=self._zoom_start,\nzoom_stop=self._zoom_stop,\nelev=self._elev,\nazim=self._azim,\nframes=self._frames,\ninterval=self._interval,\nzoom=zoom,\nrotate=rotate,\n)\nself.if_dir_not_exist(dir_name)\nfor name, fig in self.shared_plot.items():\nself.to_gif(\nfig,\nfname=Path(dir_name) / f\"{name}.gif\",\nsettings=settings,\n**kwargs,\n)\n@staticmethod\ndef if_dir_not_exist(dir_name: str) -&gt; None:\n\"\"\"Check if directory exist, if not create it.\"\"\"\nif not Path(dir_name).exists():\nPath(dir_name).mkdir(parents=True, exist_ok=True)\n@staticmethod\ndef to_csv(\n*x: UniversalArray,\nfname: Path,\nfmt: str = \"%f\",\ndelimiter: str = \",\",\ncomments: str = \"\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as csv file.\n        Args:\n            *x (UniversalArray): Arrays to save.\n            fname (Path): Path to save file.\n            fmt (str, optional): Format of file. Defaults to '%f'.\n            delimiter (str, optional): Delimiter of file. Defaults to ','.\n            comments (str, optional): Comments of file. Defaults to ''.\n            **kwargs (Any): Additional arguments for numpy.savetxt.\n        \"\"\"\nlength = len(x)\nnp.savetxt(\nfname,\nnp.asarray(x).T.reshape(-1, length),\nfmt=fmt,\ndelimiter=delimiter,\nheader=delimiter.join([f\"x_{i}\" for i in range(length)]),\ncomments=comments,\n**kwargs,\n)\n@staticmethod\ndef to_json(\n*x: UniversalArray,\nfname: Path,\nmode: str = \"w+\",\nencoding: str = \"UTF-8\",\nindent: int = 4,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as json file.\n        Args:\n            *x (UniversalArray): Arrays to save.\n            mode (str, optional): Mode of file. Defaults to 'w+'.\n            encoding (str, optional): Encoding of file. Defaults to 'UTF-8'.\n            indent (int, optional): Indent of file. Defaults to 4.\n            fname (Path): Path to save file.\n            **kwargs (dict[str, Any]): Additional arguments for json.dump.\n        \"\"\"\nwith Path(fname).open(mode=mode, encoding=encoding) as f:\njson.dump(\n{f\"x_{i}\": x[i].tolist() for i in range(len(x))},\nf,\nindent=indent,\n**kwargs,\n)\n@staticmethod\ndef to_pickle(*x: UniversalArray, fname: Path, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as pickle file.\n        Args:\n            *x (UniversalArray): Arrays to save.\n            fname (Path): Path to save file.\n            **kwargs (Any): Additional arguments for numpy.savez.\n        \"\"\"\nnp.savez(fname, *x, **kwargs)\ndef to_clipboard(self) -&gt; None:\n\"\"\"Save shared states of math function to clipboard.\"\"\"\nraise NotImplementedError\n@staticmethod\ndef to_image(\nfig: FigureTypePlotly | FigureTypeMatplotlib,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as image file.\n        Args:\n            fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n            fname (Path): Path to save file.\n            fformat (str, optional): Format of file. Defaults to 'png'.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save.\n        \"\"\"\nplot_classes = {\nplt.Figure: ClassicPlot,\ngo.Figure: PlotlyPlot,\n}\nplot_class = plot_classes.get(type(fig))\nif plot_class is not None:\nplot_class.plot_save(fig=fig, fname=fname, fformat=fformat, **kwargs)\n@staticmethod\ndef to_gif(\nfig: FigureTypePlotly | FigureTypeMatplotlib,\nfname: Path,\nax_fig: plt.Figure,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as gif file.\n        Notes:\n            This method is only supported for Matplotlib plots.\n        Args:\n            fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n            fname (Path): Path to save file.\n            ax_fig (plt.Figure): Figure to save.\n            settings (GIFSettings): Settings of gif via `GIFSettings`.\n            **kwargs (dict[str, Any]): Additional arguments for plot_save_gif.\n        \"\"\"\nplot_classes = {\nplt.Figure: ClassicPlot,\ngo.Figure: PlotlyPlot,\n}\nplot_class = plot_classes.get(type(fig))\nif plot_class is not None:\nplot_class.plot_save_gif(\nfig=fig,\nax_fig=ax_fig,\nfname=fname,\nsettings=settings,\n**kwargs,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.azim","title":"<code>azim: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return azimuth of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.dpi","title":"<code>dpi: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return dpi of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.elev","title":"<code>elev: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return elevation of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.frames","title":"<code>frames: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return frames of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.interval","title":"<code>interval: int</code>  <code>property</code>","text":"<p>Return interval of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.zoom_start","title":"<code>zoom_start: float</code>  <code>property</code> <code>writable</code>","text":"<p>Return zoom in of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.zoom_stop","title":"<code>zoom_stop: float</code>  <code>property</code> <code>writable</code>","text":"<p>Return zoom out of gif.</p>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.__init__","title":"<code>__init__()</code>","text":"<p>Initialize shared states of math function.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize shared states of math function.\"\"\"\nsuper().__init__()\nself.dpi = GIFSettings().dpi\nself._zoom_start = GIFSettings().zoom_start\nself._zoom_stop = GIFSettings().zoom_stop\nself._elev = GIFSettings().elev\nself._azim = GIFSettings().azim\nself._frames = GIFSettings().frames\nself._interval = GIFSettings().interval\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.if_dir_not_exist","title":"<code>if_dir_not_exist(dir_name)</code>  <code>staticmethod</code>","text":"<p>Check if directory exist, if not create it.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef if_dir_not_exist(dir_name: str) -&gt; None:\n\"\"\"Check if directory exist, if not create it.\"\"\"\nif not Path(dir_name).exists():\nPath(dir_name).mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_clipboard","title":"<code>save_as_clipboard()</code>","text":"<p>Save shared states of math function to clipboard.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_clipboard(self) -&gt; None:\n\"\"\"Save shared states of math function to clipboard.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_csv","title":"<code>save_as_csv(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as csv file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savetxt.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_csv(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as csv file.\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for numpy.savetxt.\n    \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_csv(*values, fname=Path(dir_name) / f\"{name}.csv\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_gif","title":"<code>save_as_gif(*, dir_name='.', zoom=True, rotate=True, **kwargs)</code>","text":"<p>Save shared states of math function as gif file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>zoom</code> <code>bool</code> <p>Whether to save zoom gif. Defaults to True.</p> <code>True</code> <code>rotate</code> <code>bool</code> <p>Whether to save rotate gif. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_gif(\nself,\n*,\ndir_name: str = \".\",\nzoom: bool = True,\nrotate: bool = True,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as gif file.\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        zoom (bool, optional): Whether to save zoom gif. Defaults to True.\n        rotate (bool, optional): Whether to save rotate gif. Defaults to True.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save.\n    \"\"\"\nsettings = GIFSettings(\ndpi=self._dpi,\nzoom_start=self._zoom_start,\nzoom_stop=self._zoom_stop,\nelev=self._elev,\nazim=self._azim,\nframes=self._frames,\ninterval=self._interval,\nzoom=zoom,\nrotate=rotate,\n)\nself.if_dir_not_exist(dir_name)\nfor name, fig in self.shared_plot.items():\nself.to_gif(\nfig,\nfname=Path(dir_name) / f\"{name}.gif\",\nsettings=settings,\n**kwargs,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_image","title":"<code>save_as_image(dir_name='.', ffomat='png', **kwargs)</code>","text":"<p>Save shared states of math function as image file.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_image(\nself,\ndir_name: str = \".\",\nffomat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as image file.\"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, fig in self.shared_plot.items():\nself.to_image(fig, fname=Path(dir_name) / name, fformat=ffomat, **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_json","title":"<code>save_as_json(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as json file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for json.dump.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_json(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as json file.\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for json.dump.\n    \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_json(*values, fname=Path(dir_name) / f\"{name}.json\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.save_as_pickle","title":"<code>save_as_pickle(dir_name='.', **kwargs)</code>","text":"<p>Save shared states of math function as pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>dir_name</code> <code>str</code> <p>Directory name to save file. Defaults to '.'.</p> <code>'.'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savez.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>def save_as_pickle(self, dir_name: str = \".\", **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as pickle file.\n    Args:\n        dir_name (str, optional): Directory name to save file. Defaults to '.'.\n        **kwargs (Any): Additional arguments for numpy.savez.\n    \"\"\"\nself.if_dir_not_exist(dir_name)\nfor name, values in self.shared_result.items():\nself.to_pickle(*values, fname=Path(dir_name) / f\"{name}.npz\", **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_clipboard","title":"<code>to_clipboard()</code>","text":"<p>Save shared states of math function to clipboard.</p> Source code in <code>umf/core/create.py</code> Python<pre><code>def to_clipboard(self) -&gt; None:\n\"\"\"Save shared states of math function to clipboard.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_csv","title":"<code>to_csv(*x, fname, fmt='%f', delimiter=',', comments='', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as csv file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>fmt</code> <code>str</code> <p>Format of file. Defaults to '%f'.</p> <code>'%f'</code> <code>delimiter</code> <code>str</code> <p>Delimiter of file. Defaults to ','.</p> <code>','</code> <code>comments</code> <code>str</code> <p>Comments of file. Defaults to ''.</p> <code>''</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savetxt.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_csv(\n*x: UniversalArray,\nfname: Path,\nfmt: str = \"%f\",\ndelimiter: str = \",\",\ncomments: str = \"\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as csv file.\n    Args:\n        *x (UniversalArray): Arrays to save.\n        fname (Path): Path to save file.\n        fmt (str, optional): Format of file. Defaults to '%f'.\n        delimiter (str, optional): Delimiter of file. Defaults to ','.\n        comments (str, optional): Comments of file. Defaults to ''.\n        **kwargs (Any): Additional arguments for numpy.savetxt.\n    \"\"\"\nlength = len(x)\nnp.savetxt(\nfname,\nnp.asarray(x).T.reshape(-1, length),\nfmt=fmt,\ndelimiter=delimiter,\nheader=delimiter.join([f\"x_{i}\" for i in range(length)]),\ncomments=comments,\n**kwargs,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_gif","title":"<code>to_gif(fig, fname, ax_fig, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as gif file.</p> Notes <p>This method is only supported for Matplotlib plots.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>Figure to save.</p> required <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>ax_fig</code> <code>Figure</code> <p>Figure to save.</p> required <code>settings</code> <code>GIFSettings</code> <p>Settings of gif via <code>GIFSettings</code>.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save_gif.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_gif(\nfig: FigureTypePlotly | FigureTypeMatplotlib,\nfname: Path,\nax_fig: plt.Figure,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as gif file.\n    Notes:\n        This method is only supported for Matplotlib plots.\n    Args:\n        fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n        fname (Path): Path to save file.\n        ax_fig (plt.Figure): Figure to save.\n        settings (GIFSettings): Settings of gif via `GIFSettings`.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save_gif.\n    \"\"\"\nplot_classes = {\nplt.Figure: ClassicPlot,\ngo.Figure: PlotlyPlot,\n}\nplot_class = plot_classes.get(type(fig))\nif plot_class is not None:\nplot_class.plot_save_gif(\nfig=fig,\nax_fig=ax_fig,\nfname=fname,\nsettings=settings,\n**kwargs,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_image","title":"<code>to_image(fig, fname, fformat='png', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as image file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>Figure to save.</p> required <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>fformat</code> <code>str</code> <p>Format of file. Defaults to 'png'.</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for plot_save.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_image(\nfig: FigureTypePlotly | FigureTypeMatplotlib,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as image file.\n    Args:\n        fig (FigureTypePlotly | FigureTypeMatplotlib): Figure to save.\n        fname (Path): Path to save file.\n        fformat (str, optional): Format of file. Defaults to 'png'.\n        **kwargs (dict[str, Any]): Additional arguments for plot_save.\n    \"\"\"\nplot_classes = {\nplt.Figure: ClassicPlot,\ngo.Figure: PlotlyPlot,\n}\nplot_class = plot_classes.get(type(fig))\nif plot_class is not None:\nplot_class.plot_save(fig=fig, fname=fname, fformat=fformat, **kwargs)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_json","title":"<code>to_json(*x, fname, mode='w+', encoding='UTF-8', indent=4, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as json file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>mode</code> <code>str</code> <p>Mode of file. Defaults to 'w+'.</p> <code>'w+'</code> <code>encoding</code> <code>str</code> <p>Encoding of file. Defaults to 'UTF-8'.</p> <code>'UTF-8'</code> <code>indent</code> <code>int</code> <p>Indent of file. Defaults to 4.</p> <code>4</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for json.dump.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_json(\n*x: UniversalArray,\nfname: Path,\nmode: str = \"w+\",\nencoding: str = \"UTF-8\",\nindent: int = 4,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save shared states of math function as json file.\n    Args:\n        *x (UniversalArray): Arrays to save.\n        mode (str, optional): Mode of file. Defaults to 'w+'.\n        encoding (str, optional): Encoding of file. Defaults to 'UTF-8'.\n        indent (int, optional): Indent of file. Defaults to 4.\n        fname (Path): Path to save file.\n        **kwargs (dict[str, Any]): Additional arguments for json.dump.\n    \"\"\"\nwith Path(fname).open(mode=mode, encoding=encoding) as f:\njson.dump(\n{f\"x_{i}\": x[i].tolist() for i in range(len(x))},\nf,\nindent=indent,\n**kwargs,\n)\n</code></pre>"},{"location":"modules/api/data_generation/#umf.core.create.SaveBorg.to_pickle","title":"<code>to_pickle(*x, fname, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save shared states of math function as pickle file.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Arrays to save.</p> <code>()</code> <code>fname</code> <code>Path</code> <p>Path to save file.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments for numpy.savez.</p> <code>{}</code> Source code in <code>umf/core/create.py</code> Python<pre><code>@staticmethod\ndef to_pickle(*x: UniversalArray, fname: Path, **kwargs: dict[str, Any]) -&gt; None:\n\"\"\"Save shared states of math function as pickle file.\n    Args:\n        *x (UniversalArray): Arrays to save.\n        fname (Path): Path to save file.\n        **kwargs (Any): Additional arguments for numpy.savez.\n    \"\"\"\nnp.savez(fname, *x, **kwargs)\n</code></pre>"},{"location":"modules/api/distributions/","title":"Modules","text":"<p>Continuous distributions on the interval \\([0, 2\\pi]\\).</p> <p>Continuous bounded interval distributions for the umf package.</p> <p>Continuous distributions with support for semi-infinite intervals for the umf.</p> <p>Continuous variable support distributions for the umf module.</p> <p>Continous distributions with whole line support for the umf package.</p> <p>Discrete distributions with finite support for the umf package.</p> <p>Discrete distributions with infinite support.</p> <p>Mixed discrete-continuous distributions for the for the umf package.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution","title":"<code>VonMisesDistribution</code>","text":"<p>             Bases: <code>Continuous2PiInterval</code></p> <p>von Mises distribution.</p> <p>The von Mises distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... VonMisesDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n&gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n&gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The von Mises distribution is defined as follows for probability density:</p> \\[ f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class VonMisesDistribution(Continuous2PiInterval):\nr\"\"\"von Mises distribution.\n    The von Mises distribution is a continuous probability distribution on the\n    circle. It is a close approximation to the wrapped normal distribution,\n    which is the circular analogue of the normal distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... VonMisesDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n        &gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n        &gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The von Mises distribution is defined as follows for probability density:\n        $$\n        f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n        $$\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the von Mises distribution.\"\"\"\nreturn np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n2 * np.pi * special.i0(self.kappa)\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the von Mises distribution.\"\"\"\ndef _mode() -&gt; float | tuple[float, float]:\n\"\"\"Mode of the von Mises distribution.\"\"\"\nreturn self.mu\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=1 - special.i1(self.kappa) / special.i0(self.kappa),\nmode=_mode(),\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the von Mises distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.VonMisesDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the von Mises distribution.</p> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the von Mises distribution.\"\"\"\nreturn np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n2 * np.pi * special.i0(self.kappa)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution","title":"<code>WrappedAsymLaplaceDistribution</code>","text":"<p>             Bases: <code>Continuous2PiInterval</code></p> <p>Wrapped asymmetric Laplace distribution.</p> <p>The wrapped (asymmetric) Laplace distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... WrappedAsymLaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.5,\n... kappa=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.7,\n... kappa=0.7,\n... ).__eval__\n&gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.9,\n... kappa=0.9,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The wrapped Laplace distribution is defined as follows for probability density:</p> \\[ \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;= \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt] &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases} {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }} \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.<sup>1</sup></p> <ol> <li> <p>Wrapped asymmetric Laplace distribution. (2022, January 24). In Wikipedia. en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class WrappedAsymLaplaceDistribution(Continuous2PiInterval):\nr\"\"\"Wrapped asymmetric Laplace distribution.\n    The wrapped (asymmetric) Laplace distribution is a continuous probability\n    distribution on the circle. It is a close approximation to the wrapped normal\n    distribution, which is the circular analogue of the normal distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... WrappedAsymLaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.5,\n        ... kappa=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.7,\n        ... kappa=0.7,\n        ... ).__eval__\n        &gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.9,\n        ... kappa=0.9,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The wrapped Laplace distribution is defined as follows for probability\n        density:\n        $$\n        \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;=\n        \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt]\n        &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases}\n        {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }}\n        \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned}\n        $$\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.[^1]\n        [^1]: Wrapped asymmetric Laplace distribution. (2022, January 24).\n            _In Wikipedia._\n            https://en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution\n    Args:\n        x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        lambda_: The scale parameter of the distribution.\n        kappa: The concentration of the distribution around mu.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nlambda_: float = 1,\nkappa: float = 1,\n) -&gt; None:\nr\"\"\"Initialize a wrapped Laplace distribution.\n        Args:\n            *x (UniversalArray): The points at which to evaluate the distribution.\n            mu (float): The mean of the distribution. Defaults to 0.\n            lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n            kappa (float): The concentration of the distribution around mu.\n                Defaults to 1.\n        \"\"\"\nsuper().__init__(*x, mu=mu, kappa=kappa)\nself.lambda_ = lambda_\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\npart_1 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n)\n)\npart_2 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n)\n)\n# Combine the two parts\nreturn np.where(self._x &gt;= self.mu, part_1, part_2)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the wrapped Laplace distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=1\n- self.lambda_**2\n/ np.sqrt(\n(1 / self.kappa**2 + self.lambda_**2)\n* (self.kappa**2 + self.lambda_**2),\n),\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the wrapped Laplace distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.__init__","title":"<code>__init__(*x, mu=0, lambda_=1, kappa=1)</code>","text":"<p>Initialize a wrapped Laplace distribution.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nlambda_: float = 1,\nkappa: float = 1,\n) -&gt; None:\nr\"\"\"Initialize a wrapped Laplace distribution.\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\nsuper().__init__(*x, mu=mu, kappa=kappa)\nself.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_2pi_interval.WrappedAsymLaplaceDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the wrapped Laplace distribution.</p> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\npart_1 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n)\n)\npart_2 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n)\n)\n# Combine the two parts\nreturn np.where(self._x &gt;= self.mu, part_1, part_2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution","title":"<code>KumaraswamyDistribution</code>","text":"<p>             Bases: <code>ContinuousBoundedInterval</code></p> <p>Kumaraswamy distribution.</p> <p>The Kumaraswamy distribution is a continuous probability distribution with support on the interval [0, 1]. It is a generalization of the beta distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n&gt;&gt;&gt; plt.close()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"KumaraswamyDistribution-cml.png\",\n... dpi=300,\n... transparent=True\n... )\n</code></pre> Notes <p>The Kumaraswamy distribution is generally defined for the PDF as:</p> \\[ f(x; a, b) = abx^{a-1}(1-x^a)^{b-1} \\] <p>where \\(a, b &gt; 0\\) and \\(0 \\leq x \\leq 1\\). The CDF is given by:</p> \\[ F(x; a, b) = 1 - (1 - x^a)^b \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>a</code> <code>float</code> <p>The first shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>b</code> <code>float</code> <p>The second shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>class KumaraswamyDistribution(ContinuousBoundedInterval):\nr\"\"\"Kumaraswamy distribution.\n    The Kumaraswamy distribution is a continuous probability distribution with\n    support on the interval [0, 1]. It is a generalization of the beta\n    distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; plt.close()\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"KumaraswamyDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True\n        ... )\n    Notes:\n        The Kumaraswamy distribution is generally defined for the PDF as:\n        $$\n        f(x; a, b) = abx^{a-1}(1-x^a)^{b-1}\n        $$\n        where $a, b &gt; 0$ and $0 \\leq x \\leq 1$. The CDF is given by:\n        $$\n        F(x; a, b) = 1 - (1 - x^a)^b\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        a (float): The first shape parameter, which must be positive. Default is 1.\n        b (float): The second shape parameter, which must be positive. Default is 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\na: float = 1,\nb: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the Kumaraswamy distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotAPositiveNumberError(msg, b)\nsuper().__init__(*x, start=0, end=1, cumulative=cumulative)\nself.a = a\nself.b = b\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n        Returns:\n            UniversalArray: The value of the probability density function of the\n                Kumaraswamy distribution.\n        \"\"\"\nreturn (\nself.a\n* self.b\n* self._x ** (self.a - 1)\n* (1 - self._x**self.a) ** (self.b - 1)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n        Returns:\n            UniversalArray: The value of the cumulative distribution function of the\n                Kumaraswamy distribution.\n        \"\"\"  # noqa: E501\nreturn 1 - (1 - self._x**self.a) ** self.b\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Calculate the summary statistics of the Kumaraswamy distribution.\n        Returns:\n            SummaryStatisticsAPI: The summary statistics of the Kumaraswamy\n                distribution.\n        \"\"\"\nmode = (\n(self.a - 1) / (self.a + self.b - 2) if self.a &gt; 1 and self.b &gt; 1 else None\n)\nmean = (self.b * gamma(1 + 1 / self.a) * gamma(self.a - 1)) / (\nself.a * gamma(self.a + self.b)\n)\nreturn SummaryStatisticsAPI(\nmean=mean,\nmode=mode,\nvariance=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Calculate the summary statistics of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>SummaryStatisticsAPI</code> <code>SummaryStatisticsAPI</code> <p>The summary statistics of the Kumaraswamy distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.__init__","title":"<code>__init__(*x, a=1, b=1, cumulative=False)</code>","text":"<p>Initialize the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\na: float = 1,\nb: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the Kumaraswamy distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotAPositiveNumberError(msg, b)\nsuper().__init__(*x, start=0, end=1, cumulative=cumulative)\nself.a = a\nself.b = b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Calculate the cumulative distribution function of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the cumulative distribution function of the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n    Returns:\n        UniversalArray: The value of the cumulative distribution function of the\n            Kumaraswamy distribution.\n    \"\"\"  # noqa: E501\nreturn 1 - (1 - self._x**self.a) ** self.b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_bounded_interval.KumaraswamyDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Calculate the probability density function of the Kumaraswamy distribution.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the probability density function of the Kumaraswamy distribution.</p> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n    Returns:\n        UniversalArray: The value of the probability density function of the\n            Kumaraswamy distribution.\n    \"\"\"\nreturn (\nself.a\n* self.b\n* self._x ** (self.a - 1)\n* (1 - self._x**self.a) ** (self.b - 1)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution","title":"<code>ChiSquaredDistribution</code>","text":"<p>             Bases: <code>SemiContinuous</code></p> <p>Chi-square distribution.</p> <p>The chi-square distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the sum of the squares of independent standard normal random variables. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The chi-square distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n... x,\n... k=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n... x,\n... k=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n... x,\n... k=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The chi-square distribution is generally defined for the PDF as:</p> \\[ f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2) \\] <p>and for the CDF as:</p> \\[ F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2) \\] <p>where \\(k\\) is the degrees of freedom.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>k</code> <code>float</code> <p>Degrees of freedom. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class ChiSquaredDistribution(SemiContinuous):\nr\"\"\"Chi-square distribution.\n    The chi-square distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the sum of the squares of\n    independent standard normal random variables. It is a transformation of the normal\n    distribution, where the logarithm of the variable is normally distributed. The\n    chi-square distribution has applications in various fields, such as finance,\n    biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n        ... x,\n        ... k=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n        ... x,\n        ... k=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n        ... x,\n        ... k=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The chi-square distribution is generally defined for the PDF as:\n        $$\n        f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2)\n        $$\n        and for the CDF as:\n        $$\n        F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2)\n        $$\n        where $k$ is the degrees of freedom.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        k (float): Degrees of freedom. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif k &lt;= 0:\nraise NotLargerThanZeroError(k)\nsuper().__init__(*x, cumulative=cumulative)\nself.k = k\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (2 ** (self.k / 2) * gamma(self.k / 2))\n* self._x ** (self.k / 2 - 1)\n* np.exp(-self._x / 2)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.k,\nvariance=2 * self.k,\nmode=self.k - 2 if self.k &gt; 2 else 0,  # noqa: PLR2004\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.__init__","title":"<code>__init__(*x, k=1.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif k &lt;= 0:\nraise NotLargerThanZeroError(k)\nsuper().__init__(*x, cumulative=cumulative)\nself.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.ChiSquaredDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (2 ** (self.k / 2) * gamma(self.k / 2))\n* self._x ** (self.k / 2 - 1)\n* np.exp(-self._x / 2)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution","title":"<code>DagumDistribution</code>","text":"<p>             Bases: <code>ContinuousPure</code></p> <p>Dagum distribution.</p> <p>The Dagum distribution is a continuous probability distribution that is defined on the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is characterized by its shape, scale, and shape parameters. The Dagum distribution is used in various fields, including economics, finance, and engineering, to model data that is non-negative and skewed to the right. It has a probability density function (PDF) and a cumulative distribution function (CDF) that can be used to calculate various statistical measures, such as mean, variance, and mode. \u258c</p> Notes <p>The Dagum distribution is generally defined for the PDF as:</p> \\[ f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{(p+1)/p}} \\] <p>and for the CDF as:</p> \\[ F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p} \\] <p>where \\(p\\) is the shape parameter, \\(a\\) is the scale parameter, and \\(b\\) is the shape parameter.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... DagumDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>a</code> <code>float</code> <p>Scale parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>NotLargerThanZeroError</code> <p>If p, a, or b is not larger than 0.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class DagumDistribution(ContinuousPure):\nr\"\"\"Dagum distribution.\n    The Dagum distribution is a continuous probability distribution that is defined on\n    the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is\n    characterized by its shape, scale, and shape parameters. The Dagum distribution is\n    used in various fields, including economics, finance, and engineering, to model\n    data that is non-negative and skewed to the right. It has a probability density\n    function (PDF) and a cumulative distribution function (CDF) that can be used to\n    calculate various statistical measures, such as mean, variance, and mode. \u258c\n    Notes:\n        The Dagum distribution is generally defined for the PDF as:\n        $$\n        f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b}\n        x\\right)^{p}\\right]^{(p+1)/p}}\n        $$\n        and for the CDF as:\n        $$\n        F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p}\n        $$\n        where $p$ is the shape parameter, $a$ is the scale parameter, and $b$ is the\n        shape parameter.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... DagumDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        p (float): Shape parameter. Must be greater than 0. Defaults to 1.\n        a (float): Scale parameter. Must be greater than 0. Defaults to 1.\n        b (float): Shape parameter. Must be greater than 0. Defaults to 1.\n    Raises:\n        NotLargerThanZeroError: If p, a, or b is not larger than 0.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\np: float = 1.0,\na: float = 1.0,\nb: float = 1.0,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif p &lt;= 0:\nmsg = \"p\"\nraise NotLargerThanZeroError(msg, p)\nif a &lt;= 0:\nmsg = \"a\"\nraise NotLargerThanZeroError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotLargerThanZeroError(msg, b)\nsuper().__init__(*x)\nself.p = p\nself.a = a\nself.b = b\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.p\n* self.a**self.p\n/ (\nself._x ** (self.p + 1)\n* (1 + (self.a / self.b) ** self.p * self._x**self.p)\n** ((self.p + 1) / self.p)\n)\n)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.a\n* gamma((self.p - 1) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p),\nvariance=self.a**2\n* (\ngamma((self.p - 2) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p)\n- (\nself.a\n* gamma((self.p - 1) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p)\n)\n** 2\n),\nmode=self.a\n* ((self.p / self.b) ** (1 / self.p))\n* ((self.p - 1) / self.p) ** (1 / self.p),\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.__init__","title":"<code>__init__(*x, p=1.0, a=1.0, b=1.0)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\np: float = 1.0,\na: float = 1.0,\nb: float = 1.0,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif p &lt;= 0:\nmsg = \"p\"\nraise NotLargerThanZeroError(msg, p)\nif a &lt;= 0:\nmsg = \"a\"\nraise NotLargerThanZeroError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotLargerThanZeroError(msg, b)\nsuper().__init__(*x)\nself.p = p\nself.a = a\nself.b = b\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.DagumDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.p\n* self.a**self.p\n/ (\nself._x ** (self.p + 1)\n* (1 + (self.a / self.b) ** self.p * self._x**self.p)\n** ((self.p + 1) / self.p)\n)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution","title":"<code>LogNormalDistribution</code>","text":"<p>             Bases: <code>SemiContinuousWSigma</code></p> <p>Log-normal distribution.</p> <p>The log-normal distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The log-normal distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The log-normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class LogNormalDistribution(SemiContinuousWSigma):\nr\"\"\"Log-normal distribution.\n    The log-normal distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The log-normal distribution has\n    applications in various fields, such as finance, biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The log-normal distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self._x * self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.exp(self.mu + self.sigma**2 / 2),\nvariance=(np.exp(self.sigma**2) - 1)\n* np.exp(2 * self.mu + self.sigma**2),\nmode=np.exp(self.mu - self.sigma**2),\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.LogNormalDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self._x * self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution","title":"<code>RayleighDistribution</code>","text":"<p>             Bases: <code>SemiContinuousWSigma</code></p> <p>Rayleigh distribution.</p> <p>The Rayleigh distribution is a continuous probability distribution that is commonly used in statistics to model the magnitude of a vector whose components are independent and identically distributed Gaussian random variables with zero mean. It is also used to describe the distribution of the magnitude of the sum of independent, identically distributed Gaussian random variables with zero mean and equal variance.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rayleigh distribution is generally defined for the PDF as:</p> \\[ f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>where \\(\\sigma\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class RayleighDistribution(SemiContinuousWSigma):\nr\"\"\"Rayleigh distribution.\n    The Rayleigh distribution is a continuous probability distribution that is commonly\n    used in statistics to model the magnitude of a vector whose components are\n    independent and identically distributed Gaussian random variables with zero mean.\n    It is also used to describe the distribution of the magnitude of the sum of\n    independent, identically distributed Gaussian random variables with zero mean\n    and equal variance.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Rayleigh distribution is generally defined for the PDF as:\n        $$\n        f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n        where $\\sigma$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.sqrt(np.pi / 2) * self.sigma,\nvariance=(4 - np.pi) / 2 * self.sigma**2,\nmode=self.sigma,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.RayleighDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution","title":"<code>WeibullDistribution</code>","text":"<p>             Bases: <code>SemiContinuous</code></p> <p>Weibull distribution.</p> <p>The Weibull distribution is a continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The Weibull distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n... x,\n... lambda_=1,\n... k=0.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n... x,\n... lambda_=2,\n... k=1.0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n... x,\n... lambda_=3,\n... k=1.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Weibull distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}     \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>where \\(\\lambda\\) is the scale parameter and \\(k\\) is the shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> required <code>k</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class WeibullDistribution(SemiContinuous):\nr\"\"\"Weibull distribution.\n    The Weibull distribution is a continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The Weibull distribution has\n    applications in various fields, such as finance, biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n        ... x,\n        ... lambda_=1,\n        ... k=0.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n        ... x,\n        ... lambda_=2,\n        ... k=1.0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n        ... x,\n        ... lambda_=3,\n        ... k=1.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Weibull distribution is generally defined for the PDF as:\n        $$\n        f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}\n            \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n        where $\\lambda$ is the scale parameter and $k$ is the shape parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda (float): Scale parameter. Defaults to 1.\n        k (float): Shape parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nlambda_: float = 1.0,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif lambda_ &lt; 0:\nmsg = \"lambda_\"\nraise NotAPositiveNumberError(msg, lambda_)\nif k &lt;= 0:\nmsg = \"k\"\nraise NotLargerThanZeroError(msg, k)\nsuper().__init__(*x, cumulative=cumulative)\nself.lambda_ = lambda_\nself.k = k\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.k\n/ self.lambda_\n* (self._x / self.lambda_) ** (self.k - 1)\n* np.exp(-((self._x / self.lambda_) ** self.k))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.lambda_ * gamma(1 + 1 / self.k),\nvariance=self.lambda_**2\n* (gamma(1 + 2 / self.k) - gamma(1 + 1 / self.k) ** 2),\nmode=self.lambda_ * (self.k - 1) ** (1 / self.k) if self.k &gt; 1 else 0,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.__init__","title":"<code>__init__(*x, lambda_=1.0, k=1.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nlambda_: float = 1.0,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif lambda_ &lt; 0:\nmsg = \"lambda_\"\nraise NotAPositiveNumberError(msg, lambda_)\nif k &lt;= 0:\nmsg = \"k\"\nraise NotLargerThanZeroError(msg, k)\nsuper().__init__(*x, cumulative=cumulative)\nself.lambda_ = lambda_\nself.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_semi_infinite_interval.WeibullDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.k\n/ self.lambda_\n* (self._x / self.lambda_) ** (self.k - 1)\n* np.exp(-((self._x / self.lambda_) ** self.k))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution","title":"<code>GeneralizedExtremeValueDistribution</code>","text":"<p>             Bases: <code>ContinuousMixed</code></p> <p>Generalized extreme value distribution.</p> <p>The generalized extreme value distribution is a family of continuous probability distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet and Weibull families also known as type I, II and III extreme value distributions. The generalized extreme value distribution is also sometimes referred to as the Fisher-Tippett distribution or the extreme value type I distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedExtremeValueDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized extreme value distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right] \\exp \\left[ - \\exp \\left( - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized extreme value distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0.0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedExtremeValueDistribution(ContinuousMixed):\nr\"\"\"Generalized extreme value distribution.\n    The generalized extreme value distribution is a family of continuous probability\n    distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet\n    and Weibull families also known as type I, II and III extreme value distributions.\n    The generalized extreme value distribution is also sometimes referred to as the\n    Fisher-Tippett distribution or the extreme value type I distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedExtremeValueDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized extreme value distribution is defined as follows for probability\n        density function:\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta\n        \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma}\n        \\right) \\right] \\exp \\left[ - \\exp \\left( -\n        \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n        The generalized extreme value distribution is defined as follows for cumulative\n        distribution function:\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x -\n        \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right]\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        zeta (float): Shape parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n@property\ndef t_factor(self) -&gt; UniversalArray:\n\"\"\"Factor of the t-distribution.\"\"\"\nif self.zeta == 0:\nreturn np.exp(-self._x - self.mu) / self.sigma\nreturn np.exp(-((1 + self.zeta * self._x) ** (-1 / self.zeta))) / self.sigma\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\nreturn self.t_factor**self.zeta * np.exp(-self.t_factor)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\nreturn np.exp(-self.t_factor)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the gen. extreme value distribution.\"\"\"\nif self.zeta != 0 and self.zeta &lt; 1:\nmean = self.mu + self.sigma * (gamma(1 - self.zeta) - 1) / self.zeta\nelif self.zeta == 0:\nmean = self.mu + self.sigma * np.euler_gamma\nelse:\nmean = np.inf\nif self.zeta != 0 and self.zeta &lt; 0.5:  # noqa: PLR2004\nvariance = (\nself.sigma**2\n* (gamma(1 - 2 * self.zeta) - gamma(1 - self.zeta) ** 2)\n/ self.zeta**2\n)\nelif self.zeta == 0:\nvariance = self.sigma**2 * np.pi**2 / 6\nelse:\nvariance = np.inf\nif self.zeta != 0:\nmode = self.mu + self.sigma * (1 - self.zeta ** (-1)) ** (-1 / self.zeta)\nelse:\nmode = self.mu\nreturn SummaryStatisticsAPI(\nmean=mean,\nvariance=variance,\nmode=mode,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the gen. extreme value distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.t_factor","title":"<code>t_factor: UniversalArray</code>  <code>property</code>","text":"<p>Factor of the t-distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the gen. extreme value distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\nreturn np.exp(-self.t_factor)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedExtremeValueDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the gen. extreme value distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\nreturn self.t_factor**self.zeta * np.exp(-self.t_factor)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution","title":"<code>GeneralizedParetoDistribution</code>","text":"<p>             Bases: <code>ContinuousMixed</code></p> <p>Generalized Pareto distribution.</p> <p>The generalized Pareto distribution is a family of continuous probability distributions that includes the exponential, Weibull, and uniform distributions. The generalized Pareto distribution is often used to model the tails of another distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized Pareto distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta - 1} &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized Pareto distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\begin{cases} 1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if } \\zeta \\neq 0 \\\\ 1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedParetoDistribution(ContinuousMixed):\nr\"\"\"Generalized Pareto distribution.\n    The generalized Pareto distribution is a family of continuous probability\n    distributions that includes the exponential, Weibull, and uniform distributions.\n    The generalized Pareto distribution is often used to model the tails of another\n    distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized Pareto distribution is defined as follows for probability\n        density function:\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta -\n        1} &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if }\n        \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n        The generalized Pareto distribution is defined as follows for cumulative\n        distribution function:\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if }\n        \\zeta \\neq 0 \\\\\n        1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        zeta (float): Shape parameter. Defaults to 0.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nzeta: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the generalized Pareto distribution.\"\"\"\nif (min_x := np.min(x)) &lt; 0:\nmsg = \"*x\"\nraise NotAPositiveNumberError(msg, number=float(min_x))\nsuper().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn np.exp(-(self._x - self.mu) / self.sigma)\nreturn (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / (self.zeta + 1)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn 1 - np.exp(-(self._x - self.mu) / self.sigma)\nreturn 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / self.zeta\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the generalized Pareto distribution.\"\"\"\nSummaryStatisticsAPI(\nmean=self.mu + self.sigma / (1 - self.zeta) if self.zeta &lt; 1 else np.inf,\nvariance=self.sigma**2 / (1 - self.zeta) ** 2 / (1 - 2 * self.zeta)\nif self.zeta &lt; 0.5  # noqa: PLR2004\nelse np.inf,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the generalized Pareto distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, zeta=0, cumulative=False)</code>","text":"<p>Initialize the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nzeta: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the generalized Pareto distribution.\"\"\"\nif (min_x := np.min(x)) &lt; 0:\nmsg = \"*x\"\nraise NotAPositiveNumberError(msg, number=float(min_x))\nsuper().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn 1 - np.exp(-(self._x - self.mu) / self.sigma)\nreturn 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / self.zeta\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_variable_support.GeneralizedParetoDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the generalized Pareto distribution.</p> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn np.exp(-(self._x - self.mu) / self.sigma)\nreturn (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / (self.zeta + 1)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution","title":"<code>CauchyDistribution</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Cauchy distribution.</p> <p>The Cauchy distribution is a continuous probability distribution that has no mean or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n... x,\n... gamma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n... x,\n... gamma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n... x,\n... gamma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cauchy distribution is defined as:</p> \\[ f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 + \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]} \\] <p>where \\(x_0\\) is the location parameter and \\(\\gamma\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Cauchy distribution is:</p> \\[ F(x | x_0, \\gamma) = \\frac{1}{\\pi} \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>gamma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class CauchyDistribution(ContinuousDistributionBase):\nr\"\"\"Cauchy distribution.\n    The Cauchy distribution is a continuous probability distribution that has no mean\n    or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n        ... x,\n        ... gamma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n        ... x,\n        ... gamma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n        ... x,\n        ... gamma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Cauchy distribution is defined as:\n        $$\n        f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 +\n        \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]}\n        $$\n        where $x_0$ is the location parameter and $\\gamma$ is the scale parameter.\n        The cumulative distribution function (CDF) of the Cauchy distribution is:\n        $$\n        F(x | x_0, \\gamma) = \\frac{1}{\\pi}\n        \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2}\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        gamma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\ngamma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif gamma &lt;= 0:\nmsg = \"gamma must be positive\"\nraise ValueError(msg)\nself.gamma = gamma\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.nan,\nvariance=np.nan,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.__init__","title":"<code>__init__(*x, mu=0, gamma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\ngamma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif gamma &lt;= 0:\nmsg = \"gamma must be positive\"\nraise ValueError(msg)\nself.gamma = gamma\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.CauchyDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution","title":"<code>ExponentialDistribution</code>","text":"<p>             Bases: <code>ContinuousWLambda</code></p> <p>Exponential distribution.</p> <p>The exponential distribution is a continuous probability distribution that describes the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is a one-parameter family of curves, with the rate parameter \\(\\lambda\\) controlling the shape of the distribution. The exponential distribution is widely used in reliability theory, queueing theory, and other fields.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n... x,\n... lambda_=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n... x,\n... lambda_=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n... x,\n... lambda_=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The exponential distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda) = \\lambda e^{-\\lambda x} \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda) = 1 - e^{-\\lambda x} \\] <p>where \\(\\lambda\\) is the rate parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda_</code> <code>float</code> <p>Rate parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class ExponentialDistribution(ContinuousWLambda):\nr\"\"\"Exponential distribution.\n    The exponential distribution is a continuous probability distribution that\n    describes the time between events in a Poisson process, where events occur\n    continuously and independently at a constant average rate. It is a one-parameter\n    family of curves, with the rate parameter $\\lambda$ controlling the shape of the\n    distribution. The exponential distribution is widely used in reliability theory,\n    queueing theory, and other fields.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n        ... x,\n        ... lambda_=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n        ... x,\n        ... lambda_=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n        ... x,\n        ... lambda_=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The exponential distribution is generally defined for the PDF as:\n        $$\n        f(x | \\lambda) = \\lambda e^{-\\lambda x}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\lambda) = 1 - e^{-\\lambda x}\n        $$\n        where $\\lambda$ is the rate parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda_ (float): Rate parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn self.lambda_ * np.exp(-self.lambda_ * self._x)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-self.lambda_ * self._x)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=1 / self.lambda_,\nvariance=1 / self.lambda_**2,\nmode=0,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-self.lambda_ * self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.ExponentialDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn self.lambda_ * np.exp(-self.lambda_ * self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution","title":"<code>GaussianDistribution</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Gaussian distribution.</p> <p>The Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GaussianDistribution(ContinuousWSigma):\nr\"\"\"Gaussian distribution.\n    The Gaussian distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gaussian distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.sigma**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GaussianDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution","title":"<code>GeneralizedNormalDistribution</code>","text":"<p>             Bases: <code>ContinuousWBeta</code></p> <p>Generalized normal distribution.</p> <p>The generalized normal distribution is a probability distribution that extends the normal distribution to incorporate an additional shape parameter, allowing for greater flexibility in modeling a wider range of data distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedNormalDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}   \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2} \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha}, \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma \\left(\\frac{1}{\\alpha}\\right)}\\right) \\] <p>where \\(\\alpha\\) is the shape parameter, \\(\\beta\\) is the scale parameter, and \\(\\mu\\) is the location parameter plus \\(\\Gamma\\) as the gamma function. The PDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha, \\beta &gt; 0\\). The CDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha &gt; 0\\) and rquires the unnormalized lower incomplete gamma function.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GeneralizedNormalDistribution(ContinuousWBeta):\nr\"\"\"Generalized normal distribution.\n    The generalized normal distribution is a probability distribution that extends the\n    normal distribution to incorporate an additional shape parameter, allowing for\n    greater flexibility in modeling a wider range of data distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedNormalDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized normal distribution is generally defined for the PDF as:\n        $$\n        f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}\n          \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2}\n        \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha},\n        \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma\n        \\left(\\frac{1}{\\alpha}\\right)}\\right)\n        $$\n        where $\\alpha$ is the shape parameter, $\\beta$ is the scale parameter, and\n        $\\mu$ is the location parameter plus $\\Gamma$ as the gamma function.\n        The PDF is defined for $x \\in \\mathbb{R}$ and $\\alpha, \\beta &gt; 0$.\n        The CDF is defined for $x \\in \\mathbb{R}$ and $\\alpha &gt; 0$ and rquires the\n        unnormalized lower incomplete gamma function.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        alpha (float): Shape parameter. Defaults to 1.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nalpha: float = 1,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif beta &lt; 0:\nmsg = \"beta\"\nraise NotAPositiveNumberError(msg, beta)\nif alpha &lt;= 0:\nmsg = \"alpha\"\nraise NotLargerThanZeroError(msg, alpha)\nsuper().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.beta\n/ (2 * self.alpha * gamma(1.0 / self.beta))\n* np.exp(-np.abs((self._x - self.mu) / self.alpha) ** self.beta)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 + np.sign(self._x - self.mu) * (\n1 / (2 * gamma(1 / self.beta))\n) * gammainc(\n1 / self.beta,\nnp.abs((self._x - self.mu) / self.alpha) ** self.beta,\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.alpha**2 * gamma(3 / self.beta) / gamma(1 / self.beta),\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.__init__","title":"<code>__init__(*x, mu=0, alpha=1, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nalpha: float = 1,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif beta &lt; 0:\nmsg = \"beta\"\nraise NotAPositiveNumberError(msg, beta)\nif alpha &lt;= 0:\nmsg = \"alpha\"\nraise NotLargerThanZeroError(msg, alpha)\nsuper().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\nself.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 + np.sign(self._x - self.mu) * (\n1 / (2 * gamma(1 / self.beta))\n) * gammainc(\n1 / self.beta,\nnp.abs((self._x - self.mu) / self.alpha) ** self.beta,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GeneralizedNormalDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.beta\n/ (2 * self.alpha * gamma(1.0 / self.beta))\n* np.exp(-np.abs((self._x - self.mu) / self.alpha) ** self.beta)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution","title":"<code>GumbelDistribution</code>","text":"<p>             Bases: <code>ContinuousWBeta</code></p> <p>Gumbel distribution.</p> <p>The Gumbel distribution is a continuous probability distribution that is used to model the distribution of the maximum (or the minimum) of a number of samples of various distributions. It is a two-parameter family of curves, with the location parameter \\(\\mu\\) controlling the location of the distribution and the scale parameter \\(\\beta\\) controlling the spread of the distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n... x,\n... mu=0,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n... x,\n... mu=5,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n... x,\n... mu=10,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gumbel distribution is defined as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}} \\] <p>where \\(\\mu\\) is the location parameter and \\(\\beta\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Gumbel distribution is:</p> \\[ F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GumbelDistribution(ContinuousWBeta):\nr\"\"\"Gumbel distribution.\n    The Gumbel distribution is a continuous probability distribution that is used to\n    model the distribution of the maximum (or the minimum) of a number of samples of\n    various distributions. It is a two-parameter family of curves, with the location\n    parameter $\\mu$ controlling the location of the distribution and the scale\n    parameter $\\beta$ controlling the spread of the distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n        ... x,\n        ... mu=0,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n        ... x,\n        ... mu=5,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n        ... x,\n        ... mu=10,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gumbel distribution is defined as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta}\n        e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}}\n        $$\n        where $\\mu$ is the location parameter and $\\beta$ is the scale parameter.\n        The cumulative distribution function (CDF) of the Gumbel distribution is:\n        $$\n        F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}}\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ self.beta\n* np.exp(\n-(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n/ self.beta,\n)\n)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu + self.beta * np.euler_gamma,\nvariance=(np.pi**2 / 6) * self.beta**2,\nmode=self.mu + self.beta * np.log(np.log(3)),\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.GumbelDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ self.beta\n* np.exp(\n-(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n/ self.beta,\n)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution","title":"<code>LaplaceDistribution</code>","text":"<p>             Bases: <code>ContinuousWBeta</code></p> <p>Laplace distribution.</p> <p>The Laplace distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Laplace distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu) \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right) \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LaplaceDistribution(ContinuousWBeta):\nr\"\"\"Laplace distribution.\n    The Laplace distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Laplace distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu)\n        \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right)\n        $$\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.array(\n0.5\n+ 0.5\n* np.sign(self._x - self.mu)\n* (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=2 * self.beta**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.array(\n0.5\n+ 0.5\n* np.sign(self._x - self.mu)\n* (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LaplaceDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution","title":"<code>LogisticDistribution</code>","text":"<p>             Bases: <code>ContinuousWBeta</code></p> <p>Logistic distribution.</p> <p>The logistic distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Logistic distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)} \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LogisticDistribution(ContinuousWBeta):\nr\"\"\"Logistic distribution.\n    The logistic distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Logistic distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x -\n        \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)}\n        $$\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn np.array(\n1\n/ self.beta\n* np.exp(-(self._x - self.mu) / self.beta)\n/ (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=(np.pi**2 * self.beta**2) / 3,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.LogisticDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn np.array(\n1\n/ self.beta\n* np.exp(-(self._x - self.mu) / self.beta)\n/ (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution","title":"<code>SkewGaussianDistribution</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Skew Gaussian distribution.</p> <p>The Skew Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions with skewness.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... SkewGaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=0,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=1,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=-1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Skew Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation, and \\(\\alpha\\) is the skewness.</p> <p>The CDF is not available in closed form.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Skewness. Defaults to 0.</p> <code>0</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class SkewGaussianDistribution(ContinuousWSigma):\nr\"\"\"Skew Gaussian distribution.\n    The Skew Gaussian distribution is a continuous probability distribution that is\n    widely used in statistics to describe the normal distributions with skewness.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... SkewGaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=-1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Skew Gaussian distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n        \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation, and $\\alpha$ is the\n        skewness.\n        The CDF is not available in closed form.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        alpha (float): Skewness. Defaults to 0.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nalpha: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n* (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.sigma**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, alpha=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nalpha: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.SkewGaussianDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n* (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution","title":"<code>VoigtDistribution</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Voigt distribution.</p> <p>The Voigt distribution is a continuous probability distribution that is widely used in physics and spectroscopy to describe the line shape of spectral lines. It is a convolution of a Gaussian distribution and a Lorentzian distribution, and is useful for modeling the effects of both natural and instrumental broadening on spectral lines.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... VoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Voigt distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>which can be further simplified to:</p> \\[ V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}} \\] <p>with \\(\\operatorname {Re} [w(z)\\) as the real part of the Faddeeva function and \\(z\\) as:</p> \\[ z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation and \\(\\gamma\\) is the Lorentzian width.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>gamma</code> <code>float</code> <p>Lorentzian width. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class VoigtDistribution(ContinuousWSigma):\nr\"\"\"Voigt distribution.\n    The Voigt distribution is a continuous probability distribution that is widely used\n    in physics and spectroscopy to describe the line shape of spectral lines. It is a\n    convolution of a Gaussian distribution and a Lorentzian distribution, and is useful\n    for modeling the effects of both natural and instrumental broadening on spectral\n    lines.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... VoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Voigt distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n        which can be further simplified to:\n        $$\n        V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}}\n        $$\n        with $\\operatorname {Re} [w(z)$ as the real part of the Faddeeva function and\n        $z$ as:\n        $$\n        z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation and $\\gamma$ is the\n        Lorentzian width.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        gamma (float): Lorentzian width. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nsigma: float = 1,\ngamma: float = 1,\nmu: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif sigma &lt; 0:\nmsg = \"sigma\"\nraise NotAPositiveNumberError(msg, sigma)\nif gamma &lt; 0:\nmsg = \"gamma\"\nraise NotAPositiveNumberError(msg, gamma)\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.gamma = gamma\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nz = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\nreturn np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=0,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.__init__","title":"<code>__init__(*x, sigma=1, gamma=1, mu=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nsigma: float = 1,\ngamma: float = 1,\nmu: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif sigma &lt; 0:\nmsg = \"sigma\"\nraise NotAPositiveNumberError(msg, sigma)\nif gamma &lt; 0:\nmsg = \"gamma\"\nraise NotAPositiveNumberError(msg, gamma)\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.gamma = gamma\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.continuous_whole_line_support.VoigtDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nz = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\nreturn np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution","title":"<code>BernoulliDistribution</code>","text":"<p>             Bases: <code>DiscreteP</code></p> <p>Bernoulli distribution.</p> <p>The Bernoulli distribution is a discrete distribution with two possible outcomes, 0 and 1. It is the simplest discrete distribution. It is a special case of the binomial distribution where a single trial is conducted (n=1).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BernoulliDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bernoulli distribution is defined as follows:</p> \\[ f(x;p) = p^x (1-p)^{1-x} \\] <p>where \\(x \\in \\{0, 1\\}\\) and \\(p \\in [0, 1]\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BernoulliDistribution(DiscreteP):\nr\"\"\"Bernoulli distribution.\n    The Bernoulli distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is the simplest discrete distribution. It is a\n    special case of the binomial distribution where a single trial is\n    conducted (n=1).\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BernoulliDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Bernoulli distribution is defined as follows:\n        $$\n        f(x;p) = p^x (1-p)^{1-x}\n        $$\n        where $x \\in \\{0, 1\\}$ and $p \\in [0, 1]$.\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n    \"\"\"\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\nreturn self.p**self._x * (self.q) ** (1 - self._x)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Bernoulli distribution.\"\"\"\ndef _mode() -&gt; float | tuple[float, float]:\n\"\"\"Mode of the Bernoulli distribution.\"\"\"\nthreshold = 0.5\nif self.p &gt; threshold:\nreturn 1\nreturn 0 if self.p &lt; threshold else (0, 1)\nreturn SummaryStatisticsAPI(\nmean=self.p,\nvariance=self.p * self.q,\nmode=_mode(),\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Bernoulli distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BernoulliDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Bernoulli distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\nreturn self.p**self._x * (self.q) ** (1 - self._x)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution","title":"<code>BinomialDistribution</code>","text":"<p>             Bases: <code>DiscreteP</code></p> <p>Binomial distribution.</p> <p>The binomial distribution is a discrete distribution with two possible outcomes, 0 and 1. It is a generalization of the Bernoulli distribution where \\(n\\) trials are conducted.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n&gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n&gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The binomial distribution is defined as follows for probability mass function:</p> \\[ f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\).</p> <p>The binomial distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\). This expression is also known as the regularized incomplete beta function.</p> \\[ F(x;n,p) = I_{1-p}(n-k, k+1) \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> required <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BinomialDistribution(DiscreteP):\nr\"\"\"Binomial distribution.\n    The binomial distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is a generalization of the Bernoulli distribution\n    where $n$ trials are conducted.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The binomial distribution is defined as follows for probability mass function:\n        $$\n        f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        The binomial distribution is defined as follows for cumulative distribution\n        function:\n        $$\n        F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        This expression is also known as the regularized incomplete beta function.\n        $$\n        F(x;n,p) = I_{1-p}(n-k, k+1)\n        $$\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n        cumulative: If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Binomial distribution.\"\"\"\nsuper().__init__(*x, p=p, cumulative=cumulative)\nself.n = np.full_like(self._x, self._x[-1])\nself.k = self._x\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Binomial distribution.\"\"\"\nreturn (\ncombinations(self.n, self.k)\n* self.p**self.k\n* self.q ** (self.n - self.k)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\nreturn np.array(\n[\nnp.sum(\n[\ncombinations(self.n[i], k)\n* self.p**k\n* self.q ** (self.n[i] - k)\nfor k in range(self.k[i] + 1)\n],\n)\nfor i in range(len(self._x))\n],\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Binomial distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.n.max() * self.p,\nvariance=self.n.max() * self.p * self.q,\nmode=math.ceil((self.n.max() + 1) * self.p) - 1,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Binomial distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.__init__","title":"<code>__init__(*x, p, cumulative=False)</code>","text":"<p>Initialize the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Binomial distribution.\"\"\"\nsuper().__init__(*x, p=p, cumulative=cumulative)\nself.n = np.full_like(self._x, self._x[-1])\nself.k = self._x\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\nreturn np.array(\n[\nnp.sum(\n[\ncombinations(self.n[i], k)\n* self.p**k\n* self.q ** (self.n[i] - k)\nfor k in range(self.k[i] + 1)\n],\n)\nfor i in range(len(self._x))\n],\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_finite_support.BinomialDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Binomial distribution.</p> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Binomial distribution.\"\"\"\nreturn (\ncombinations(self.n, self.k)\n* self.p**self.k\n* self.q ** (self.n - self.k)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution","title":"<code>BoltzmannDistribution</code>","text":"<p>             Bases: <code>DiscretePure</code></p> <p>Boltzmann distribution.</p> <p>The Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of energy among particles in a system at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... BoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n&gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n&gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n&gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Boltzmann distribution is defined for the probability mass function as:</p> \\[ F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right) \\] <p>where \\(p_i\\) is the probability of a system being in state \\(i\\), \\(p_j\\) is the probability of a system being in state \\(j\\), \\(\\varepsilon_i\\) is the energy of state \\(i\\), \\(\\varepsilon_j\\) is the energy of state \\(j\\), \\(k\\) is the Boltzmann constant, and \\(T\\) is the temperature.</p> Info <p>For simplicity, the exponentianal term of the Boltzmann factor \\(k\\) is simpflified from  \\(1.380649 \\times 10^{-23}\\) to 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>energy_i</code> <code>float</code> <p>The energy of state \\(i\\).</p> required <code>energy_j</code> <code>float</code> <p>The energy of state \\(j\\).</p> required <code>temperature</code> <code>float</code> <p>The temperature of the system.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class BoltzmannDistribution(DiscretePure):\nr\"\"\"Boltzmann distribution.\n    The Boltzmann distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of energy among particles\n    in a system at a given temperature in statistical mechanics and thermodynamics.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... BoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n        &gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n        &gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n        &gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Boltzmann distribution is defined for the probability mass function as:\n        $$\n        F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac\n        {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right)\n        $$\n        where $p_i$ is the probability of a system being in state $i$, $p_j$ is the\n        probability of a system being in state $j$, $\\varepsilon_i$ is the energy of\n        state $i$, $\\varepsilon_j$ is the energy of state $j$, $k$ is the Boltzmann\n        constant, and $T$ is the temperature.\n    Info:\n        For simplicity, the exponentianal term of the Boltzmann factor $k$ is\n        simpflified from  $1.380649 \\times 10^{-23}$ to 1.\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        energy_i (float): The energy of state $i$.\n        energy_j (float): The energy of state $j$.\n        temperature (float): The temperature of the system.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nenergy_i: float,\nenergy_j: float,\nk: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Boltzmann distribution.\"\"\"\nif energy_i == energy_j:\nmsg = \"'energy_i' and 'energy_j' cannot be equal.\"\nraise ValueError(msg)\nif energy_i &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_i\",\nnumber=energy_i,\n)\nif energy_j &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_j\",\nnumber=energy_j,\n)\nif (min_temp := float(np.min(x))) &lt;= 0:\nraise NotLargerThanZeroError(\nvar_number=\"temperature\",\nnumber=min_temp,\n)\nsuper().__init__(*x)\nself.energy_i = energy_i\nself.energy_j = energy_j\nself.temperature = self._x\nself.k = k\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\nreturn np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Boltzmann distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Boltzmann distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.__init__","title":"<code>__init__(*x, energy_i, energy_j, k=1)</code>","text":"<p>Initialize the Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nenergy_i: float,\nenergy_j: float,\nk: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Boltzmann distribution.\"\"\"\nif energy_i == energy_j:\nmsg = \"'energy_i' and 'energy_j' cannot be equal.\"\nraise ValueError(msg)\nif energy_i &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_i\",\nnumber=energy_i,\n)\nif energy_j &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_j\",\nnumber=energy_j,\n)\nif (min_temp := float(np.min(x))) &lt;= 0:\nraise NotLargerThanZeroError(\nvar_number=\"temperature\",\nnumber=min_temp,\n)\nsuper().__init__(*x)\nself.energy_i = energy_i\nself.energy_j = energy_j\nself.temperature = self._x\nself.k = k\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.BoltzmannDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\nreturn np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution","title":"<code>GausKuzminDistribution</code>","text":"<p>             Bases: <code>DiscretePure</code></p> <p>Gaus-Kuzmin distribution.</p> <p>The Gaus-Kuzmin distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaus-Kuzmin distribution is defined for the PMF as follows:</p> \\[ F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right] \\] <p>where \\(k\\) is the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>The Gaus-Kuzmin distribution is defined for the CDF as follows:</p> \\[ F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right) \\] <p>For more information about the Gaus-Kuzmin distribution, see also en.wikipedia.org/wiki/Gauss-Kuzmin_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class GausKuzminDistribution(DiscretePure):\nr\"\"\"Gaus-Kuzmin distribution.\n    The Gaus-Kuzmin distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of the number of steps\n    taken by a random walker on a line before reaching a given distance from the origin.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gaus-Kuzmin distribution is defined for the PMF as\n        follows:\n        $$\n        F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right]\n        $$\n        where $k$ is the number of steps taken by a random walker on a line before\n        reaching a given distance from the origin.\n        The Gaus-Kuzmin distribution is defined for the CDF as follows:\n        $$\n        F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right)\n        $$\n        For more information about the Gaus-Kuzmin distribution, see also\n        &lt;https://en.wikipedia.org/wiki/Gauss-Kuzmin_distribution&gt;\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n    \"\"\"\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\nreturn -np.log2(1 - 1 / (self._x + 1) ** 2)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\nreturn 1 - np.log2((self._x + 2) / (self._x + 1))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Gaus-Kuzmin distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.inf,\nvariance=np.inf,\nmode=1,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Gaus-Kuzmin distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Gaus-Kuzmin distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\nreturn 1 - np.log2((self._x + 2) / (self._x + 1))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.GausKuzminDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Gaus-Kuzmin distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\nreturn -np.log2(1 - 1 / (self._x + 1) ** 2)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution","title":"<code>MaxwellBoltzmannDistribution</code>","text":"<p>             Bases: <code>DiscretePure</code></p> <p>Maxwell-Boltzmann distribution.</p> <p>The Maxwell-Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the speeds of particles in a gas at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n... x,\n... a=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n... x,\n... a=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n... x,\n... a=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"MaxwellBoltzmannDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The Maxwell-Boltzmann distribution is defined for the PMF as follows:</p> \\[ F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}} \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>where \\(x\\) is the speed of a particle, \\(a\\) is the most probable speed of \\(a\\), \\(\\pi\\) is the constant pi, and \\(a\\) is a parametrization.</p> <p>The Maxwell-Boltzmann distribution is defined for the CDF as follows:</p> \\[ F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right) -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>For more informtation about the Maxwell-Boltzmann distribution, see also en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>a(float)</code> <p>A parametrization for the Co-Factors of the Maxwell-Boltzmann distribution.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class MaxwellBoltzmannDistribution(DiscretePure):\nr\"\"\"Maxwell-Boltzmann distribution.\n    The Maxwell-Boltzmann distribution is a discrete probability distribution with\n    discrete infinite support. It is used to describe the distribution of the speeds of\n    particles in a gas at a given temperature in statistical mechanics and\n    thermodynamics.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"MaxwellBoltzmannDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The Maxwell-Boltzmann distribution is defined for the PMF as follows:\n        $$\n        F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}}\n        \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n        where $x$ is the speed of a particle, $a$ is the most probable speed of $a$,\n        $\\pi$ is the constant pi, and $a$ is a parametrization.\n        The Maxwell-Boltzmann distribution is defined for the CDF as follows:\n        $$\n        F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right)\n        -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp\n        \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n        For more informtation about the Maxwell-Boltzmann distribution, see also\n        https://en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        a(float): A parametrization for the Co-Factors of the Maxwell-Boltzmann\n            distribution.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nsuper().__init__(*x, cumulative=cumulative)\nself.a = a\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn (\nnp.sqrt(2 / np.pi)\n* (self._x**2 / self.a**3)\n* np.exp(-self._x**2 / (2 * self.a**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n2 / np.pi,\n) * self._x / self.a * np.exp(-self._x**2 / (2 * self.a**2))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Maxwell-Boltzmann distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=2 * np.sqrt(2 / np.pi) * self.a,\nvariance=(self.a**2 * (3 * np.pi - 8)) / (np.pi),\nmode=np.sqrt(2) * self.a,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Maxwell-Boltzmann distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.__init__","title":"<code>__init__(*x, a, cumulative=False)</code>","text":"<p>Initialize the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nsuper().__init__(*x, cumulative=cumulative)\nself.a = a\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Cumulative distribution function of the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n2 / np.pi,\n) * self._x / self.a * np.exp(-self._x**2 / (2 * self.a**2))\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.discrete_infinite_support.MaxwellBoltzmannDistribution.probability_mass_function","title":"<code>probability_mass_function()</code>","text":"<p>Probability mass function of the Maxwell-Boltzmann distribution.</p> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>def probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn (\nnp.sqrt(2 / np.pi)\n* (self._x**2 / self.a**3)\n* np.exp(-self._x**2 / (2 * self.a**2))\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape","title":"<code>AsymmetricRamanLineshape</code>","text":"<p>             Bases: <code>ContinousAsymmetricPseudo</code></p> <p>Asymmetric Raman lineshape distribution.</p> <p>The Asymmetric Raman lineshape distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for Raman spectroscopy data analysis.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... AsymmetricRamanLineshape\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Asymmetric Raman lineshape distribution is defined as follows for probability density [^1]:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma)) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\) and the damped sigmoidal term \\(p(x)\\):</p> \\[ p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right) \\] <p>[^1] Korepanov, V, I.and Sedlovets, D. M. (2018),     An asymmetric fitting function for condensed-phase Raman spectroscopy,     Analyst RSC, 2674-2679 (143)     dx.doi.org/10.1039/C8AN00710A</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class AsymmetricRamanLineshape(ContinousAsymmetricPseudo):\nr\"\"\"Asymmetric Raman lineshape distribution.\n    The Asymmetric Raman lineshape distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for Raman spectroscopy data analysis.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... AsymmetricRamanLineshape\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n    Notes:\n        The Asymmetric Raman lineshape distribution is defined as follows for\n        probability density [^1]:\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot\n        p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma))\n        $$\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$ and the\n        damped sigmoidal term $p(x)$:\n        $$\n        p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot\n        \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right)\n        $$\n        [^1] Korepanov, V, I.and Sedlovets, D. M. (2018),\n            An asymmetric fitting function for condensed-phase Raman spectroscopy,\n            Analyst RSC, 2674-2679 (143)\n            http://dx.doi.org/10.1039/C8AN00710A\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\np = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n-((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x * p,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Asym. Raman lineshape distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Asym. Raman lineshape distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.AsymmetricRamanLineshape.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Asym. Raman lineshape distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\np = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n-((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x * p,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution","title":"<code>CrystalBallDistribution</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Crystal Ball distribution.</p> <p>The Crystal Ball distribution, which is sometimes also called the Crystal Ball function, is a continuous but asymmetric probability distribution on the real line.[^1] This type of function is often used in physics to model the invariant mass of a particle or system of particles, especially when there is a known background contribution.[^2]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... CrystalBallDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n&gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n&gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Crystal Ball distribution is defined as follows for probability density</p> \\[ f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{ \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }} \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha \\end{cases}} \\] <p>with:</p> \\[ A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right| \\] \\[ N={\\frac  {1}{\\sigma (C+D)}} \\] \\[ C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}} \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf} \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right) \\] <p>See also: www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/ crystalball.html</p> <p>About the Normalization</p> <p>The normalization constant \\(N\\) might be not correct implemented because for the zero-division case \\(n=1\\) the normalization constant \\(N\\) is set to one to achieve a optical match with the reference figures of <sup>1</sup>.</p> <ol> <li> <p>Crystal Ball function. (2020, November 27). In Wikipedia. en.wikipedia.org/wiki/Crystal_Ball_function \u21a9</p> </li> <li> <p>Tomasz Skwarnicki, A study of the radiative CASCADE transitions between _ the Upsilon-Prime and Upsilon resonances_, PHD-Thesis, DESY-F31-86-02, Apr. 1986\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the Gaussian region.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the Gaussian region.</p> <code>1</code> <code>n</code> <code>float</code> <p>The power of the power-law region.</p> <code>1</code> <code>alpha</code> <code>float</code> <p>: The location of the transition between the Gaussian and power-law regions.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class CrystalBallDistribution(ContinuousWSigma):\nr\"\"\"Crystal Ball distribution.\n    The Crystal Ball distribution, which is sometimes also called the Crystal\n    Ball function, is a continuous but asymmetric probability distribution on the real\n    line.[^1] This type of function is often used in physics to model the invariant\n    mass of a particle or system of particles, especially when there is a known\n    background contribution.[^2]\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... CrystalBallDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n        &gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n        &gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Crystal Ball distribution is defined as follows for probability density\n        [^2]:\n        $$\n        f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp\n        \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{\n        \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot\n        \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }}\n        \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha\n        \\end{cases}}\n        $$\n        with:\n        $$\n        A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp\n        \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n        $$\n        B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right|\n        $$\n        $$\n        N={\\frac  {1}{\\sigma (C+D)}}\n        $$\n        $$\n        C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}}\n        \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n        $$\n        D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf}\n        \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right)\n        $$\n        See also: https://www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/\n        crystalball.html\n        !!! warning \"About the Normalization\"\n            The normalization constant $N$ might be not correct implemented because\n            for the zero-division case $n=1$ the normalization constant $N$ is set to\n            one to achieve a optical match with the reference figures of [^2].\n        [^1]: Tomasz Skwarnicki, _A study of the radiative CASCADE transitions between_\n            _ the Upsilon-Prime and Upsilon resonances_, **PHD-Thesis**, DESY-F31-86-02,\n            Apr. 1986\n        [^2]: Crystal Ball function. (2020, November 27). _In Wikipedia._\n            https://en.wikipedia.org/wiki/Crystal_Ball_function\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the Gaussian region.\n        sigma (float): The standard deviation of the Gaussian region.\n        n (float): The power of the power-law region.\n        alpha (float):: The location of the transition between the Gaussian and\n            power-law regions.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nn: float = 1,\nalpha: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Crystal Ball distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nif n &lt;= 0:\nraise NotLargerThanZeroError(number=n)\nif alpha &lt; 0:\nraise NotLargerThanZeroError(number=alpha)\nself.n = n\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n_a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n-(self.alpha**2) / 2,\n)\n_b = self.n / abs(self.alpha) - abs(self.alpha)\nif self.n == 1:\n_n = self.n\nelse:\n_c = (\nself.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n)\n_d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n_n = 1 / (self.sigma * (_c + _d))\nreturn np.where(\n(self._x - self.mu) / self.sigma &gt; -self.alpha,\n_n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n_n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Crystal Ball distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Crystal Ball distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, n=1, alpha=1)</code>","text":"<p>Initialize the Crystal Ball distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nn: float = 1,\nalpha: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Crystal Ball distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nif n &lt;= 0:\nraise NotLargerThanZeroError(number=n)\nif alpha &lt; 0:\nraise NotLargerThanZeroError(number=alpha)\nself.n = n\nself.alpha = alpha\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.CrystalBallDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Crystal Ball distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n_a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n-(self.alpha**2) / 2,\n)\n_b = self.n / abs(self.alpha) - abs(self.alpha)\nif self.n == 1:\n_n = self.n\nelse:\n_c = (\nself.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n)\n_d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n_n = 1 / (self.sigma * (_c + _d))\nreturn np.where(\n(self._x - self.mu) / self.sigma &gt; -self.alpha,\n_n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n_n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution","title":"<code>ModifiedDoniachSunjicDistribution</code>","text":"<p>             Bases: <code>ContinousAsymmetricPseudo</code></p> <p>Doniach-Sunjic distribution.</p> <p>The Doniach-Sunjic distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for XPS/AES data analysis. See also: www.casaxps.com</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... ModifiedDoniachSunjicDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"ModifiedDoniachSunjicDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Warning <p>The Doniach-Sunjic distribution as defined for casaxps is not the same as used in the current implementation. In the current implementation, the damping factor is included into the lorentzian model.</p> Notes <p>The Doniach-Sunjic distribution is defined as follows for probability density:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma)) \\] <p>with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal is defined as:</p> \\[ p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\ 0 &amp; \\text{if } x \\geq \\mu \\end{cases} \\] <p>and the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: www.casaxps.com/help_manual/line_shapes.htm</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class ModifiedDoniachSunjicDistribution(ContinousAsymmetricPseudo):\nr\"\"\"Doniach-Sunjic distribution.\n    The Doniach-Sunjic distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for XPS/AES data analysis. See also:\n    http://www.casaxps.com\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... ModifiedDoniachSunjicDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"ModifiedDoniachSunjicDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Warning:\n        The Doniach-Sunjic distribution as defined for **casaxps** is not the same as\n        used in the current implementation. In the current implementation, the damping\n        factor is included into the lorentzian model.\n    Notes:\n        The Doniach-Sunjic distribution is defined as follows for probability density:\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma))\n        $$\n        with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal\n        is defined as:\n        $$\n        p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot\n        \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\\n        0 &amp; \\text{if } x \\geq \\mu \\end{cases}\n        $$\n        and the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: http://www.casaxps.com/help_manual/line_shapes.htm\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\np = np.where(\nself._x &lt; self.mu,\nnp.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n0,\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Doniach-Sunjic distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Doniach-Sunjic distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.ModifiedDoniachSunjicDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Doniach-Sunjic distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\np = np.where(\nself._x &lt; self.mu,\nnp.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n0,\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution","title":"<code>PearsonVIIDistribution</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Pearson VII distribution.</p> <p>The Pearson VII distribution is a continuous probability distribution on the real line. It is a generalization of the Student's t-distribution and the Cauchy distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PearsonVIIDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n&gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n&gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n&gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n&gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n&gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pearson VII distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)} {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+ \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}} \\] <p><sup>1</sup> Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.     Journal of Applied Crystalography, 31(3), 474-476.     doi.org/10.1107/S0021889897011047</p> <p>See also: en.wikipedia.org/wiki/Pearson_distribution and www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>p</code> <code>float</code> <p>The shape parameter of the distribution.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PearsonVIIDistribution(ContinuousWSigma):\nr\"\"\"Pearson VII distribution.\n    The Pearson VII distribution is a continuous probability distribution on the real\n    line. It is a generalization of the Student's t-distribution and the Cauchy\n    distribution. This function becomes popular for X-ray diffraction data analysis.[^1]\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PearsonVIIDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n        &gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n        &gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n        &gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n        &gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n        &gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Pearson VII distribution is defined as follows for probability density\n        [^1]:\n        $$\n        f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)}\n        {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+\n        \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}}\n        $$\n        [^1] Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.\n            Journal of Applied Crystalography, 31(3), 474-476.\n            https://doi.org/10.1107/S0021889897011047\n        See also: https://en.wikipedia.org/wiki/Pearson_distribution and\n        https://www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution.\n        sigma (float): The standard deviation of the distribution.\n        p (float): The shape parameter of the distribution.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\np: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Pearson VII distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nself.p = p\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Pearson VII distribution.\"\"\"\nreturn (\ngammaln(self.p / 2)\n/ (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n* (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Pearson VII distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Pearson VII distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.__init__","title":"<code>__init__(*x, mu=0, sigma=1, p=1)</code>","text":"<p>Initialize the Pearson VII distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\np: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Pearson VII distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nself.p = p\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PearsonVIIDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Pearson VII distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Pearson VII distribution.\"\"\"\nreturn (\ngammaln(self.p / 2)\n/ (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n* (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution","title":"<code>PseudoVoigtDistribution</code>","text":"<p>             Bases: <code>ContinousPseudo</code></p> <p>Pseudo-Voigt distribution.</p> <p>The Pseudo-Voigt distribution is a continuous probability distribution on the real line. It is a convolution of a Gaussian distribution and a Lorentzian distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PseudoVoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.1).__eval__\n&gt;&gt;&gt; y_2 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.2).__eval__\n&gt;&gt;&gt; y_3 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.3).__eval__\n&gt;&gt;&gt; y_4 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.4).__eval__\n&gt;&gt;&gt; y_5 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.5).__eval__\n&gt;&gt;&gt; y_6 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.6).__eval__\n&gt;&gt;&gt; y_7 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.7).__eval__\n&gt;&gt;&gt; y_8 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.8).__eval__\n&gt;&gt;&gt; y_9 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$f=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$f=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$f=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$f=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$f=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$f=0.6$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_7, label=r\"$f=0.7$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_8, label=r\"$f=0.8$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_9, label=r\"$f=0.9$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PseudoVoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pseudo-Voigt distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,\\eta)=(1 - \\eta) \\cdot \\frac {1}{\\sigma {\\sqrt {2\\pi }}}\\exp \\left(-{\\frac {(x-\\mu )^{2}}{2\\sigma^{2}}} \\right)+\\eta \\cdot {\\frac {1}{\\pi }}\\left( {\\frac {\\sigma }{(\\frac{\\sigma}{2})^{2}+(x-\\mu )^{2}}}\\right) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: en.wikipedia.org/wiki/Voigt_profile</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PseudoVoigtDistribution(ContinousPseudo):\nr\"\"\"Pseudo-Voigt distribution.\n    The Pseudo-Voigt distribution is a continuous probability distribution on the real\n    line. It is a convolution of a Gaussian distribution and a Lorentzian distribution.\n    This function becomes popular for X-ray diffraction data analysis.[^1]\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PseudoVoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.1).__eval__\n        &gt;&gt;&gt; y_2 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.2).__eval__\n        &gt;&gt;&gt; y_3 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.3).__eval__\n        &gt;&gt;&gt; y_4 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.4).__eval__\n        &gt;&gt;&gt; y_5 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.5).__eval__\n        &gt;&gt;&gt; y_6 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.6).__eval__\n        &gt;&gt;&gt; y_7 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.7).__eval__\n        &gt;&gt;&gt; y_8 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.8).__eval__\n        &gt;&gt;&gt; y_9 = PseudoVoigtDistribution(x, mu=0, sigma=1, eta=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$f=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$f=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$f=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$f=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$f=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$f=0.6$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_7, label=r\"$f=0.7$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_8, label=r\"$f=0.8$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_9, label=r\"$f=0.9$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PseudoVoigtDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Pseudo-Voigt distribution is defined as follows for probability density\n        $$\n        f(x;\\mu ,\\sigma ,\\eta)=(1 - \\eta) \\cdot \\frac {1}{\\sigma\n        {\\sqrt {2\\pi }}}\\exp \\left(-{\\frac {(x-\\mu )^{2}}{2\\sigma^{2}}}\n        \\right)+\\eta \\cdot {\\frac {1}{\\pi }}\\left(\n        {\\frac {\\sigma }{(\\frac{\\sigma}{2})^{2}+(x-\\mu )^{2}}}\\right)\n        $$\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: https://en.wikipedia.org/wiki/Voigt_profile\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Pseudo-Voigt distribution.\"\"\"\nreturn (1 - self.eta) * GaussianDistribution(\nself._x,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Pseudo-Voigt distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>property</code>","text":"<p>Summary statistics of the Pseudo-Voigt distribution.</p>"},{"location":"modules/api/distributions/#umf.functions.distributions.mixed_discrete_continuous.PseudoVoigtDistribution.probability_density_function","title":"<code>probability_density_function()</code>","text":"<p>Probability density function of the Pseudo-Voigt distribution.</p> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>def probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Pseudo-Voigt distribution.\"\"\"\nreturn (1 - self.eta) * GaussianDistribution(\nself._x,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/","title":"Modules","text":"<p>API for function classes.</p> <p>Reference class for functions to generate data for benchmarking.</p> <p>Abstract class for plotting functions.</p> <p>About</p> <p>This module defines an abstract class <code>Plot</code> and a named tuple <code>GraphSettings</code> for plotting functions.</p> <ul> <li><code>GraphSettings</code>: A class for named tuples which defines the settings for     the graph, such as size, dpi, axis labels, title, color, colormap, and     alpha value.</li> <li><code>Plot</code>: An abstract class that defines methods for plotting data in 2D, 3D,     contour, surface, and dashboard formats, as well as animating the plot. It also     defines abstract methods for showing and saving the plot.</li> </ul>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.MaximaAPI","title":"<code>MaximaAPI</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Maxima API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class MaximaAPI(BaseModel):\n\"\"\"Maxima API for optimization functions.\"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True)\nf_x: float | UniversalArray = Field(\n...,\ndescription=\"Value of the function at the maximum or maxima.\",\n)\nx: UniversalArrayTuple | UniversalFloatTuple = Field(\n...,\ndescription=\"Input data, where the maximum or maxima is located.\",\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.MinimaAPI","title":"<code>MinimaAPI</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Minima API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class MinimaAPI(BaseModel):\n\"\"\"Minima API for optimization functions.\"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True)\nf_x: float | UniversalArray = Field(\n...,\ndescription=\"Value of the function at the minimum or minima.\",\n)\nx: UniversalArrayTuple | UniversalFloatTuple = Field(\n...,\ndescription=\"Input data, where the minimum or minima is located.\",\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsDistributionAPI","title":"<code>ResultsDistributionAPI</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Results API for distribution functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsDistributionAPI(BaseModel):\n\"\"\"Results API for distribution functions.\"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True)\nx: UniversalArrayTuple = Field(\n...,\ndescription=\"Input data, which can be one, two, three, or higher dimensional.\",\n)\nresult: UniversalArray | MeshArray = Field(\n...,\ndescription=\"Function value as numpy array or numpy mesh grid array.\",\n)\nsummary: SummaryStatisticsAPI = Field(\n...,\ndescription=\"Summary statistics of the data.\",\n)\ndoc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.ResultsFunctionAPI","title":"<code>ResultsFunctionAPI</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Results API for optimization functions.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class ResultsFunctionAPI(BaseModel):\n\"\"\"Results API for optimization functions.\"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True)\nx: UniversalArrayTuple = Field(\n...,\ndescription=\"Input data, which can be one, two, three, or higher dimensional.\",\n)\nresult: UniversalArray | MeshArray = Field(\n...,\ndescription=\"Function value as numpy array or numpy mesh grid array.\",\n)\nminima: MinimaAPI | None = Field(\ndefault=None,\ndescription=\"Tuple of minima as numpy arrays.\",\n)\nmaxima: MaximaAPI | None = Field(\ndefault=None,\ndescription=\"Tuple of maxima as numpy arrays.\",\n)\ndoc: str | None = Field(..., description=\"Function documentation string.\")\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.api.SummaryStatisticsAPI","title":"<code>SummaryStatisticsAPI</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>API for summary statistics.</p> Source code in <code>umf/meta/api.py</code> Python<pre><code>class SummaryStatisticsAPI(BaseModel):\n\"\"\"API for summary statistics.\"\"\"\nmodel_config = ConfigDict(arbitrary_types_allowed=True)\nmean: float | None = Field(\n...,\ndescription=\"Mean value of the data.\",\n)\nvariance: float | None = Field(\n...,\ndescription=\"Variance of the data.\",\n)\nmode: float | UniversalFloatTuple | None = Field(\n...,\ndescription=\"Mode or modes of the data.\",\n)\ndoc: str | None = Field(\n...,\ndescription=\"Documentation string for the summary statistics.\",\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousAsymmetricPseudo","title":"<code>ContinousAsymmetricPseudo</code>","text":"<p>             Bases: <code>ContinousPseudo</code></p> <p>Base class for continuous distributions for asym. pseudo Voigt like functions.</p> Note <p>In terms of pseudo Voigt like functions, the \\(\\gamma\\) parameter is used to provide an asymetric line shape. The \\(\\gamma\\) parameter is defined as the ratio of the Lorentzian contribution to the Gaussian contribution. In case of XPS and XAS, these type of functions are popular to model the line shape of the photoemission and absorption spectra.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>eta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>Asymmetry parameter of the distribution. Defaults to 0.0.</p> <code>0.0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> required <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([0, 1]\\).</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinousAsymmetricPseudo(ContinousPseudo):\nr\"\"\"Base class for continuous distributions for asym. pseudo Voigt like functions.\n    Note:\n        In terms of pseudo Voigt like functions, the $\\gamma$ parameter is used to\n        provide an asymetric line shape. The $\\gamma$ parameter is defined as the ratio\n        of the Lorentzian contribution to the Gaussian contribution. In case of\n        **XPS** and **XAS**, these type of functions are popular to model the line shape\n        of the photoemission and absorption spectra.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        eta (float): Shape parameter of the distribution. Defaults to 0.5.\n        gamma (float): Asymmetry parameter of the distribution. Defaults to 0.0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n        OutOfRangeError: If the input data is not in the interval $[0, 1]$.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\neta: float = 0.5,\ngamma: float = 0.0,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, eta=eta, cumulative=False)\nself.gamma = gamma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousAsymmetricPseudo.__init__","title":"<code>__init__(*x, mu=0, sigma=1, eta=0.5, gamma=0.0)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\neta: float = 0.5,\ngamma: float = 0.0,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, eta=eta, cumulative=False)\nself.gamma = gamma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousPseudo","title":"<code>ContinousPseudo</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Base class for continuous distributions for pseudo Voigt like functions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>eta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([0, 1]\\).</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinousPseudo(ContinuousWSigma):\n\"\"\"Base class for continuous distributions for pseudo Voigt like functions.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        eta (float): Shape parameter of the distribution. Defaults to 0.5.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n        OutOfRangeError: If the input data is not in the interval $[0, 1]$.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\neta: float = 0.5,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nif eta &lt; 0 or eta &gt; 1:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=0,\nend_range=1,\n)\nself.eta = eta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinousPseudo.__init__","title":"<code>__init__(*x, mu=0, sigma=1, eta=0.5, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\neta: float = 0.5,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nif eta &lt; 0 or eta &gt; 1:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=0,\nend_range=1,\n)\nself.eta = eta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.Continuous2PiInterval","title":"<code>Continuous2PiInterval</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with fixed interval of \\(2\\pi\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([-\\pi, \\pi]\\).</p> <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class Continuous2PiInterval(ContinuousDistributionBase):\nr\"\"\"Base class for continuous distributions with fixed interval of $2\\pi$.\n    Args:\n        *x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        OutOfRangeError: If the input data is not in the interval $[-\\pi, \\pi]$.\n        MissingXError: If no input data is specified.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nkappa: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; -np.pi or np.max(x) &gt; np.pi:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=-np.pi,\nend_range=np.pi,\n)\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.kappa = kappa\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.Continuous2PiInterval.__init__","title":"<code>__init__(*x, mu=0, kappa=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nkappa: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; -np.pi or np.max(x) &gt; np.pi:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=-np.pi,\nend_range=np.pi,\n)\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.kappa = kappa\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousBoundedInterval","title":"<code>ContinuousBoundedInterval</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a bounded interval.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>start</code> <code>float</code> <p>Start of the interval. Defaults to 0.</p> <code>0</code> <code>end</code> <code>float</code> <p>End of the interval. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>OutOfRangeError</code> <p>If the input data is not in the interval \\([start, end]\\).</p> <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousBoundedInterval(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with a bounded interval.\n    Args:\n        *x (UniversalArray): Input data, which currently must be one dimensional.\n        start (float): Start of the interval. Defaults to 0.\n        end (float): End of the interval. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        OutOfRangeError: If the input data is not in the interval $[start, end]$.\n        MissingXError: If no input data is specified.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nstart: float = 0,\nend: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; start or np.max(x) &gt; end:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=start,\nend_range=end,\n)\nsuper().__init__(*x, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousBoundedInterval.__init__","title":"<code>__init__(*x, start=0, end=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nstart: float = 0,\nend: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; start or np.max(x) &gt; end:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=start,\nend_range=end,\n)\nsuper().__init__(*x, cumulative=cumulative)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase","title":"<code>ContinuousDistributionBase</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for distributions with a standard deviation and beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousDistributionBase(ABC, metaclass=CoreElements):\n\"\"\"Base class for distributions with a standard deviation and beta parameter.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float ): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=self.__class__.__name__,\ndimension=__1d__,\n)\nself._x = x[0]\nself.mu = mu\nself.cumulative = cumulative\n@property\ndef __input__(self) -&gt; UniversalArrayTuple:\n\"\"\"Return the input data.\"\"\"\nreturn (np.array(self._x),)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the function.\"\"\"\nreturn (\nself.cumulative_distribution_function()\nif self.cumulative\nelse self.probability_density_function()\n)\n@abstractmethod\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\n@property\n@abstractmethod\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nraise NoCumulativeError\ndef __call__(self) -&gt; ResultsDistributionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsDistributionAPI(\nx=self.__input__,\nresult=self.__eval__,\nsummary=self.__summary__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__input__","title":"<code>__input__: UniversalArrayTuple</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsDistributionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsDistributionAPI(\nx=self.__input__,\nresult=self.__eval__,\nsummary=self.__summary__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.__init__","title":"<code>__init__(*x, mu=0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=self.__class__.__name__,\ndimension=__1d__,\n)\nself._x = x[0]\nself.mu = mu\nself.cumulative = cumulative\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nraise NoCumulativeError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousDistributionBase.probability_density_function","title":"<code>probability_density_function()</code>  <code>abstractmethod</code>","text":"<p>Return the probability density function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>@abstractmethod\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousMixed","title":"<code>ContinuousMixed</code>","text":"<p>             Bases: <code>ContinuousWSigma</code></p> <p>Base class for continuous distributions with mixed parameters.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 0.0.</p> <code>0.0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousMixed(ContinuousWSigma):\nr\"\"\"Base class for continuous distributions with mixed parameters.\n    Args:\n        x (UniversalArray): Input data, which can be one, two, three, or higher\n            dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        zeta (float): Shape parameter of the distribution. Defaults to 0.0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nzeta: float = 0.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.zeta = zeta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousMixed.__init__","title":"<code>__init__(*x, mu=0, sigma=1, zeta=0.0, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nzeta: float = 0.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.zeta = zeta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousPure","title":"<code>ContinuousPure</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousPure(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with a standard deviation.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWBeta","title":"<code>ContinuousWBeta</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWBeta(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with beta parameter.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nif beta &lt;= 0:\nraise NotAPositiveNumberError(number=\"beta\")\nself.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWBeta.__init__","title":"<code>__init__(*x, mu=0, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nif beta &lt;= 0:\nraise NotAPositiveNumberError(number=\"beta\")\nself.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWLambda","title":"<code>ContinuousWLambda</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWLambda(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with beta parameter.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nlambda_: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, cumulative=cumulative)\nif lambda_ &lt;= 0:\nraise NotAPositiveNumberError(number=lambda_)\nself.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWLambda.__init__","title":"<code>__init__(*x, lambda_=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nlambda_: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, cumulative=cumulative)\nif lambda_ &lt;= 0:\nraise NotAPositiveNumberError(number=lambda_)\nself.lambda_ = lambda_\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWSigma","title":"<code>ContinuousWSigma</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class ContinuousWSigma(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with a standard deviation.\n    Args:\n        x (UniversalArray): Input data, which can be one, two, three, or higher\n            dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.ContinuousWSigma.__init__","title":"<code>__init__(*x, mu=0, sigma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements","title":"<code>CoreElements</code>","text":"<p>             Bases: <code>ABCMeta</code></p> <p>Metaclass for functions.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class CoreElements(ABCMeta):\n\"\"\"Metaclass for functions.\"\"\"\n@property\n@abstractmethod\ndef __eval__(cls) -&gt; UniversalArray:\n\"\"\"Evaluate the function.\"\"\"\n@property\n@abstractmethod\ndef __input__(cls) -&gt; UniversalArrayTuple:\n\"\"\"Return the input data.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.CoreElements.__input__","title":"<code>__input__: UniversalArrayTuple</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase","title":"<code>DiscreteDistributionBase</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for discrete distributions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscreteDistributionBase(ABC, metaclass=CoreElements):\n\"\"\"Base class for discrete distributions.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=self.__class__.__name__,\ndimension=__1d__,\n)\nself._x = x[0]\nself.cumulative = cumulative\n@property\ndef __input__(self) -&gt; UniversalArrayTuple:\n\"\"\"Return the input data.\"\"\"\nreturn (np.array(self._x),)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the function.\"\"\"\nreturn (\nself.cumulative_distribution_function()\nif self.cumulative\nelse self.probability_mass_function()\n)\n@abstractmethod\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability mass function.\"\"\"\n@property\n@abstractmethod\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nraise NoCumulativeError\ndef __call__(self) -&gt; ResultsDistributionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsDistributionAPI(\nx=self.__input__,\nresult=self.__eval__,\nsummary=self.__summary__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__input__","title":"<code>__input__: UniversalArrayTuple</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__summary__","title":"<code>__summary__: SummaryStatisticsAPI</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the summary statistics.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsDistributionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsDistributionAPI(\nx=self.__input__,\nresult=self.__eval__,\nsummary=self.__summary__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.__init__","title":"<code>__init__(*x, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=self.__class__.__name__,\ndimension=__1d__,\n)\nself._x = x[0]\nself.cumulative = cumulative\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.cumulative_distribution_function","title":"<code>cumulative_distribution_function()</code>","text":"<p>Return the cumulative distribution function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nraise NoCumulativeError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteDistributionBase.probability_mass_function","title":"<code>probability_mass_function()</code>  <code>abstractmethod</code>","text":"<p>Return the probability mass function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>@abstractmethod\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability mass function.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteP","title":"<code>DiscreteP</code>","text":"<p>             Bases: <code>DiscreteDistributionBase</code></p> <p>Base class for discrete distributions with a probability parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Probability parameter of the distribution. Defaults to 0.5.</p> <code>0.5</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscreteP(DiscreteDistributionBase):\n\"\"\"Base class for discrete distributions with a probability parameter.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        p (float): Probability parameter of the distribution. Defaults to 0.5.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\np: float = 0.5,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, cumulative=cumulative)\nif p &lt; 0 or p &gt; 1:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=0,\nend_range=1,\n)\nself.p = p\nself.q = 1 - p\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscreteP.__init__","title":"<code>__init__(*x, p=0.5, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\np: float = 0.5,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, cumulative=cumulative)\nif p &lt; 0 or p &gt; 1:\nraise OutOfRangeError(\nfunction_name=self.__class__.__name__,\nstart_range=0,\nend_range=1,\n)\nself.p = p\nself.q = 1 - p\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.DiscretePure","title":"<code>DiscretePure</code>","text":"<p>             Bases: <code>DiscreteDistributionBase</code></p> <p>Base class for discrete distributions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> required <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class DiscretePure(DiscreteDistributionBase):\n\"\"\"Base class for discrete distributions.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction","title":"<code>OptFunction</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for functions for optimization.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher dimensional.</p> <code>()</code> <code>kwargs</code> <p>Keyword arguments for the function.</p> required <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class OptFunction(ABC, metaclass=CoreElements):\n\"\"\"Base class for functions for optimization.\n    Args:\n        x: Input data, which can be one, two, three, or higher dimensional.\n        kwargs: Keyword arguments for the function.\n    Raises:\n        MissingXError: If no input data is specified.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nself._x: tuple[UniversalArray, ...] = x\nself.dimension: int = len(x)\n@property\ndef __input__(self) -&gt; UniversalArrayTuple:\n\"\"\"Return the input data.\"\"\"\nreturn self._x\n@property\n@abstractmethod\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the function.\"\"\"\n@property\n@abstractmethod\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the zero function.\"\"\"\ndef __call__(self) -&gt; ResultsFunctionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsFunctionAPI(\nx=self.__input__,\nresult=self.__eval__,\nminima=self.__minima__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Evaluate the function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__input__","title":"<code>__input__: UniversalArrayTuple</code>  <code>property</code>","text":"<p>Return the input data.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__call__","title":"<code>__call__()</code>","text":"<p>Return the results of the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __call__(self) -&gt; ResultsFunctionAPI:\n\"\"\"Return the results of the function.\"\"\"\nreturn ResultsFunctionAPI(\nx=self.__input__,\nresult=self.__eval__,\nminima=self.__minima__,\ndoc=self.__doc__,\n)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.OptFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nraise MissingXError\nself._x: tuple[UniversalArray, ...] = x\nself.dimension: int = len(x)\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuous","title":"<code>SemiContinuous</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for semi continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuous(ContinuousDistributionBase):\n\"\"\"Base class for semi continuous distributions with a standard deviation.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWBeta","title":"<code>SemiContinuousWBeta</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with beta parameter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Shape parameter of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuousWBeta(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with beta parameter.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        beta (float): Shape parameter of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif (min_x := np.min(x)) &lt; 0:\nraise NotAPositiveNumberError(number=float(min_x))\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nif beta &lt;= 0:\nraise NotAPositiveNumberError(number=beta)\nself.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWBeta.__init__","title":"<code>__init__(*x, mu=0, beta=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif (min_x := np.min(x)) &lt; 0:\nraise NotAPositiveNumberError(number=float(min_x))\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nif beta &lt;= 0:\nraise NotAPositiveNumberError(number=beta)\nself.beta = beta\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWSigma","title":"<code>SemiContinuousWSigma</code>","text":"<p>             Bases: <code>ContinuousDistributionBase</code></p> <p>Base class for continuous distributions with a standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>Input data, which currently must be one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Mean of the distribution. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the distribution. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>Whether to return the cumulative distribution function. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>MissingXError</code> <p>If no input data is specified.</p> <code>OutOfDimensionError</code> <p>If the input data has more than one dimension.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>class SemiContinuousWSigma(ContinuousDistributionBase):\n\"\"\"Base class for continuous distributions with a standard deviation.\n    Args:\n        x (UniversalArray): Input data, which currently must be one dimensional.\n        mu (float): Mean of the distribution. Defaults to 0.\n        sigma (float): Standard deviation of the distribution. Defaults to 1.\n        cumulative (bool): Whether to return the cumulative distribution function.\n            Defaults to False.\n    Raises:\n        MissingXError: If no input data is specified.\n        OutOfDimensionError: If the input data has more than one dimension.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; 0:\nraise NotAPositiveNumberError(var_number=\"*x\", number=float(np.min(x)))\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.functions.SemiContinuousWSigma.__init__","title":"<code>__init__(*x, mu=0, sigma=1, cumulative=False)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/functions.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif np.min(x) &lt; 0:\nraise NotAPositiveNumberError(var_number=\"*x\", number=float(np.min(x)))\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\nself.sigma = sigma\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.GIFSettings","title":"<code>GIFSettings</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>A named tuple representing the settings for the GIF animation of a 3D plot.</p> <p>Parameters:</p> Name Type Description Default <code>dpi</code> <code>int</code> <p>The resolution of the output GIF in dots per inch. Defaults to 100.</p> required <code>zoom</code> <code>bool</code> <p>Whether or not to include a zoom effect in the animation. Defaults to True.</p> required <code>zoom_start</code> <code>float</code> <p>The starting zoom level for the zoom effect. Defaults to 0.5.</p> required <code>zoom_stop</code> <code>float</code> <p>The ending zoom level for the zoom effect. Defaults to 1.5.</p> required <code>rotate</code> <code>bool</code> <p>Whether or not to include a rotation effect in the animation. Defaults to True.</p> required <code>elev</code> <code>int</code> <p>The elevation angle of the plot in degrees. Defaults to 30.</p> required <code>azim</code> <code>int</code> <p>The azimuth angle of the plot in degrees. Defaults to 5.</p> required <code>frames</code> <code>int</code> <p>The number of frames in the animation. Defaults to 72.</p> required <code>interval</code> <code>int</code> <p>The delay between frames in milliseconds. Defaults to  50.</p> required Source code in <code>umf/meta/plots.py</code> Python<pre><code>class GIFSettings(NamedTuple):\n\"\"\"A named tuple representing the settings for the GIF animation of a 3D plot.\n    Args:\n        dpi (int, optional): The resolution of the output GIF in dots per inch.\n            Defaults to 100.\n        zoom (bool, optional): Whether or not to include a zoom effect in the animation.\n            Defaults to True.\n        zoom_start (float, optional): The starting zoom level for the zoom effect.\n            Defaults to 0.5.\n        zoom_stop (float, optional): The ending zoom level for the zoom effect.\n            Defaults to 1.5.\n        rotate (bool, optional): Whether or not to include a rotation effect in the\n            animation. Defaults to True.\n        elev (int, optional): The elevation angle of the plot in degrees. Defaults to\n            30.\n        azim (int, optional): The azimuth angle of the plot in degrees. Defaults to 5.\n        frames (int, optional): The number of frames in the animation. Defaults to 72.\n        interval (int, optional): The delay between frames in milliseconds. Defaults to\n             50.\n    \"\"\"\ndpi: int = 100\nzoom: bool = True\nzoom_start: float = 0.5\nzoom_stop: float = 1.5\nrotate: bool = True\nelev: int = 30\nazim: int = 5\nframes: int = 72\ninterval: int = 50\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.GraphSettings","title":"<code>GraphSettings</code>","text":"<p>             Bases: <code>NamedTuple</code></p> <p>Settings for the graph.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>The size of the plot. Defaults to (5, 5).</p> <code>dpi</code> <code>int</code> <p>The DPI of the plot. Defaults to 200.</p> <code>axis</code> <code>list[str]</code> <p>The labels for the axes of the plot. Defaults to  None.</p> <code>title</code> <code>str</code> <p>The title of the plot. Defaults to None.</p> <code>color</code> <code>str</code> <p>The color of the plot. Defaults to None.</p> <code>cmap</code> <code>str</code> <p>The colormap of the plot. Defaults to \"YlGnBu_r\".</p> <code>alpha</code> <code>float</code> <p>The alpha value of the plot. Defaults to None.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>class GraphSettings(NamedTuple):\n\"\"\"Settings for the graph.\n    Attributes:\n        size (tuple[int, int]): The size of the plot. Defaults to (5, 5).\n        dpi (int, optional): The DPI of the plot. Defaults to 200.\n        axis (list[str], optional): The labels for the axes of the plot. Defaults to\n             None.\n        title (str, optional): The title of the plot. Defaults to None.\n        color (str, optional): The color of the plot. Defaults to None.\n        cmap (str, optional): The colormap of the plot. Defaults to \"YlGnBu_r\".\n        alpha (float, optional): The alpha value of the plot. Defaults to None.\n    \"\"\"\nsize: tuple[int, int] = (5, 5)\ndpi: int = 200\naxis: list[str] | None = None\ntitle: str | None = None\ncolor: str | None = None\ncmap: str = \"viridis_r\"\nalpha: float | None = None\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot","title":"<code>Plot</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract class for plotting functions.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Source code in <code>umf/meta/plots.py</code> Python<pre><code>class Plot(ABC):\n\"\"\"Abstract class for plotting functions.\n    Args:\n        *x (UniversalArray):  Input data, which can be one, two, three, or higher\n             dimensional.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the plot\n             function.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nsettings: GraphSettings = None,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nmsg = \"x has to be specified.\"\nraise ValueError(msg)\nif settings is None:\nsettings = GraphSettings()\nself._x = x\nself.dimension = len(x)\nself.title = settings.title\nself.axis = (\nsettings.axis\nif settings.axis is not None\nelse [f\"x_{i}\" for i in range(self.dimension)]\n)\nself.color = settings.color\nself.cmap = settings.cmap\nself.alpha = settings.alpha\nself.size = settings.size\nself.dpi = settings.dpi\nself._kwargs = kwargs\ndef plot_2d(self) -&gt; None:\n\"\"\"Plot the data in 2D.\"\"\"\nraise NotImplementedError\ndef plot_series(self) -&gt; None:\n\"\"\"Plot the data in 2D as a series.\"\"\"\nraise NotImplementedError\ndef plot_3d(self) -&gt; None:\n\"\"\"Plot the data in 3D.\"\"\"\nraise NotImplementedError\ndef plot_contour(self) -&gt; None:\n\"\"\"Plot the data as a contour plot.\"\"\"\nraise NotImplementedError\ndef plot_surface(self) -&gt; None:\n\"\"\"Plot the data as a surface plot.\"\"\"\nraise NotImplementedError\ndef plot_dashboard(self) -&gt; None:\n\"\"\"Plot the data as a dashboard.\"\"\"\nraise NotImplementedError\ndef animate(self) -&gt; None:\n\"\"\"Animate the plot.\"\"\"\nraise NotImplementedError\n@abstractmethod\ndef plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\n@property\n@abstractmethod\ndef plot_return(self) -&gt; plt.figure | go.Figure:\n\"\"\"Return the plot.\"\"\"\n@staticmethod\ndef ax_return() -&gt; plt.Figure:\n\"\"\"Return the Figure.\"\"\"\nraise NotImplementedError\n@staticmethod\n@abstractmethod\ndef plot_save(\nfig: plt.Figure | go.Figure,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n        Args:\n            fig (plt.Figure | go.Figure): The figure to save as an image file.\n            fname (Path): The file path to save the plot to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n                 function.\n        \"\"\"\n@staticmethod\ndef plot_save_gif(\nfig: plt.Figure,\nax_fig: plt.Figure,\nfname: Path,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n        Notes:\n            This function can currently only be implemented for matplotlib plots and\n            not for plotly plots.\n        Args:\n            fig (plt.figure): The figure to save as an image file.\n            ax_fig (plt.Figure): The figure to save as an image file.\n            fname (Path): The file path to save the plot to.\n            settings (GIFSettings): The settings for the GIF animation.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n                 function.\n        Raises:\n            NotImplementedError: This function is not yet implemented.\n        \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_return","title":"<code>plot_return: plt.figure | go.Figure</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.__init__","title":"<code>__init__(*x, settings=None, **kwargs)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nsettings: GraphSettings = None,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif x is None:\nmsg = \"x has to be specified.\"\nraise ValueError(msg)\nif settings is None:\nsettings = GraphSettings()\nself._x = x\nself.dimension = len(x)\nself.title = settings.title\nself.axis = (\nsettings.axis\nif settings.axis is not None\nelse [f\"x_{i}\" for i in range(self.dimension)]\n)\nself.color = settings.color\nself.cmap = settings.cmap\nself.alpha = settings.alpha\nself.size = settings.size\nself.dpi = settings.dpi\nself._kwargs = kwargs\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.animate","title":"<code>animate()</code>","text":"<p>Animate the plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def animate(self) -&gt; None:\n\"\"\"Animate the plot.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.ax_return","title":"<code>ax_return()</code>  <code>staticmethod</code>","text":"<p>Return the Figure.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\ndef ax_return() -&gt; plt.Figure:\n\"\"\"Return the Figure.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_2d","title":"<code>plot_2d()</code>","text":"<p>Plot the data in 2D.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_2d(self) -&gt; None:\n\"\"\"Plot the data in 2D.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_3d","title":"<code>plot_3d()</code>","text":"<p>Plot the data in 3D.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_3d(self) -&gt; None:\n\"\"\"Plot the data in 3D.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_contour","title":"<code>plot_contour()</code>","text":"<p>Plot the data as a contour plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_contour(self) -&gt; None:\n\"\"\"Plot the data as a contour plot.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_dashboard","title":"<code>plot_dashboard()</code>","text":"<p>Plot the data as a dashboard.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_dashboard(self) -&gt; None:\n\"\"\"Plot the data as a dashboard.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', **kwargs)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure | Figure</code> <p>The figure to save as an image file.</p> required <code>fname</code> <code>Path</code> <p>The file path to save the plot to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the save  function.</p> <code>{}</code> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\n@abstractmethod\ndef plot_save(\nfig: plt.Figure | go.Figure,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n    Args:\n        fig (plt.Figure | go.Figure): The figure to save as an image file.\n        fname (Path): The file path to save the plot to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n             function.\n    \"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_save_gif","title":"<code>plot_save_gif(fig, ax_fig, fname, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> Notes <p>This function can currently only be implemented for matplotlib plots and not for plotly plots.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save as an image file.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save as an image file.</p> required <code>fname</code> <code>Path</code> <p>The file path to save the plot to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF animation.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the save  function.</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This function is not yet implemented.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@staticmethod\ndef plot_save_gif(\nfig: plt.Figure,\nax_fig: plt.Figure,\nfname: Path,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n    Notes:\n        This function can currently only be implemented for matplotlib plots and\n        not for plotly plots.\n    Args:\n        fig (plt.figure): The figure to save as an image file.\n        ax_fig (plt.Figure): The figure to save as an image file.\n        fname (Path): The file path to save the plot to.\n        settings (GIFSettings): The settings for the GIF animation.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the save\n             function.\n    Raises:\n        NotImplementedError: This function is not yet implemented.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_series","title":"<code>plot_series()</code>","text":"<p>Plot the data in 2D as a series.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_series(self) -&gt; None:\n\"\"\"Plot the data in 2D as a series.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_show","title":"<code>plot_show()</code>  <code>abstractmethod</code>","text":"<p>Show the plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>@abstractmethod\ndef plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\n</code></pre>"},{"location":"modules/api/meta_models_and_patterns/#umf.meta.plots.Plot.plot_surface","title":"<code>plot_surface()</code>","text":"<p>Plot the data as a surface plot.</p> Source code in <code>umf/meta/plots.py</code> Python<pre><code>def plot_surface(self) -&gt; None:\n\"\"\"Plot the data as a surface plot.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"modules/api/optimization/","title":"Modules","text":"<p>Bowl shaped functions for the useful-math-functions library.</p> <p>Drop steps functions for the useful-math-functions library.</p> <p>Many local minima functions for the useful-math-functions library.</p> <p>Plate shaped functions for the useful-math-functions library.</p> <p>Special optimization functions for the useful-math-functions library.</p> <p>Valley shaped functions for the useful-math-functions library.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1","title":"<code>BohachevskyFunctionType1</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Bohachevsky function type 1.</p> <p>The Bohachevsky function type 1 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 1 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType1(OptFunction):\nr\"\"\"Bohachevsky function type 1.\n    The Bohachevsky function type 1 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 1 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType1\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 1 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1)\n- 0.4 * np.cos(4 * np.pi * x_2)\n+ 0.7\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 1.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 1.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 1 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 1.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 1.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType1.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType1\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2","title":"<code>BohachevskyFunctionType2</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Bohachevsky function tye 2.</p> <p>The Bohachevsky function type 2 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 2 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType2(OptFunction):\nr\"\"\"Bohachevsky function tye 2.\n    The Bohachevsky function type 2 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 2 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 2 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1) * np.cos(4 * np.pi * x_2)\n+ 0.3\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 2.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 2.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 2 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 2.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 2.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType2.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3","title":"<code>BohachevskyFunctionType3</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Bohachevsky function type 3.</p> <p>The Bohachevsky function type 3 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 3 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType3(OptFunction):\nr\"\"\"Bohachevsky function type 3.\n    The Bohachevsky function type 3 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 3 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType3\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 3 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1 + 4 * np.pi * x_2)\n+ 0.3\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 3.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 3.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Bohachevsky function type 3 at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Bohachevsky function type 3.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Bohachevsky function type 3.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.BohachevskyFunctionType3.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType3\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction","title":"<code>PermBetaDFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Perm Beta D function.</p> <p>The Perm Beta D function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm Beta D function is defined as:</p> \\[     f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +     \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 0.5\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermBetaDFunction(OptFunction):\nr\"\"\"Perm Beta D function.\n    The Perm Beta D function is a D-dimensional function with multimodal structure\n    and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Perm Beta D function is defined as:\n        $$\n            f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +\n            \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n        with constant $\\beta = 0.5$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Perm Beta D function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nbeta = 0.5\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = sum(\n(j**i + beta) * ((self._x[j - 1] / j) ** i - 1)\nfor j in range(1, self.dimension + 1)\n)\nouter_sum += inner_sum**2\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Perm Beta D function.\n        Returns:\n            MinimaAPI: Minima of the Perm Beta D function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Perm Beta D function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermBetaDFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Perm Beta D function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Perm Beta D function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction","title":"<code>PermFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Perm function.</p> <p>The Perm function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D j^{i+1} (j + \\beta)       \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 10\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>The beta parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermFunction(OptFunction):\nr\"\"\"Perm function.\n    The Perm function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Perm function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D j^{i+1} (j + \\beta)\n              \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n        with constant $\\beta = 10$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        beta (float, optional): The beta parameter. Defaults to 10.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, beta: float = 10) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself.beta = beta\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Perm function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = sum(\nj ** (i + 1) * (j + self.beta) * ((self._x[j - 1] / j) ** i - 1)\nfor j in range(1, self.dimension + 1)\n)\nouter_sum += inner_sum**2\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Perm function.\n        Returns:\n            MinimaAPI: Minima of the Perm function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Perm function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Perm function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Perm function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.PermFunction.__init__","title":"<code>__init__(*x, beta=10)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, beta: float = 10) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself.beta = beta\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction","title":"<code>RotatedHyperEllipseFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Rotated hyper-ellipse function.</p> <p>The Rotated hyper-ellipse function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... RotatedHyperEllipseFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rotated hyper-ellipse function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2 \\] <p>with \\(D\\) the dimension of the input and \\(a_{ij}\\) the rotation matrix. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class RotatedHyperEllipseFunction(OptFunction):\nr\"\"\"Rotated hyper-ellipse function.\n    The Rotated hyper-ellipse function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... RotatedHyperEllipseFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rotated hyper-ellipse function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2\n        $$\n        with $D$ the dimension of the input and $a_{ij}$ the rotation matrix. The\n        hypercube of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/rothyp.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"RotatedHyperEllipse\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rotated hyper-ellipse function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(self.dimension):\ninner_sum = np.zeros(self._x[0].shape)\nfor j in range(i + 1):\ninner_sum += self._x[j] ** 2\nouter_sum = outer_sum + inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Rotated hyper-ellipse function.\n        Returns:\n            MinimaAPI: Minima of the Rotated hyper-ellipse function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Rotated hyper-ellipse function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Rotated hyper-ellipse function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Rotated hyper-ellipse function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.RotatedHyperEllipseFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"RotatedHyperEllipse\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction","title":"<code>SphereFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Sphere function.</p> <p>The Sphere function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sphere function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SphereFunction(OptFunction):\nr\"\"\"Sphere function.\n    The Sphere function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n        &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sphere function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D x_i^2\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/spheref.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sphere function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn np.sum(np.power(self._x, 2), axis=0)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sphere function.\n        Returns:\n            MinimaAPI: Minima of the Sphere function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Sphere function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SphereFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Sphere function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sphere function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction","title":"<code>SumOfDifferentPowersFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Sum of different powers function.</p> <p>The Sum of different powers function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... SumOfDifferentPowersFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum of different powers function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>_Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumOfDifferentPowersFunction(OptFunction):\nr\"\"\"Sum of different powers function.\n    The Sum of different powers function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... SumOfDifferentPowersFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sum of different powers function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1}\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        _Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sum of different powers function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = abs(self._x[i - 1]) ** (i + 1)\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sum of different powers function.\n        Returns:\n            MinimaAPI: Minima of the Sum of different powers function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Sum of different powers function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumOfDifferentPowersFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Sum of different powers function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sum of different powers function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction","title":"<code>SumSquaresFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Sum squares function.</p> <p>The Sum squares function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum squares function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D i x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumSquaresFunction(OptFunction):\nr\"\"\"Sum squares function.\n    The Sum squares function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sum squares function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D i x_i^2\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumsqu.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sum squares function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = i * self._x[i - 1] ** 2\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sum squares function.\n        Returns:\n            MinimaAPI: Minima of the Sum squares function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Sum squares function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Sum squares function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Sum squares function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.SumSquaresFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction","title":"<code>TridFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Trid function.</p> <p>The Trid function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Trid function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class TridFunction(OptFunction):\nr\"\"\"Trid function.\n    The Trid function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Trid function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1}\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/trid.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Trid function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = (self._x[i - 1] - 1) ** 2 - self._x[i - 1] * self._x[i - 2]\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Trid function.\n        Returns:\n            MinimaAPI: Minima of the Trid function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-self.dimension * (self.dimension + 4) * (self.dimension - 1) / 6,\nx=tuple(i * (self.dimension + 1 - i) for i in range(1, self.dimension + 1)),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Trid function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.TridFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Trid function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Trid function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction","title":"<code>ZirilliFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Zirilli function.</p> <p>The Zirilli function is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zirilli function is defined as:</p> \\[     f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2 \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class ZirilliFunction(OptFunction):\nr\"\"\"Zirilli function.\n    The Zirilli function is a 2D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zirilli function is defined as:\n        $$\n            f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2\n        $$\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Zirilli\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Zirilli function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 0.25 * x_1**4 - 0.5 * x_1**2 + 0.1 * x_1 + 0.5 * x_2**2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zirilli function.\n        Returns:\n            MinimaAPI: Minima of the Zirilli function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-0.352386073800034,\nx=(-1.046680576580755, 0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Zirilli function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Zirilli function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Zirilli function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.bowl_shaped.ZirilliFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Zirilli\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function","title":"<code>DeJongN5Function</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>De Jong N.5 Function.</p> <p>The De Jong N.5 function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n&gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The De Jong N.5 function is defined as:</p> \\[     f(x, y) = \\left(         0.0002 + \\sum_{i=1}^{25}         \\frac{1}{             i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6         }     \\right)^{-1} \\] <p>where</p> \\[     a = \\left(         \\begin{matrix}         -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\         -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32         \\end{matrix}         \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  adddimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Elements of the matrix a, which has to become are 2-dimensional with shape (2, 25). Defaults to None.</p> <code>None</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class DeJongN5Function(OptFunction):\nr\"\"\"De Jong N.5 Function.\n    The De Jong N.5 function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n        &gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n    Notes:\n        The De Jong N.5 function is defined as:\n        $$\n            f(x, y) = \\left(\n                0.0002 + \\sum_{i=1}^{25}\n                \\frac{1}{\n                    i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6\n                }\n            \\right)^{-1}\n        $$\n        where\n        $$\n            a = \\left(\n                \\begin{matrix}\n                -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\\n                -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32\n                \\end{matrix}\n                \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/dejong5.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             adddimensional.\n        A (UniversalArray, optional): Elements of the matrix a, which has to become are\n            2-dimensional with shape (2, 25). Defaults to None.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray | None = None,  # noqa: N803\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"De Jong N.5\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\nif A is None:\nrow_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\nrow_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\nself.a_matrix = np.vstack((row_1, row_2))\nelif A.shape != (2, 25):\nmsg = \"The shape of a has to be (2, 25).\"\nraise ValueError(msg)\nelse:\nself.a_matrix = A\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the De Jong N.5 function.\n        Returns:\n            UniversalArray: The value of the De Jong N.5 function.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\na_1 = self.a_matrix[0, :]\na_2 = self.a_matrix[1, :]\nsum_ = np.zeros_like(x_1)\nfor i in range(25):\nsum_ += 1 / ((i + 1) + (x_1 - a_1[i]) ** 6 + (x_2 - a_2[i]) ** 6)\nreturn (0.0002 + sum_) ** -1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the De Jong N.5 function.\n        Returns:\n            MinimaAPI: The minima of the De Jong N.5 function.\n        \"\"\"\nreturn MinimaAPI(f_x=0.0, x=(0.0, 0.0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the De Jong N.5 function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the De Jong N.5 function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the De Jong N.5 function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the De Jong N.5 function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.DeJongN5Function.__init__","title":"<code>__init__(*x, A=None)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray | None = None,  # noqa: N803\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"De Jong N.5\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\nif A is None:\nrow_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\nrow_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\nself.a_matrix = np.vstack((row_1, row_2))\nelif A.shape != (2, 25):\nmsg = \"The shape of a has to be (2, 25).\"\nraise ValueError(msg)\nelse:\nself.a_matrix = A\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction","title":"<code>EasomFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Easom Function.</p> <p>The Easom function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Easom function is defined as:</p> \\[     f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2     - \\left(y-\\pi\\right)^2\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class EasomFunction(OptFunction):\nr\"\"\"Easom Function.\n    The Easom function is a two-dimensional function with a single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Easom function is defined as:\n        $$\n            f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2\n            - \\left(y-\\pi\\right)^2\\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/easom.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Easom\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Easom function.\n        Returns:\n            UniversalArray: The value of the Easom function.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.array(\n-np.cos(x_1)\n* np.cos(x_2)\n* np.exp(-((x_1 - np.pi) ** 2) - (x_2 - np.pi) ** 2),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Easom function.\n        Returns:\n            MinimaAPI: The minima of the Easom function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-1.0,\nx=np.array([np.pi, np.pi]),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the Easom function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the Easom function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Easom function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the Easom function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.EasomFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Easom\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction","title":"<code>MichalewiczFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Michalewicz Function.</p> <p>The Michalewicz function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Michalewicz function is defined as:</p> \\[     f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>m</code> <code>int</code> <p>The m parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class MichalewiczFunction(OptFunction):\nr\"\"\"Michalewicz Function.\n    The Michalewicz function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n        &gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Michalewicz function is defined as:\n        $$\n            f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/michal.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        m (int, optional): The m parameter. Defaults to 10.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself.m = m\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Michalewicz function.\n        Returns:\n            UniversalArray: The value of the Michalewicz function.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor i, x_i in enumerate(self._x, start=1):\nsum_ += np.sin(x_i) * np.sin((i * x_i**2) / np.pi) ** (2 * self.m)\nreturn -sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Michalewicz function.\n         The minima of the Michalewicz function is not unique and depends on the\n            m parameter and dimensionality of the function.\n        Returns:\n            MinimaAPI: The minima of the Michalewicz function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-1.8013,\nx=(2.20, 1.57),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the Michalewicz function.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The value of the Michalewicz function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Michalewicz function.</p> <p>The minima of the Michalewicz function is not unique and depends on the     m parameter and dimensionality of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>The minima of the Michalewicz function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.drops_steps.MichalewiczFunction.__init__","title":"<code>__init__(*x, m=10)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>def __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself.m = m\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction","title":"<code>AckleyFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Ackley function.</p> <p>The Ackley function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Ackley function is defined as:</p> \\[     f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}       \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)       \\right) + e + \\alpha \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>alpha</code> <code>float</code> <p>Scaling factor. Default is 20.0.</p> <code>20.0</code> <code>beta</code> <code>float</code> <p>Scaling factor. Default is 0.2.</p> <code>0.2</code> <code>gamma</code> <code>float</code> <p>Scaling factor. Default is 2.0 * np.pi.</p> <code>2.0 * pi</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class AckleyFunction(OptFunction):\nr\"\"\"Ackley function.\n    The Ackley function is a multi-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Ackley function is defined as:\n        $$\n            f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}\n              \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)\n              \\right) + e + \\alpha\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/ackley.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        alpha (float): Scaling factor. Default is 20.0.\n        beta (float): Scaling factor. Default is 0.2.\n        gamma (float): Scaling factor. Default is 2.0 * np.pi.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nalpha: float = 20.0,\nbeta: float = 0.2,\ngamma: float = 2.0 * np.pi,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself._alpha = alpha\nself._beta = beta\nself._gamma = gamma\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Ackley function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_1 = np.zeros_like(self._x[0])\nsum_2 = np.zeros_like(self._x[0])\nfor _i, _x in enumerate(self._x, start=1):\n# Calculate sum of squares of x values\nsum_1 += _x**2\n# Calculate sum of cosines of x values\nsum_2 += np.cos(self._gamma * _x)\n# Calculate exponential terms\nterms_1 = -self._alpha * np.exp(-self._beta * np.sqrt(1 / _i * sum_1))\nterms_2 = -np.exp(1 / _i * sum_2)\n# Calculate Ackley function value\nterms_3 = np.e + self._alpha\nreturn terms_1 + terms_2 + terms_3\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Ackley function.\"\"\"\nreturn MinimaAPI(f_x=0.0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Ackley function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Ackley function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.AckleyFunction.__init__","title":"<code>__init__(*x, alpha=20.0, beta=0.2, gamma=2.0 * np.pi)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nalpha: float = 20.0,\nbeta: float = 0.2,\ngamma: float = 2.0 * np.pi,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself._alpha = alpha\nself._beta = beta\nself._gamma = gamma\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function","title":"<code>BukinN6Function</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Bukin function number 6.</p> <p>The Bukin function number 6 is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n&gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bukin function number 6 is defined as:</p> \\[     f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +     0.01 \\left| x + 10 \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class BukinN6Function(OptFunction):\nr\"\"\"Bukin function number 6.\n    The Bukin function number 6 is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n        &gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Bukin function number 6 is defined as:\n        $$\n            f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +\n            0.01 \\left| x + 10 \\right|\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/bukin6.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Bukin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bukin function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = 100 * np.sqrt(np.abs(x_2 - 0.01 * x_1**2))\nterm_2 = 0.01 * np.abs(x_1 + 10)\nreturn term_1 + term_2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(-10.0, 1.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Bukin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.BukinN6Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Bukin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction","title":"<code>CrossInTrayFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Cross-in-tray function.</p> <p>The Cross-in-tray function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cross-in-tray function is defined as:</p> \\[     f(x) = -0.0001 \\left| \\sin(x_1) \\sin(x_2) \\exp \\left| 100     - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right| + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class CrossInTrayFunction(OptFunction):\nr\"\"\"Cross-in-tray function.\n    The Cross-in-tray function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Cross-in-tray function is defined as:\n        $$\n            f(x) = -0.0001 \\left| \\sin(x_1) \\sin(x_2) \\exp \\left| 100\n            - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right| + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/crossit.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Cross-in-tray\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Cross-in-tray function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(x_1) * np.sin(x_2)\nterm_2 = np.exp(np.abs(100 - np.sqrt(x_1**2 + x_2**2) / np.pi))\nreturn -0.0001 * np.abs(term_1 * term_2 + 1) ** 0.1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-2.06261,\nx=tuple(\nnp.array([1.34941, 1.34941]),\nnp.array([-1.34941, -1.34941]),\nnp.array([1.34941, -1.34941]),\nnp.array([-1.34941, 1.34941]),\n),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Cross-in-tray function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.CrossInTrayFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Cross-in-tray\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction","title":"<code>DropWaveFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Drop-wave function.</p> <p>The Drop-wave function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Drop-wave function is defined as:</p> \\[     f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)     / (0.5(x_1^2 + x_2^2) + 2) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class DropWaveFunction(OptFunction):\nr\"\"\"Drop-wave function.\n    The Drop-wave function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Drop-wave function is defined as:\n        $$\n            f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)\n            / (0.5(x_1^2 + x_2^2) + 2)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/drop.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Drop-wave\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Drop-wave function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = 12 * np.sqrt(x_1**2 + x_2**2)\nterm_2 = 0.5 * (x_1**2 + x_2**2) + 2\nreturn -((1 + np.cos(term_1)) / term_2)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=-1.0, x=tuple(0.0, 0.0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Drop-wave function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.DropWaveFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Drop-wave\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction","title":"<code>EggHolderFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Egg-holder function.</p> <p>The Egg-holder function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n&gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Egg-holder function is defined as:</p> \\[     f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}     + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1     - (x_2 + 47) \\right|} \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class EggHolderFunction(OptFunction):\nr\"\"\"Egg-holder function.\n    The Egg-holder function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n        &gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Egg-holder function is defined as:\n        $$\n            f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}\n            + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1\n            - (x_2 + 47) \\right|} \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/egg.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Egg-holder\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Egg-holder function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sqrt(np.abs(x_2 + 47 + x_1 / 2))\nterm_2 = np.sqrt(np.abs(x_1 - (x_2 + 47)))\nreturn -(x_2 + 47) * np.sin(term_1) - x_1 * np.sin(term_2)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=-959.6407, x=tuple(512, 404.2319))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Egg-holder function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.EggHolderFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Egg-holder\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction","title":"<code>GramacyLeeFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Gramacy and Lee function.</p> <p>The Gramacy and Lee function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GramacyLeeFunction\n&gt;&gt;&gt; x = np.linspace(-1, 2.5, 1000)\n&gt;&gt;&gt; y = GramacyLeeFunction(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot(x, y)\n&gt;&gt;&gt; plt.savefig(\"GramacyLeeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gramacy and Lee function is defined as:</p> \\[     f(x) = \\sin(10 \\pi x_1) / (2 x_1) + (x_1 - 1)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be one dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GramacyLeeFunction(OptFunction):\nr\"\"\"Gramacy and Lee function.\n    The Gramacy and Lee function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GramacyLeeFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 2.5, 1000)\n        &gt;&gt;&gt; y = GramacyLeeFunction(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot(x, y)\n        &gt;&gt;&gt; plt.savefig(\"GramacyLeeFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Gramacy and Lee function is defined as:\n        $$\n            f(x) = \\sin(10 \\pi x_1) / (2 x_1) + (x_1 - 1)^4\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/gramacy.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be one dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=\"Gramacy and Lee\",\ndimension=__1d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Gramacy and Lee function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nterm_1 = np.sin(10 * np.pi * x_1) / (2 * x_1)\nterm_2 = (x_1 - 1) ** 4\nreturn term_1 + term_2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=None, x=None)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Gramacy and Lee function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GramacyLeeFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __1d__:\nraise OutOfDimensionError(\nfunction_name=\"Gramacy and Lee\",\ndimension=__1d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction","title":"<code>GriewankFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Griewank function.</p> <p>The Griewank function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Griewank function is defined as:</p> \\[     f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos     \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GriewankFunction(OptFunction):\nr\"\"\"Griewank function.\n    The Griewank function is a multi-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Griewank function is defined as:\n        $$\n            f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos\n            \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/griewank.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Griewank function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor i, x_i in enumerate(self._x, start=1):\nsum_ += 1 / 4000 * x_i**2\nif i == 1:\nprod_ = np.cos(x_i / np.sqrt(i))\nprod_ *= np.cos(x_i / np.sqrt(i))\nreturn sum_ - prod_ + 1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Griewank function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.GriewankFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction","title":"<code>HolderTableFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Holder table function.</p> <p>The Holder table function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Holder table function is defined as:</p> \\[     f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /     \\pi \\right| \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class HolderTableFunction(OptFunction):\nr\"\"\"Holder table function.\n    The Holder table function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Holder table function is defined as:\n        $$\n            f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /\n            \\pi \\right| \\right|\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/holder.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Holder table\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Holder table function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(x_1) * np.cos(x_2)\nterm_2 = np.abs(1 - np.sqrt(x_1**2 + x_2**2) / np.pi)\nterm_3 = np.exp(term_2)\nreturn -np.abs(term_1 * term_3)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-19.2085,\nx=tuple(\nnp.array([8.05502, 9.66459]),\nnp.array([8.05502, -9.66459]),\nnp.array([-8.05502, 9.66459]),\nnp.array([-8.05502, -9.66459]),\n),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Holder table function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.HolderTableFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Holder table\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction","title":"<code>LangermannFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Langermann function.</p> <p>The Langermann function is a multi-dimensional function with many unevenly distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Langermann function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}     (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi     \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right) \\] <p>with the constants :math:<code>c_i</code> and the :math:<code>a_{ij}</code> given by:</p> \\[     c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =     \\left\\{ 3, 5, 2, 1, 7 \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Matrix of constants :math:<code>a_{ij}</code>. The numbers of rows has to be equal to the number of input data, respectively, dimensions. Defaults to :math:<code>a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}</code>.</p> <code>None</code> <code>c</code> <code>UniversalArray</code> <p>Vector of constants :math:<code>c_i</code>. Defaults to :math:<code>c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}</code>.</p> <code>None</code> <code>m</code> <code>int</code> <p>Number of local minima. Defaults to 5.</p> <code>5</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LangermannFunction(OptFunction):\nr\"\"\"Langermann function.\n    The Langermann function is a multi-dimensional function with many unevenly\n    distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n    Notes:\n        The Langermann function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}\n            (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi\n            \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right)\n        $$\n        with the constants :math:`c_i` and the :math:`a_{ij}` given by:\n        $$\n            c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =\n            \\left\\{ 3, 5, 2, 1, 7 \\right\\}\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/langer.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        A (UniversalArray, optional): Matrix of constants :math:`a_{ij}`. The numbers\n            of rows has to be equal to the number of input data, respectively,\n            dimensions. Defaults to :math:`a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}`.\n        c (UniversalArray, optional): Vector of constants :math:`c_i`. Defaults to\n            :math:`c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}`.\n        m (int, optional): Number of local minima. Defaults to 5.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray = None,  # noqa: N803\nc: UniversalArray = None,\nm: int = 5,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nif A is None:\nA = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\nif c is None:\nc = np.array([1, 2, 5, 2, 3], dtype=float)\nif len(x) != A.shape[0]:\nmsg = \"Dimension of x must match number of rows in A.\"\nraise ValueError(msg)\nif len(A.shape) != __2d__:\nmsg = (\n\"A must be two dimensional array. In case of one input the  \"\n\"array must lool like 'np.array([[...]])'. \"\n)\nraise ValueError(\nmsg,\n)\nif A.shape[1] != m:\nraise MatchLengthError(_object=\"A\", _target=\"m\")\nif len(c) != m:\nraise MatchLengthError(_object=\"C\", _target=\"m\")\nif len(c.shape) != __1d__:\nmsg = \"c must be one dimensional array.\"\nraise ValueError(msg)\nself.a_matrix = A\nself._c = c\nself._m = m\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Langermann function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nouter_sum = np.zeros_like(self._x[0])\nfor i in range(self._m):\ninner_sum = np.zeros_like(self._x[0])\nfor j, _x in enumerate(self._x):\ninner_sum += (_x - self.a_matrix[j, i]) ** 2\nouter_sum += (\nself._c[i] * np.exp(-inner_sum / np.pi) * np.cos(np.pi * inner_sum)\n)\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(\nnp.array([self.a_matrix[0, i], self.a_matrix[1, i]])\nfor i in range(self._m)\n),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Langermann function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LangermannFunction.__init__","title":"<code>__init__(*x, A=None, c=None, m=5)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray = None,  # noqa: N803\nc: UniversalArray = None,\nm: int = 5,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nif A is None:\nA = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\nif c is None:\nc = np.array([1, 2, 5, 2, 3], dtype=float)\nif len(x) != A.shape[0]:\nmsg = \"Dimension of x must match number of rows in A.\"\nraise ValueError(msg)\nif len(A.shape) != __2d__:\nmsg = (\n\"A must be two dimensional array. In case of one input the  \"\n\"array must lool like 'np.array([[...]])'. \"\n)\nraise ValueError(\nmsg,\n)\nif A.shape[1] != m:\nraise MatchLengthError(_object=\"A\", _target=\"m\")\nif len(c) != m:\nraise MatchLengthError(_object=\"C\", _target=\"m\")\nif len(c.shape) != __1d__:\nmsg = \"c must be one dimensional array.\"\nraise ValueError(msg)\nself.a_matrix = A\nself._c = c\nself._m = m\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction","title":"<code>LevyFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Levy function.</p> <p>The Levy function is a multi-dimensional function with many local and harmonic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy function is defined as:</p> \\[     f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[     1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]     + \\left( w_d - 1 \\right)^2 \\left[     1 + \\sin^2( 2 \\pi w_d ) \\right] \\] <p>with the :math:<code>w_i</code> given by:</p> \\[     w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in     \\left\\{ 1, \\dots, d \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyFunction(OptFunction):\nr\"\"\"Levy function.\n    The Levy function is a multi-dimensional function with many local and harmonic\n    distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Levy function is defined as:\n        $$\n            f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[\n            1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]\n            + \\left( w_d - 1 \\right)^2 \\left[\n            1 + \\sin^2( 2 \\pi w_d ) \\right]\n        $$\n        with the :math:`w_i` given by:\n        $$\n            w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in\n            \\left\\{ 1, \\dots, d \\right\\}\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Levy function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nterm_1 = np.sin(np.pi * (1 + (1 / 4) * (self._x[0] - 1))) ** 2\nif len(self._x) == 1:\nreturn term_1\nfor i in range(1, len(self._x) - 1):\nterm_2 = (1 + (1 / 4) * (self._x[i] - 1)) ** 2\nterm_3 = 1 + 10 * np.sin(np.pi * (1 + (1 / 4) * (self._x[i] - 1)) + 1) ** 2\nsum_ += term_2 * term_3\nterm_4 = (1 + (1 / 4) * (self._x[-1] - 1)) ** 2\nterm_5 = (1 + np.sin(2 * np.pi * (1 + (1 / 4) * (self._x[-1] - 1)))) ** 2\nsum_ += term_4 * term_5\nreturn term_1 + sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([1.0]) for _ in range(len(self._x))),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Levy function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function","title":"<code>LevyN13Function</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Levy N. 13 function.</p> <p>The Levy N. 13 function is a two-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy N. 13 function is defined as:</p> \\[     f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1     + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1     + \\sin^2( 2 \\pi x_2 ) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyN13Function(OptFunction):\nr\"\"\"Levy N. 13 function.\n    The Levy N. 13 function is a two-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Levy N. 13 function is defined as:\n        $$\n            f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 2 \\pi x_2 ) \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy13.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Levy N. 13\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Levy N. 13 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(3 * np.pi * x_1) ** 2\nterm_2 = (x_1 - 1) ** 2\nterm_3 = 1 + np.sin(3 * np.pi * x_2) ** 2\nterm_4 = (x_2 - 1) ** 2\nterm_5 = 1 + np.sin(2 * np.pi * x_2) ** 2\nreturn term_1 + term_2 * term_3 + term_4 * term_5\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(1.0, 1.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Levy N. 13 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.LevyN13Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Levy N. 13\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction","title":"<code>RastriginFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Rastrigin function.</p> <p>The Rastrigin function is a multi-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n&gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rastrigin function is defined as:</p> \\[     f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class RastriginFunction(OptFunction):\nr\"\"\"Rastrigin function.\n    The Rastrigin function is a multi-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n        &gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rastrigin function is defined as:\n        $$\n            f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rastr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rastrigin function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor x_i in self._x:\nsum_ += x_i**2 - 10 * np.cos(2 * np.pi * x_i)\nreturn 10 * len(self._x) + sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([0.0]) for _ in range(len(self._x))),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Rastrigin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.RastriginFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function","title":"<code>SchafferN2Function</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Schaffer N. 2 function.</p> <p>The Schaffer N. 2 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 2 function is defined as:</p> \\[     f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|     \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN2Function(OptFunction):\nr\"\"\"Schaffer N. 2 function.\n    The Schaffer N. 2 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Schaffer N. 2 function is defined as:\n        $$\n            f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|\n            \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer2.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schaffer N. 2 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n0.5\n+ (np.sin(np.abs(x_1**2 + x_2**2)) ** 2 - 0.5)\n/ (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Schaffer N. 2 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>MinimaAPI object containing the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN2Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function","title":"<code>SchafferN4Function</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Schaffer N. 4 function.</p> <p>The Schaffer N. 4 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 4 function is defined as:</p> \\[     f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }     { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN4Function(OptFunction):\nr\"\"\"Schaffer N. 4 function.\n    The Schaffer N. 4 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Schaffer N. 4 function is defined as:\n        $$\n            f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }\n            { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer4.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 4\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schaffer N. 4 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n0.5\n+ (np.sin(np.sqrt(x_1**2 + x_2**2)) ** 2 - 0.5)\n/ (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Schaffer N. 4 function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchafferN4Function.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 4\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction","title":"<code>SchwefelFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Schwefel function.</p> <p>The Schwefel function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schwefel function is defined as:</p> \\[     f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin     \\left( \\sqrt{ \\left| x_i \\right| } \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchwefelFunction(OptFunction):\nr\"\"\"Schwefel function.\n    The Schwefel function is a multi-dimensional function with a\n    single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Schwefel function is defined as:\n        $$\n            f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin\n            \\left( \\sqrt{ \\left| x_i \\right| } \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schwef.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schwefel function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nreturn 418.9829 * len(self._x) - np.sum(\nself._x * np.sin(np.sqrt(np.abs(self._x))),\naxis=0,\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(420.968746, 420.968746),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Schwefel function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.SchwefelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction","title":"<code>ShubertFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Shubert function.</p> <p>The Shubert function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Shubert function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +     \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class ShubertFunction(OptFunction):\nr\"\"\"Shubert function.\n    The Shubert function is a two-dimensional function with a\n    single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Shubert function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +\n            \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/shubert.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Shubert\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Shubert function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.sum(\nnp.array(\n[\ni * np.cos((i + 1) * x_1 + i) + i * np.cos((i + 1) * x_2 + i)\nfor i in range(1, 6)\n],\n),\naxis=0,\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(f_x=-186.7309, x=(-7.708309818, -0.800371886))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Shubert function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Function values as numpy arrays.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.many_local_minima.ShubertFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Shubert\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction","title":"<code>BoothFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Booth Function.</p> <p>The Booth function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Booth function is defined as:</p> \\[     f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class BoothFunction(OptFunction):\nr\"\"\"Booth Function.\n    The Booth function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Booth function is defined as:\n        $$\n            f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/booth.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Booth function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (x_1 + 2 * x_2 - 7) ** 2 + (2 * x_1 + x_2 - 5) ** 2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Booth function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(1.0, 3.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the Booth function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Booth function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.BoothFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction","title":"<code>MatyasFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Matyas Function.</p> <p>The Matyas function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Matyas function is defined as:</p> \\[     f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class MatyasFunction(OptFunction):\nr\"\"\"Matyas Function.\n    The Matyas function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Matyas function is defined as:\n        $$\n            f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/matya.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Matyas\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Matyas function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 0.26 * (x_1**2 + x_2**2) - 0.48 * x_1 * x_2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Matyas function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the Matyas function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Matyas function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.MatyasFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Matyas\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction","title":"<code>McCormickFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>McCormick Function.</p> <p>The McCormick function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n&gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The McCormick function is defined as:</p> \\[     f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class McCormickFunction(OptFunction):\nr\"\"\"McCormick Function.\n    The McCormick function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n        &gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The McCormick function is defined as:\n        $$\n            f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/mccorm.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the McCormick function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.sin(x_1 + x_2) + (x_1 - x_2) ** 2 - 1.5 * x_1 + 2.5 * x_2 + 1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the McCormick function.\"\"\"\nreturn MinimaAPI(\nf_x=-1.9133,\nx=(-0.54719, -1.54719),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the McCormick function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.McCormickFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the McCormick function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction","title":"<code>PowerSumFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Power Sum Function.</p> <p>The Power Sum function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Power Sum function is defined as:</p> \\[     f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class PowerSumFunction(OptFunction):\nr\"\"\"Power Sum Function.\n    The Power Sum function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Power Sum function is defined as:\n        $$\n            f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/powersum.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Power Sum\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArrayTuple:\n\"\"\"Evaluate the Power Sum function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn x_1**2 + x_2**2 + x_1**4 + x_2**4\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Power Sum function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__eval__","title":"<code>__eval__: UniversalArrayTuple</code>  <code>property</code>","text":"<p>Evaluate the Power Sum function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Power Sum function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.PowerSumFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Power Sum\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction","title":"<code>ZakharovFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Zakharov Function.</p> <p>The Zakharov function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zakharov function is defined as:</p> \\[     f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2     + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZakharovFunction(OptFunction):\nr\"\"\"Zakharov Function.\n    The Zakharov function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zakharov function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2\n            + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zakharov.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArrayTuple:\n\"\"\"Evaluate the Zakharov function at x.\"\"\"\nsum_1 = np.zeros_like(self._x[0])\nsum_2 = np.zeros_like(self._x[0])\nfor i in range(self.dimension):\nsum_1 += self._x[i] ** 2\nsum_2 += 0.5 * (i + 1) * self._x[i]\nreturn sum_1 + sum_2**2 + sum_2**4\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zakharov function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.zeros_like(self.dimension)),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction.__eval__","title":"<code>__eval__: UniversalArrayTuple</code>  <code>property</code>","text":"<p>Evaluate the Zakharov function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZakharovFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Zakharov function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction","title":"<code>ZettlFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Zettl function.</p> <p>The Zettl function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zettl function is defined as:</p> \\[     f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZettlFunction(OptFunction):\nr\"\"\"Zettl function.\n    The Zettl function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zettl function is defined as:\n        $$\n            f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zettl.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Zettl function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn (\nself._x[0] ** 2 + self._x[1] ** 2 - 2 * self._x[0]\n) ** 2 + 0.25 * self._x[0]\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zettl function.\n        Returns:\n            MinimaAPI: Minima of the Zettl function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Zettl function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Zettl function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Zettl function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.plate_shaped.ZettlFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction","title":"<code>BealeFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Beale function.</p> <p>The Beale function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n&gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Beale function is defined as:</p> \\[     f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BealeFunction(OptFunction):\nr\"\"\"Beale function.\n    The Beale function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n        &gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Beale function is defined as:\n        $$\n            f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/beale.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Beale\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Beale function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx, y = self._x[0], self._x[1]\nreturn (\n(1.5 - x + x * y) ** 2\n+ (2.25 - x + x * y**2) ** 2\n+ (2.625 - x + x * y**3) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Beale function.\n        Returns:\n            MinimaAPI: Minima of the Beale function.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=(0.5))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Beale function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Beale function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Beale function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BealeFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Beale\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction","title":"<code>BraninFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Branin function.</p> <p>The Branin function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(0, 15, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Branin function is defined as:</p> \\[     f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s \\] <p>where</p> \\[     a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BraninFunction(OptFunction):\nr\"\"\"Branin function.\n    The Branin function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(0, 15, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Branin function is defined as:\n        $$\n            f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s\n        $$\n        where\n        $$\n            a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/branin.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Branin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Branin function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx, y = self._x[0], self._x[1]\na = 1\nb = 5.1 / (4 * np.pi**2)\nc = 5 / np.pi\nr = 6\ns = 10\nt = 1 / (8 * np.pi)\nreturn a * (y - b * x**2 + c * x - r) ** 2 + s * (1 - t) * np.cos(y) + s\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Branin function.\n        Returns:\n            MinimaAPI: Minima of the Branin function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.397887,\nx=tuple(\nnp.array([-np.pi, 12.275]),\nnp.array([np.pi, 2.275]),\nnp.array([np.pi, 9.42478]),\nnp.array([9.42478, 2.475]),\n),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Branin function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Branin function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Branin function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.BraninFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Branin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction","title":"<code>GoldsteinPriceFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Goldstein-Price function.</p> <p>The Goldstein-Price function is a two-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function is defined as:</p> \\[     f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2     \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)     \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2     \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right) \\] <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceFunction(OptFunction):\nr\"\"\"Goldstein-Price function.\n    The Goldstein-Price function is a two-dimensional function.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Goldstein-Price function is defined as:\n        $$\n            f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2\n            \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)\n            \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2\n            \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right)\n        $$\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Goldstein-Price function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn (\n1\n+ (self._x[0] + self._x[1] + 1) ** 2\n* (\n19\n- 14 * self._x[0]\n+ 3 * self._x[0] ** 2\n- 14 * self._x[1]\n+ 6 * self._x[0] * self._x[1]\n+ 3 * self._x[1] ** 2\n)\n) * (\n30\n+ (2 * self._x[0] - 3 * self._x[1]) ** 2\n* (\n18\n- 32 * self._x[0]\n+ 12 * self._x[0] ** 2\n+ 48 * self._x[1]\n- 36 * self._x[0] * self._x[1]\n+ 27 * self._x[1] ** 2\n)\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Goldstein-Price function.\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Goldstein-Price function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Goldstein-Price function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Goldstein-Price function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction","title":"<code>GoldsteinPriceLogFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Goldstein-Price function in logarithmic form.</p> <p>The Goldstein-Price function in logarithmic form is a two-dimensional function. In this form, the function offers a better conditioning by using the logarithm.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function in logarithmic form is defined as:</p> <p>$$     f(x, y) = frac{1}{2.427} left[     log left( 1 + left( bar{x}_1 + bar{x}_2 + 1 right)^2     left( 19 - 14 x + 3 bar{x}_1^2 - 14 bar{x}_2 + 6 bar{x}_1 bar{x}_2     + 3 bar{x}_2^2 right) right) + log left( 30 + left( 2 bar{x}_1 - 3     bar{x}_2 right)^2 left( 18 - 32 bar{x}_1 + 12 bar{x}_1^2 + 48     bar{x}_2 - 36 bar{x}_1 bar{x}_2 + 27 y^2 right) right) - 8.683 right]</p> Scdoc<pre><code>\\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n</code></pre> <p>$$</p> <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceLogFunction(OptFunction):\nr\"\"\"Goldstein-Price function in logarithmic form.\n    The Goldstein-Price function in logarithmic form is a two-dimensional function.\n    In this form, the function offers a better conditioning by using the logarithm.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Goldstein-Price function in logarithmic form is defined as:\n        $$\n            f(x, y) = \\frac{1}{2.427} \\left[\n            \\log \\left( 1 + \\left( \\bar{x}_1 + \\bar{x}_2 + 1 \\right)^2\n            \\left( 19 - 14 x + 3 \\bar{x}_1^2 - 14 \\bar{x}_2 + 6 \\bar{x}_1 \\bar{x}_2\n            + 3 \\bar{x}_2^2 \\right) \\right) + \\log \\left( 30 + \\left( 2 \\bar{x}_1 - 3\n            \\bar{x}_2 \\right)^2 \\left( 18 - 32 \\bar{x}_1 + 12 \\bar{x}_1^2 + 48\n            \\bar{x}_2 - 36 \\bar{x}_1 \\bar{x}_2 + 27 y^2 \\right) \\right) - 8.683 \\right]\n            \\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n        $$\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Goldstein-Price function in logarithmic form at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = 4 * self._x[0] - 2\nx_2 = 4 * self._x[1] - 2\nreturn (\n1\n/ 2.427\n* (\nnp.log(\n1\n+ (x_1 + x_2 + 1) ** 2\n* (\n19\n- 14 * x_1\n+ 3 * x_1**2\n- 14 * x_2\n+ 6 * x_1 * x_2\n+ 3 * x_2**2\n),\n)\n+ np.log(\n30\n+ (2 * x_1 - 3 * x_2) ** 2\n* (\n18\n- 32 * x_1\n+ 12 * x_1**2\n+ 48 * x_2\n- 36 * x_1 * x_2\n+ 27 * x_2**2\n),\n)\n- 8.683\n)\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Goldstein-Price function in logarithmic form.\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function in logarithmic form.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Goldstein-Price function in logarithmic form at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Goldstein-Price function in logarithmic form.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Goldstein-Price function in logarithmic form.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.GoldsteinPriceLogFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the function.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction","title":"<code>StyblinskiTangFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Styblinski-Tang function.</p> <p>The Styblinski-Tang function is a D-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Styblinski-Tang function is defined as:</p> \\[     f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right) \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-5, 5]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class StyblinskiTangFunction(OptFunction):\nr\"\"\"Styblinski-Tang function.\n    The Styblinski-Tang function is a D-dimensional function.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Styblinski-Tang function is defined as:\n        $$\n            f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right)\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-5, 5]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/stybtang.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Styblinski-Tang function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn np.array(\n0.5\n* sum(\n(self._x[i - 1] ** 4 - 16 * self._x[i - 1] ** 2 + 5 * self._x[i - 1])\nfor i in range(1, self.dimension + 1)\n),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Styblinski-Tang function.\n        Returns:\n            MinimaAPI: Minima of the Styblinski-Tang function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-39.16616570377142,\nx=tuple(np.ones(self.dimension) * -2.903534),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Styblinski-Tang function at x.</p> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>Evaluated function value.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.special.StyblinskiTangFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the Styblinski-Tang function.</p> <p>Returns:</p> Name Type Description <code>MinimaAPI</code> <code>MinimaAPI</code> <p>Minima of the Styblinski-Tang function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction","title":"<code>DixonPriceFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Dixon-Price function.</p> <p>The Dixon-Price function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Dixon-Price function is defined as:</p> \\[ f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class DixonPriceFunction(OptFunction):\nr\"\"\"Dixon-Price function.\n    The Dixon-Price function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Dixon-Price function is defined as:\n        $$\n        f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/dixonpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Dixon-Price function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"DixonPrice\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Dixon-Price function at x.\"\"\"\nx = self._x\nreturn (x[0] - 1) ** 2 + sum(\n(i + 1) * (x[i] - x[i - 1] ** 2) ** 2 for i in range(1, len(x))\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the zero function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([2 ** (-i) for i in range(1, len(self._x) + 1)])),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Dixon-Price function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.DixonPriceFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the Dixon-Price function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Dixon-Price function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"DixonPrice\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction","title":"<code>RosenbrockFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Rosenbrock function.</p> <p>The Rosenbrock function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rosenbrock function is defined as:</p> \\[ f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class RosenbrockFunction(OptFunction):\nr\"\"\"Rosenbrock function.\n    The Rosenbrock function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rosenbrock function is defined as:\n        $$\n        f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rosen.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Rosenbrock function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"Rosenbrock\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rosenbrock function at x.\"\"\"\nx = self._x\nreturn np.array(\nsum(\n100 * (x[i + 1] - x[i] ** 2) ** 2 + (1 - x[i]) ** 2\nfor i in range(len(x) - 1)\n),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the zero function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([1.0 for _ in range(len(self._x))])),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate Rosenbrock function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the zero function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.RosenbrockFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the Rosenbrock function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Rosenbrock function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"Rosenbrock\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction","title":"<code>SixHumpCamelFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Six-hump camel function.</p> <p>The six-hump camel function is a two-dimensional function with six minima, where two of them are global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The six-hump camel function is defined as:</p> \\[ f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class SixHumpCamelFunction(OptFunction):\nr\"\"\"Six-hump camel function.\n    The six-hump camel function is a two-dimensional function with six\n    minima, where two of them are global minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The six-hump camel function is defined as:\n        $$\n        f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel6.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the six-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"SixHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the six-hump camel function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n(4 - 2.1 * x_1**2 + (x_1**4) / 3) * x_1**2\n+ x_1 * x_2\n+ (-4 + 4 * x_2**2) * x_2**2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the six-hump camel function.\"\"\"\nreturn MinimaAPI(\nf_x=-1.031628453489877,\nx=tuple(np.array([0.0898, -0.7126], [-0.0898, 0.7126])),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the six-hump camel function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the six-hump camel function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.SixHumpCamelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the six-hump camel function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the six-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"SixHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction","title":"<code>ThreeHumpCamelFunction</code>","text":"<p>             Bases: <code>OptFunction</code></p> <p>Three-hump camel function.</p> <p>The three-hump camel function is a two-dimensional function with three minima, where one of the minima is a global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The three-hump camel function is defined as:</p> \\[ f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class ThreeHumpCamelFunction(OptFunction):\nr\"\"\"Three-hump camel function.\n    The three-hump camel function is a two-dimensional function with three\n    minima, where one of the minima is a global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The three-hump camel function is defined as:\n        $$\n        f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel3.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the three-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"ThreeHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the three-hump camel function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 2 * x_1**2 - 1.05 * x_1**4 + (x_1**6) / 6 + x_1 * x_2 + x_2**2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the three-hump camel function.\"\"\"\nreturn MinimaAPI(\nf_x=np.array([0.0, 0.0]),\nx=tuple(np.array([0.0])),\n)\n</code></pre>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__eval__","title":"<code>__eval__: UniversalArray</code>  <code>property</code>","text":"<p>Evaluate the three-hump camel function at x.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__minima__","title":"<code>__minima__: MinimaAPI</code>  <code>property</code>","text":"<p>Return the minima of the three-hump camel function.</p>"},{"location":"modules/api/optimization/#umf.functions.optimization.valley_shaped.ThreeHumpCamelFunction.__init__","title":"<code>__init__(*x)</code>","text":"<p>Initialize the three-hump camel function.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>def __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the three-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"ThreeHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n</code></pre>"},{"location":"modules/api/plots/","title":"Modules","text":"<p>Plotting functions for 2D and 3D functions.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot","title":"<code>ClassicPlot</code>","text":"<p>             Bases: <code>Plot</code></p> <p>Plotting functions using via matplotlib.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n&gt;&gt;&gt; plot.plot_dashboard()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.meta.plots import GIFSettings\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; # Start with a simple plot\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     X,\n...     Y,\n...     Z,\n...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n... )\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; # Now only zoom\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n...     settings=GIFSettings(rotate=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n...     settings=GIFSettings(zoom=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only zoom and rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n...     settings=GIFSettings(),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>class ClassicPlot(Plot):\nr\"\"\"Plotting functions using via matplotlib.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = X ** 2 + Y ** 2\n        &gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n        &gt;&gt;&gt; plot.plot_3d()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n        &gt;&gt;&gt; plot.plot_contour()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n        &gt;&gt;&gt; plot.plot_dashboard()\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n        &gt;&gt;&gt; plot.plot_close()\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.meta.plots import GIFSettings\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; # Start with a simple plot\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; plot = ClassicPlot(\n        ...     X,\n        ...     Y,\n        ...     Z,\n        ...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n        ... )\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; # Now only zoom\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n        ...     settings=GIFSettings(rotate=False),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; # Now only rotate\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n        ...     settings=GIFSettings(zoom=False),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; # Now only zoom and rotate\n        &gt;&gt;&gt; plot.plot_save_gif(\n        ...     fig=plot.plot_return,\n        ...     ax_fig=plot.ax_return,\n        ...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n        ...     settings=GIFSettings(),\n        ...     savefig_kwargs={\"transparent\": True},\n        ... )\n        &gt;&gt;&gt; plot.plot_close()\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ...    RayleighDistribution,\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; plot = ClassicPlot(\n        ...     np.array([x, y_sigma_1]),\n        ...     np.array([x, y_sigma_2]),\n        ...     np.array([x, y_sigma_3]),\n        ...     settings=GraphSettings(\n        ...         axis=[\"x\", r\"$f(x)$\"],\n        ...         title=\"Rayleigh Distribution\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n        &gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        settings (GraphSettings, optional): Settings for the graph. Defaults to None.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the plot\n             function.\n    \"\"\"\nfig: plt.figure\nax: plt.Figure\ndef plot_2d(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a 2D function.\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n        \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size)\nself.ax = self.fig.add_subplot(111)\nself.ax.plot(*self._x, color=self.color, **self._kwargs)\nself.label_settings()\ndef plot_series(\nself,\nax: FigureTypeMatplotlib | None = None,\nlabel: list[str | None] | None = None,\n) -&gt; None:\n\"\"\"Plot a 2D function as a series.\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n            label (list[str | None], optional): The label of each line. Defaults to\n                     None.\n        \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size)\nself.ax = self.fig.add_subplot(111)\nif label is None:\nlabel = [None for _ in self._x]\nfor i, _x in enumerate(self._x):\nself.ax.plot(*_x, label=label[i], **self._kwargs)\nself.label_settings(legend=True)\ndef plot_3d(self, ax: plt.Figure | None = None) -&gt; None:\n\"\"\"Plot a 3D function.\n        Args:\n            ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n                 Defaults to None.\n        \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111, projection=\"3d\")\nself.ax.plot_wireframe(\n*self._x,\nedgecolor=plt.cm.get_cmap(self.color).colors,\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings(dim3=True)\ndef plot_contour(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a contour plot.\"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111)\nself.ax.contour(\n*self._x,\ncmap=plt.cm.get_cmap(self.cmap),\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings()\ndef plot_surface(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a 3D function.\"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111, projection=\"3d\")\nself.ax.plot_surface(\n*self._x,\ncmap=plt.cm.get_cmap(self.cmap),\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings(dim3=True)\ndef label_settings(self, *, dim3: bool = False, legend: bool = False) -&gt; None:\n\"\"\"Set the labels for a 2D or 3D plot.\n        Args:\n            ax (plt.Figure): Figure objects to set the labels and title.\n            dim3 (bool, optional): Whether the plot is 3D. Defaults to False.\n            legend (bool, optional): Whether to show the legend. Defaults to False.\n        \"\"\"\nself.ax.set_xlabel(self.axis[0])\nself.ax.set_ylabel(self.axis[1])\nif dim3:\nself.ax.set_zlabel(self.axis[2])\nself.ax.set_title(self.title)\nif legend is not None:\nself.ax.legend()\ndef plot_dashboard(self) -&gt; None:\n\"\"\"Plot a dashboard.\"\"\"\nfrom matplotlib import gridspec\nself.fig = plt.figure(tight_layout=True, figsize=self.size, dpi=self.dpi)\ngs = gridspec.GridSpec(2, 2)\nself.plot_contour(self.fig.add_subplot(gs[0, :]))\nself.plot_3d(self.fig.add_subplot(gs[1, 0], projection=\"3d\"))\nself.plot_surface(self.fig.add_subplot(gs[1, 1], projection=\"3d\"))\nself.fig.align_labels()\ndef plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\nplt.show()\n@property\ndef plot_return(self) -&gt; plt.figure:\n\"\"\"Return the plot.\"\"\"\nreturn self.fig\n@property\ndef ax_return(self) -&gt; plt.Figure:\n\"\"\"Return the Figure.\"\"\"\nreturn self.ax\n@staticmethod\ndef plot_save(\nfig: plt.figure,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save the plot.\n        Args:\n            fig (plt.figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                 save function.\n        \"\"\"\nfig.savefig(fname.with_suffix(f\".{fformat}\"), **kwargs)\n@staticmethod\ndef plot_save_gif(\n*,\nfig: plt.figure,\nax_fig: plt.Figure,\nfname: Path,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n        Note:\n            For gnerating GIFs, the a subfunction is used to update the plot for each\n            frame of the animation. This subfunction is defined in the function\n            `update`.\n        Args:\n            fig (plt.figure): The figure to save.\n            ax_fig (plt.Figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            settings (GIFSettings): The settings for the GIF.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                    save function.\n        \"\"\"\ndef update(frame: int, settings: GIFSettings) -&gt; list[plt.Figure]:\n\"\"\"Updates the plot for each frame of the animation.\n            Args:\n                fig (plt.figure): The figure to update.\n                ax_fig (plt.Figure): The figure to update.\n                frame (int): The current frame number.\n                settings (GIFSettings): The settings for the GIF.\n                **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                    save function.\n            Returns:\n                list[plt.Figure]: A list of the updated plot elements.\n            \"\"\"\nsurf = ax_fig\nif settings.zoom:\nax_fig.set_box_aspect(\nNone,\nzoom=np.linspace(\nsettings.zoom_start,\nsettings.zoom_stop,\nsettings.frames,\n)[frame],\n)\nif settings.rotate:\nax_fig.view_init(\nelev=settings.elev,\nazim=frame * settings.azim % 360,\n)\nreturn [surf]\nanim = FuncAnimation(\nfig,\nupdate,\nframes=settings.frames,\ninterval=settings.interval,\nfargs=(settings,),\n)\nanim.save(fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n@staticmethod\ndef plot_close() -&gt; None:\n\"\"\"Close all plots.\"\"\"\nplt.close(\"all\")\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.ax_return","title":"<code>ax_return: plt.Figure</code>  <code>property</code>","text":"<p>Return the Figure.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_return","title":"<code>plot_return: plt.figure</code>  <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.label_settings","title":"<code>label_settings(*, dim3=False, legend=False)</code>","text":"<p>Set the labels for a 2D or 3D plot.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure objects to set the labels and title.</p> required <code>dim3</code> <code>bool</code> <p>Whether the plot is 3D. Defaults to False.</p> <code>False</code> <code>legend</code> <code>bool</code> <p>Whether to show the legend. Defaults to False.</p> <code>False</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def label_settings(self, *, dim3: bool = False, legend: bool = False) -&gt; None:\n\"\"\"Set the labels for a 2D or 3D plot.\n    Args:\n        ax (plt.Figure): Figure objects to set the labels and title.\n        dim3 (bool, optional): Whether the plot is 3D. Defaults to False.\n        legend (bool, optional): Whether to show the legend. Defaults to False.\n    \"\"\"\nself.ax.set_xlabel(self.axis[0])\nself.ax.set_ylabel(self.axis[1])\nif dim3:\nself.ax.set_zlabel(self.axis[2])\nself.ax.set_title(self.title)\nif legend is not None:\nself.ax.legend()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_2d","title":"<code>plot_2d(ax=None)</code>","text":"<p>Plot a 2D function.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_2d(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a 2D function.\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n    \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size)\nself.ax = self.fig.add_subplot(111)\nself.ax.plot(*self._x, color=self.color, **self._kwargs)\nself.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_3d","title":"<code>plot_3d(ax=None)</code>","text":"<p>Plot a 3D function.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_3d(self, ax: plt.Figure | None = None) -&gt; None:\n\"\"\"Plot a 3D function.\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n    \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111, projection=\"3d\")\nself.ax.plot_wireframe(\n*self._x,\nedgecolor=plt.cm.get_cmap(self.color).colors,\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings(dim3=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_close","title":"<code>plot_close()</code>  <code>staticmethod</code>","text":"<p>Close all plots.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_close() -&gt; None:\n\"\"\"Close all plots.\"\"\"\nplt.close(\"all\")\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_contour","title":"<code>plot_contour(ax=None)</code>","text":"<p>Plot a contour plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_contour(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a contour plot.\"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111)\nself.ax.contour(\n*self._x,\ncmap=plt.cm.get_cmap(self.cmap),\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_dashboard","title":"<code>plot_dashboard()</code>","text":"<p>Plot a dashboard.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_dashboard(self) -&gt; None:\n\"\"\"Plot a dashboard.\"\"\"\nfrom matplotlib import gridspec\nself.fig = plt.figure(tight_layout=True, figsize=self.size, dpi=self.dpi)\ngs = gridspec.GridSpec(2, 2)\nself.plot_contour(self.fig.add_subplot(gs[0, :]))\nself.plot_3d(self.fig.add_subplot(gs[1, 0], projection=\"3d\"))\nself.plot_surface(self.fig.add_subplot(gs[1, 1], projection=\"3d\"))\nself.fig.align_labels()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save the plot.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the  save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save(\nfig: plt.figure,\nfname: Path,\nfformat: str = \"png\",\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save the plot.\n    Args:\n        fig (plt.figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n             save function.\n    \"\"\"\nfig.savefig(fname.with_suffix(f\".{fformat}\"), **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_save_gif","title":"<code>plot_save_gif(*, fig, ax_fig, fname, settings, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Saves the given plot to a file.</p> Note <p>For gnerating GIFs, the a subfunction is used to update the plot for each frame of the animation. This subfunction is defined in the function <code>update</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the     save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save_gif(\n*,\nfig: plt.figure,\nax_fig: plt.Figure,\nfname: Path,\nsettings: GIFSettings,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Saves the given plot to a file.\n    Note:\n        For gnerating GIFs, the a subfunction is used to update the plot for each\n        frame of the animation. This subfunction is defined in the function\n        `update`.\n    Args:\n        fig (plt.figure): The figure to save.\n        ax_fig (plt.Figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        settings (GIFSettings): The settings for the GIF.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                save function.\n    \"\"\"\ndef update(frame: int, settings: GIFSettings) -&gt; list[plt.Figure]:\n\"\"\"Updates the plot for each frame of the animation.\n        Args:\n            fig (plt.figure): The figure to update.\n            ax_fig (plt.Figure): The figure to update.\n            frame (int): The current frame number.\n            settings (GIFSettings): The settings for the GIF.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                save function.\n        Returns:\n            list[plt.Figure]: A list of the updated plot elements.\n        \"\"\"\nsurf = ax_fig\nif settings.zoom:\nax_fig.set_box_aspect(\nNone,\nzoom=np.linspace(\nsettings.zoom_start,\nsettings.zoom_stop,\nsettings.frames,\n)[frame],\n)\nif settings.rotate:\nax_fig.view_init(\nelev=settings.elev,\nazim=frame * settings.azim % 360,\n)\nreturn [surf]\nanim = FuncAnimation(\nfig,\nupdate,\nframes=settings.frames,\ninterval=settings.interval,\nfargs=(settings,),\n)\nanim.save(fname, writer=\"imagemagick\", dpi=settings.dpi, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_series","title":"<code>plot_series(ax=None, label=None)</code>","text":"<p>Plot a 2D function as a series.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Figure</code> <p>Figure object to plot the data.  Defaults to None.</p> <code>None</code> <code>label</code> <code>list[str | None]</code> <p>The label of each line. Defaults to      None.</p> <code>None</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_series(\nself,\nax: FigureTypeMatplotlib | None = None,\nlabel: list[str | None] | None = None,\n) -&gt; None:\n\"\"\"Plot a 2D function as a series.\n    Args:\n        ax (FigureTypeMatplotlib, optional): Figure object to plot the data.\n             Defaults to None.\n        label (list[str | None], optional): The label of each line. Defaults to\n                 None.\n    \"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size)\nself.ax = self.fig.add_subplot(111)\nif label is None:\nlabel = [None for _ in self._x]\nfor i, _x in enumerate(self._x):\nself.ax.plot(*_x, label=label[i], **self._kwargs)\nself.label_settings(legend=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_show","title":"<code>plot_show()</code>","text":"<p>Show the plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\nplt.show()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.ClassicPlot.plot_surface","title":"<code>plot_surface(ax=None)</code>","text":"<p>Plot a 3D function.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_surface(self, ax: FigureTypeMatplotlib | None = None) -&gt; None:\n\"\"\"Plot a 3D function.\"\"\"\nif ax is None:\nself.fig = plt.figure(figsize=self.size, dpi=self.dpi)\nself.ax = self.fig.add_subplot(111, projection=\"3d\")\nself.ax.plot_surface(\n*self._x,\ncmap=plt.cm.get_cmap(self.cmap),\nalpha=self.alpha,\n**self._kwargs,\n)\nself.label_settings(dim3=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot","title":"<code>PlotlyPlot</code>","text":"<p>             Bases: <code>Plot</code></p> <p>Plotting functions using via plotly.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = PlotlyPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for the plot.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>class PlotlyPlot(Plot):\nr\"\"\"Plotting functions using via plotly.\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = X ** 2 + Y ** 2\n        &gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n        &gt;&gt;&gt; plot.plot_3d()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n        &gt;&gt;&gt; plot.plot_contour()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n        &gt;&gt;&gt; plot.plot_surface()\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n    Examples:\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n        &gt;&gt;&gt; from umf.meta.plots import GraphSettings\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ...    RayleighDistribution,\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; plot = PlotlyPlot(\n        ...     np.array([x, y_sigma_1]),\n        ...     np.array([x, y_sigma_2]),\n        ...     np.array([x, y_sigma_3]),\n        ...     settings=GraphSettings(\n        ...         axis=[\"x\", r\"$f(x)$\"],\n        ...         title=\"Rayleigh Distribution\",\n        ...     ),\n        ... )\n        &gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n        &gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        settings (GraphSettings, optional): Settings for the graph. Defaults to None.\n        **kwargs (dict[str, Any]): Keyword arguments for the plot.\n    \"\"\"\nfig: FigureTypePlotly\ndef plot_2d(self, *, mode: str = \"lines\", width: int = 2) -&gt; None:\n\"\"\"Plot a 2D function.\n        Args:\n            mode (str, optional): The mode of the plot. Defaults to \"lines\".\n            width (int, optional): The width of the line. Defaults to 2.\n        \"\"\"\nself.check_mode(mode)\nself.fig = go.Figure(\ndata=go.Scatter(\nx=self._x[0],\ny=self._x[1],\nmode=mode,\nmarker_color=self.color,\nline={\"color\": self.color, \"width\": width},\n**self._kwargs,\n),\n)\nself.label_settings()\ndef plot_series(\nself,\nmode: str = \"lines\",\nwidth: int = 2,\nlabel: list[str | None] | None = None,\n) -&gt; None:\n\"\"\"Plot a 2D function as a series.\"\"\"\nself.check_mode(mode)\nself.fig = go.Figure()\nif label is None:\nlabel = [None for _ in self._x]\nfor i, _x in enumerate(self._x):\nself.fig.add_trace(\ngo.Scatter(\nx=_x[0],\ny=_x[1],\nmode=mode,\nmarker_color=self.color,\nline={\"color\": self.color, \"width\": width},\nname=label[i],\n**self._kwargs,\n),\n)\nself.label_settings(legend=True)\ndef check_mode(self, mode: str) -&gt; None:\n\"\"\"Check if the mode is valid.\"\"\"\nif mode not in {\"lines\", \"markers\", \"lines+markers\"}:\nraise PlotAttributeError(\nchoose=mode,\nmodes={\"lines\", \"markers\", \"lines+markers\"},\n)\n# 3D plots as mesh\ndef plot_3d(self, width: int = 2) -&gt; None:\n\"\"\"Plot a 3D function as meshgrid.\n        Args:\n            width (int, optional): The width of the line. Defaults to 2.\n        \"\"\"\nlines = []\ndef _scatter3d(\n*,\nwidth: int,\ni: int,\ntwist: bool = False,\n) -&gt; PlotlyScatterParameters:\n\"\"\"Return the function parameter for a Plotly scatter3d plot.\n            Args:\n                width (int): The width of the line.\n                i (int): The index of the line.\n                twist (bool, optional): Whether to twist the line. Defaults to False.\n            Returns:\n                PlotlyScatterParameters: The function parameter for a Plotly scatter3d\n                     plot.\n            \"\"\"\nx, y, z = self._x\nx, y, z = (\n(x[:, i], y[:, i], z[:, i]) if twist else (x[i, :], y[i, :], z[i, :])\n)\nreturn {\n\"x\": x,\n\"y\": y,\n\"z\": z,\n\"mode\": \"lines\",\n\"line\": {\"color\": z, \"width\": width, \"colorscale\": self.cmap},\n}\nfor i in range(len(self._x[0])):\nlines.extend(\n(\ngo.Scatter3d(**_scatter3d(width=width, i=i)),\ngo.Scatter3d(**_scatter3d(width=width, i=i, twist=True)),\n),\n)\nself.fig = go.Figure(data=lines)\nself.label_settings()\ndef plot_contour(\nself,\n*,\ncontours_coloring: str | None = None,\nshowscale: bool = False,\n) -&gt; None:\n\"\"\"Plot a contour plot.\n        Args:\n            contours_coloring (str, optional): The color of the contours. Defaults to\n                     None.\n            showscale (bool, optional): Whether to show the color scale. Defaults to\n                     False.\n        Raises:\n            ValueError: If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",\n                    or \"none\".\n        \"\"\"\nif (\ncontours_coloring not in {\"fill\", \"heatmap\", \"lines\", \"none\"}\nand contours_coloring is not None\n):\nraise PlotAttributeError(\nchoose=contours_coloring,\nmodes={\"fill\", \"heatmap\", \"lines\", \"none\"},\n)\nself.fig = go.Figure(\ndata=go.Contour(\nx=self._x[0].flatten(),\ny=self._x[1].flatten(),\nz=self._x[2].flatten(),\ncolorscale=self.cmap,\nopacity=self.alpha,\nshowscale=showscale,\ncontours_coloring=contours_coloring,\n**self._kwargs,\n),\n)\nself.label_settings()\ndef plot_surface(\nself,\n*,\ncolor: str | None = None,\nshowscale: bool = False,\n) -&gt; None:\n\"\"\"Plot a 3D function as surface.\n        Args:\n            color (str, optional): The color of the plot. Defaults to None.\n            showscale (bool, optional): Whether to show the color scale. Defaults to\n                     False.\n        \"\"\"\nself.fig = go.Figure(\ndata=go.Surface(\nx=self._x[0],\ny=self._x[1],\nz=self._x[2],\ncolorscale=self.cmap,\nopacity=self.alpha,\nshowscale=showscale,\nsurfacecolor=color,\n**self._kwargs,\n),\n)\nself.label_settings()\ndef label_settings(self, *, legend: bool = False) -&gt; None:\n\"\"\"Set the labels for a 3D plot.\"\"\"\naxis_titles = {\n2: {\"xaxis_title\", \"yaxis_title\"},\n3: {\"xaxis_title\", \"yaxis_title\", \"zaxis_title\"},\n}\nif len(self.axis) in axis_titles:\nscene = {\ntitle: self.axis[i]\nfor i, title in enumerate(axis_titles[len(self.axis)])\n}\nself.fig.update_layout(\ntitle=self.title,\nscene=scene,\nshowlegend=legend,\nlegend={\n\"orientation\": \"h\",\n\"yanchor\": \"bottom\",\n\"y\": 1.02,\n\"xanchor\": \"right\",\n\"x\": 1,\n}\nif legend\nelse None,\n)\ndef plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\nself.fig.show()\n@property\ndef plot_return(self) -&gt; FigureTypePlotly:\n\"\"\"Return the plot.\"\"\"\nreturn self.fig\n@staticmethod\ndef plot_save(\nfig: go.Figure,\nfname: Path,\nfformat: str = \"png\",\nscale: int = 3,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save the plot.\n        Args:\n            fig (go.Figure): The figure to save.\n            fname (Path): The filename to save the figure to.\n            fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n            scale (int, optional): The scale of the plot. Defaults to 3.\n            **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n                 save function.\n        \"\"\"\nfig.write_image(fname.with_suffix(f\".{fformat}\"), scale=scale, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_return","title":"<code>plot_return: FigureTypePlotly</code>  <code>property</code>","text":"<p>Return the plot.</p>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.check_mode","title":"<code>check_mode(mode)</code>","text":"<p>Check if the mode is valid.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def check_mode(self, mode: str) -&gt; None:\n\"\"\"Check if the mode is valid.\"\"\"\nif mode not in {\"lines\", \"markers\", \"lines+markers\"}:\nraise PlotAttributeError(\nchoose=mode,\nmodes={\"lines\", \"markers\", \"lines+markers\"},\n)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.label_settings","title":"<code>label_settings(*, legend=False)</code>","text":"<p>Set the labels for a 3D plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def label_settings(self, *, legend: bool = False) -&gt; None:\n\"\"\"Set the labels for a 3D plot.\"\"\"\naxis_titles = {\n2: {\"xaxis_title\", \"yaxis_title\"},\n3: {\"xaxis_title\", \"yaxis_title\", \"zaxis_title\"},\n}\nif len(self.axis) in axis_titles:\nscene = {\ntitle: self.axis[i]\nfor i, title in enumerate(axis_titles[len(self.axis)])\n}\nself.fig.update_layout(\ntitle=self.title,\nscene=scene,\nshowlegend=legend,\nlegend={\n\"orientation\": \"h\",\n\"yanchor\": \"bottom\",\n\"y\": 1.02,\n\"xanchor\": \"right\",\n\"x\": 1,\n}\nif legend\nelse None,\n)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_2d","title":"<code>plot_2d(*, mode='lines', width=2)</code>","text":"<p>Plot a 2D function.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The mode of the plot. Defaults to \"lines\".</p> <code>'lines'</code> <code>width</code> <code>int</code> <p>The width of the line. Defaults to 2.</p> <code>2</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_2d(self, *, mode: str = \"lines\", width: int = 2) -&gt; None:\n\"\"\"Plot a 2D function.\n    Args:\n        mode (str, optional): The mode of the plot. Defaults to \"lines\".\n        width (int, optional): The width of the line. Defaults to 2.\n    \"\"\"\nself.check_mode(mode)\nself.fig = go.Figure(\ndata=go.Scatter(\nx=self._x[0],\ny=self._x[1],\nmode=mode,\nmarker_color=self.color,\nline={\"color\": self.color, \"width\": width},\n**self._kwargs,\n),\n)\nself.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_3d","title":"<code>plot_3d(width=2)</code>","text":"<p>Plot a 3D function as meshgrid.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the line. Defaults to 2.</p> <code>2</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_3d(self, width: int = 2) -&gt; None:\n\"\"\"Plot a 3D function as meshgrid.\n    Args:\n        width (int, optional): The width of the line. Defaults to 2.\n    \"\"\"\nlines = []\ndef _scatter3d(\n*,\nwidth: int,\ni: int,\ntwist: bool = False,\n) -&gt; PlotlyScatterParameters:\n\"\"\"Return the function parameter for a Plotly scatter3d plot.\n        Args:\n            width (int): The width of the line.\n            i (int): The index of the line.\n            twist (bool, optional): Whether to twist the line. Defaults to False.\n        Returns:\n            PlotlyScatterParameters: The function parameter for a Plotly scatter3d\n                 plot.\n        \"\"\"\nx, y, z = self._x\nx, y, z = (\n(x[:, i], y[:, i], z[:, i]) if twist else (x[i, :], y[i, :], z[i, :])\n)\nreturn {\n\"x\": x,\n\"y\": y,\n\"z\": z,\n\"mode\": \"lines\",\n\"line\": {\"color\": z, \"width\": width, \"colorscale\": self.cmap},\n}\nfor i in range(len(self._x[0])):\nlines.extend(\n(\ngo.Scatter3d(**_scatter3d(width=width, i=i)),\ngo.Scatter3d(**_scatter3d(width=width, i=i, twist=True)),\n),\n)\nself.fig = go.Figure(data=lines)\nself.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_contour","title":"<code>plot_contour(*, contours_coloring=None, showscale=False)</code>","text":"<p>Plot a contour plot.</p> <p>Parameters:</p> Name Type Description Default <code>contours_coloring</code> <code>str</code> <p>The color of the contours. Defaults to      None.</p> <code>None</code> <code>showscale</code> <code>bool</code> <p>Whether to show the color scale. Defaults to      False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",     or \"none\".</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_contour(\nself,\n*,\ncontours_coloring: str | None = None,\nshowscale: bool = False,\n) -&gt; None:\n\"\"\"Plot a contour plot.\n    Args:\n        contours_coloring (str, optional): The color of the contours. Defaults to\n                 None.\n        showscale (bool, optional): Whether to show the color scale. Defaults to\n                 False.\n    Raises:\n        ValueError: If contours_coloring is not one of \"fill\", \"heatmap\", \"lines\",\n                or \"none\".\n    \"\"\"\nif (\ncontours_coloring not in {\"fill\", \"heatmap\", \"lines\", \"none\"}\nand contours_coloring is not None\n):\nraise PlotAttributeError(\nchoose=contours_coloring,\nmodes={\"fill\", \"heatmap\", \"lines\", \"none\"},\n)\nself.fig = go.Figure(\ndata=go.Contour(\nx=self._x[0].flatten(),\ny=self._x[1].flatten(),\nz=self._x[2].flatten(),\ncolorscale=self.cmap,\nopacity=self.alpha,\nshowscale=showscale,\ncontours_coloring=contours_coloring,\n**self._kwargs,\n),\n)\nself.label_settings()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_save","title":"<code>plot_save(fig, fname, fformat='png', scale=3, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Save the plot.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>fformat</code> <code>str</code> <p>The format to save the plot as. Defaults to \"png\".</p> <code>'png'</code> <code>scale</code> <code>int</code> <p>The scale of the plot. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the  save function.</p> <code>{}</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>@staticmethod\ndef plot_save(\nfig: go.Figure,\nfname: Path,\nfformat: str = \"png\",\nscale: int = 3,\n**kwargs: dict[str, Any],\n) -&gt; None:\n\"\"\"Save the plot.\n    Args:\n        fig (go.Figure): The figure to save.\n        fname (Path): The filename to save the figure to.\n        fformat (str, optional): The format to save the plot as. Defaults to \"png\".\n        scale (int, optional): The scale of the plot. Defaults to 3.\n        **kwargs (dict[str, Any]): Additional keyword arguments to pass to the\n             save function.\n    \"\"\"\nfig.write_image(fname.with_suffix(f\".{fformat}\"), scale=scale, **kwargs)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_series","title":"<code>plot_series(mode='lines', width=2, label=None)</code>","text":"<p>Plot a 2D function as a series.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_series(\nself,\nmode: str = \"lines\",\nwidth: int = 2,\nlabel: list[str | None] | None = None,\n) -&gt; None:\n\"\"\"Plot a 2D function as a series.\"\"\"\nself.check_mode(mode)\nself.fig = go.Figure()\nif label is None:\nlabel = [None for _ in self._x]\nfor i, _x in enumerate(self._x):\nself.fig.add_trace(\ngo.Scatter(\nx=_x[0],\ny=_x[1],\nmode=mode,\nmarker_color=self.color,\nline={\"color\": self.color, \"width\": width},\nname=label[i],\n**self._kwargs,\n),\n)\nself.label_settings(legend=True)\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_show","title":"<code>plot_show()</code>","text":"<p>Show the plot.</p> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_show(self) -&gt; None:\n\"\"\"Show the plot.\"\"\"\nself.fig.show()\n</code></pre>"},{"location":"modules/api/plots/#umf.images.diagrams.PlotlyPlot.plot_surface","title":"<code>plot_surface(*, color=None, showscale=False)</code>","text":"<p>Plot a 3D function as surface.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>The color of the plot. Defaults to None.</p> <code>None</code> <code>showscale</code> <code>bool</code> <p>Whether to show the color scale. Defaults to      False.</p> <code>False</code> Source code in <code>umf/images/diagrams.py</code> Python<pre><code>def plot_surface(\nself,\n*,\ncolor: str | None = None,\nshowscale: bool = False,\n) -&gt; None:\n\"\"\"Plot a 3D function as surface.\n    Args:\n        color (str, optional): The color of the plot. Defaults to None.\n        showscale (bool, optional): Whether to show the color scale. Defaults to\n                 False.\n    \"\"\"\nself.fig = go.Figure(\ndata=go.Surface(\nx=self._x[0],\ny=self._x[1],\nz=self._x[2],\ncolorscale=self.cmap,\nopacity=self.alpha,\nshowscale=showscale,\nsurfacecolor=color,\n**self._kwargs,\n),\n)\nself.label_settings()\n</code></pre>"},{"location":"modules/export/","title":"Export","text":"<p>The useful-math-functions-functions-functions-functions-functions package provides several functions for exporting mathematical expressions as images, text, or binary data. Furthermore it is possible to export the whole documentation of function or module as a string.</p>"},{"location":"modules/export/2d_and_3d_plots/","title":"2D and 3D Plots","text":""},{"location":"modules/export/2d_and_3d_plots/#matplotlib-type-plots","title":"Matplotlib-type Plots","text":"<p>Plotting functions using via matplotlib.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = ClassicPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_surface.png\"))\n&gt;&gt;&gt; plot.plot_dashboard()\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_dashboard.png\"))\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.meta.plots import GIFSettings\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; # Start with a simple plot\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     X,\n...     Y,\n...     Z,\n...     settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]),\n... )\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; # Now only zoom\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_zoom.gif\"),\n...     settings=GIFSettings(rotate=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_rotate.gif\"),\n...     settings=GIFSettings(zoom=False),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; # Now only zoom and rotate\n&gt;&gt;&gt; plot.plot_save_gif(\n...     fig=plot.plot_return,\n...     ax_fig=plot.ax_return,\n...     fname=Path(\"GoldsteinPriceFunction_all.gif\"),\n...     settings=GIFSettings(),\n...     savefig_kwargs={\"transparent\": True},\n... )\n&gt;&gt;&gt; plot.plot_close()\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import ClassicPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = ClassicPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; ClassicPlot.plot_save(plot.plot_return, Path(\"ClassicPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the plot  function.</p> <code>{}</code> Types Matplotlib-type Plots 3D-Plot Contour-Plot Surface-Plot Dashboard-Plot coming soon 2D-Plot"},{"location":"modules/export/2d_and_3d_plots/#plotly-type-plots","title":"Plotly-type Plots","text":"<p>Plotting functions using via plotly.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = X ** 2 + Y ** 2\n&gt;&gt;&gt; plot = PlotlyPlot(X, Y, Z, settings=GraphSettings(axis=[\"x\", \"y\", \"z\"]))\n&gt;&gt;&gt; plot.plot_3d()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_3d.png\"))\n&gt;&gt;&gt; plot.plot_contour()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_contour.png\"))\n&gt;&gt;&gt; plot.plot_surface()\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_surface.png\"))\n</code></pre> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.images.diagrams import PlotlyPlot\n&gt;&gt;&gt; from umf.meta.plots import GraphSettings\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n...    RayleighDistribution,\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; plot = PlotlyPlot(\n...     np.array([x, y_sigma_1]),\n...     np.array([x, y_sigma_2]),\n...     np.array([x, y_sigma_3]),\n...     settings=GraphSettings(\n...         axis=[\"x\", r\"$f(x)$\"],\n...         title=\"Rayleigh Distribution\",\n...     ),\n... )\n&gt;&gt;&gt; plot.plot_series(label=[r\"$\\sigma=1$\", r\"$\\sigma=2$\", r\"$\\sigma=3$\"])\n&gt;&gt;&gt; PlotlyPlot.plot_save(plot.plot_return, Path(\"PlotlyPlot_series.png\"))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>settings</code> <code>GraphSettings</code> <p>Settings for the graph. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for the plot.</p> <code>{}</code> Types Plotly-type Plots 3D-Plot Contour-Plot Surface-Plot Dashboard-Plot coming soon 2D-Plot"},{"location":"modules/export/dataset_generation/","title":"Dataset Generation","text":""},{"location":"modules/export/dataset_generation/#optbench-dataset-generation","title":"OptBench Dataset Generation","text":"<p>Dataset Generation</p> <p>This page describes how to generate the OptBench dataset, which covers a wide range a wide range of different formats:</p> <ul> <li> Text file based as <code>*.csv</code> and <code>*.json</code></li> <li> Binary file based as <code>*.npy</code></li> <li> Image file based as <code>*.png</code> for 2D, 3D, and gif animations. Furthermore,        the image files can also contains series of different functions, if the        used functions are 2D.</li> </ul> Text file based dataset generation JSONCSVCode JSON<pre><code>{\n\"x_0\": [\n[\n-5.0, -4.9, -4.800000000000001, -4.700000000000001, -4.600000000000001,\n-4.500000000000002, -4.400000000000002, -4.3000000000000025,\n-4.200000000000003, -4.100000000000003, -4.0000000000000036,\n-3.900000000000004, -3.8000000000000043, -3.7000000000000046,\n-3.600000000000005, -3.5000000000000053, -3.4000000000000057,\n-3.300000000000006, -3.2000000000000064, -3.1000000000000068,\n-3.000000000000007, -2.9000000000000075, -2.800000000000008,\n-2.700000000000008, -2.6000000000000085, -2.500000000000009,\n-2.4000000000000092, -2.3000000000000096, -2.20000000000001,\n-2.1000000000000103, -2.0000000000000107, -1.900000000000011,\n-1.8000000000000114, -1.7000000000000117, -1.600000000000012,\n-1.5000000000000124, -1.4000000000000128, -1.3000000000000131,\n-1.2000000000000135, -1.1000000000000139, -1.0000000000000142,\n-0.9000000000000146, -0.8000000000000149, -0.7000000000000153,\n-0.6000000000000156, -0.500000000000016, -0.40000000000001634,\n-0.3000000000000167, -0.20000000000001705, -0.10000000000001741,\n-1.7763568394002505e-14, 0.09999999999998188, 0.19999999999998153,\n0.29999999999998117, 0.3999999999999808, 0.49999999999998046,\n0.5999999999999801, 0.6999999999999797, 0.7999999999999794,\n0.899999999999979, 0.9999999999999787, 1.0999999999999783,\n1.199999999999978, 1.2999999999999776, 1.3999999999999773,\n1.499999999999977, 1.5999999999999766, 1.6999999999999762,\n1.7999999999999758, 1.8999999999999755, 1.9999999999999751,\n2.0999999999999748, 2.1999999999999744, 2.299999999999974,\n2.3999999999999737, 2.4999999999999734, 2.599999999999973,\n2.6999999999999726, 2.7999999999999723, 2.899999999999972,\n2.9999999999999716, 3.0999999999999712, 3.199999999999971,\n3.2999999999999705, 3.39999999999997, 3.49999999999997,\n3.5999999999999694, 3.699999999999969, 3.7999999999999687,\n3.8999999999999684, 3.999999999999968, 4.099999999999968,\n4.199999999999967, 4.299999999999967, 4.399999999999967,\n4.499999999999966, 4.599999999999966, 4.6999999999999655,\n4.799999999999965, 4.899999999999965\n], ...\n]\n}\n</code></pre> Scdoc<pre><code>x_0,x_1,x_2\n-5.000000,-5.000000,12.642411\n-5.000000,-4.900000,12.816406\n-5.000000,-4.800000,13.289395\n-5.000000,-4.700000,13.727453\n-5.000000,-4.600000,13.966601\n-5.000000,-4.500000,13.993625\n-5.000000,-4.400000,13.820456\n-5.000000,-4.300000,13.435255\n-5.000000,-4.200000,12.851327\n-5.000000,-4.100000,12.232743\n-5.000000,-4.000000,11.913518\n-5.000000,-3.900000,12.089881\n...,...,...\n</code></pre> <p>For the generation of the dataset, the following code snippet can be used:</p> Python<pre><code>es.save_as_csv(dir_name=\"csv\")\nes.save_as_json(dir_name=\"json\")\n</code></pre> Image Generation Matplotlib <code>res.plot_style = \"matplot\"</code>Plotly <code>res.plot_style = \"plotly\"</code> Example - I Example - II Example - I Example - II <p>A class for optimizing and benchmarking mathematical functions.</p> <p>About OptBench</p> <p>This class inherits from the <code>FunctionBorg</code>, <code>PlotBorg</code>, and <code>SaveBorg</code> classes, which allows it to share state across multiple instances. It defines various properties and methods for managing settings related to plotting, such as the size and resolution of the plot, the axis labels, the color scheme, and the plot style (either Matplotlib or Plotly). It also defines a <code>plot</code> method that plots the shared states of a math function using either Matplotlib or Plotly, depending on the value of the <code>_plot_style</code> attribute.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # 3D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench([\"DeJongN5Function\", \"AckleyFunction\"], dim=3)\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_type_3d = \"plot_surface\"\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n&gt;&gt;&gt; res.save_as_csv(dir_name=\"csv\")\n&gt;&gt;&gt; res.save_as_json(dir_name=\"json\")\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # 2D examples\n&gt;&gt;&gt; from umf.core.create import OptBench\n&gt;&gt;&gt; res = OptBench(\n...     [\n...         \"CrystalBallDistribution\",\n...         \"PseudoVoigtDistribution\",\n...         \"AsymmetricRamanLineshape\",\n...     ],\n...     [\n...         {\"mu\": 1.0, \"sigma\":2, \"alpha\":0.5, \"n\":1.0},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5},\n...         {\"mu\": 1.0, \"sigma\":2, \"eta\":0.5, \"gamma\":0.5},\n...     ],\n...     start=-10,\n...     stop=10,\n...     step_size=0.1,\n...     dim=2,\n... )\n&gt;&gt;&gt; res.show = False\n&gt;&gt;&gt; res.plot_style = \"matplot\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"matplot\")\n&gt;&gt;&gt; # As plotly\n&gt;&gt;&gt; res.plot_style = \"plotly\"\n&gt;&gt;&gt; res.plot_series()\n&gt;&gt;&gt; res.save_as_image(dir_name=\"plotly\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>list[str] | str</code> <p>Name of the function(s) to optimize and benchmark.</p> required <code>func_args</code> <code>list[dict[str, Any]] | dict[str, Any] | None</code> <p>Arguments  for the function(s). Defaults to None.</p> <code>None</code> <code>start</code> <code>float</code> <p>Start value of the range. Defaults to -5.0.</p> <code>-5.0</code> <code>stop</code> <code>float</code> <p>Stop value of the range. Defaults to 5.0.</p> <code>5.0</code> <code>step_size</code> <code>float | int</code> <p>Step value of the range or number of maximum  steps. Defaults to 0.1.</p> <code>0.1</code> <code>dim</code> <code>int</code> <p>Number of dimensions. Defaults to 2.</p> <code>2</code> <code>mode</code> <code>str</code> <p>Mode for creating the range of values. Must be either  'arange' or 'linspace'. Defaults to \"arange\".</p> <code>'arange'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Mode must be either 'arange' or 'linspace'.</p> <code>ValueError</code> <p>Number of dimensions must be greater than 1.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>int</code> <p>Number of dimensions.</p> <code>shared_result</code> <code>dict</code> <p>Dictionary containing arrays for plotting and saving.</p> <p>Methods:</p> Name Description <code>initializeshared_result</code> <p>Make arrays for plotting, saving and add them to share result.</p> <code>create_range</code> <p>float, stop: float,</p> <code>step_size</code> <p>float, dim: int = 2, mode: str = \"arange\")</p> <code>-&gt; list[UniversalArray] | MeshArray</code> <p>Create range of values for each dimension.</p>"},{"location":"modules/export/gifs/","title":"GIFs","text":"<p>About GIFs</p> <p>In addition to the standard image formats, UMF supports exporting plots as animated GIFs. This is done by calling the <code>plot.save_gif</code> method.</p> <p>Saves the given plot to a file.</p> Note <p>For gnerating GIFs, the a subfunction is used to update the plot for each frame of the animation. This subfunction is defined in the function <code>update</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>figure</code> <p>The figure to save.</p> required <code>ax_fig</code> <code>Figure</code> <p>The figure to save.</p> required <code>fname</code> <code>Path</code> <p>The filename to save the figure to.</p> required <code>settings</code> <code>GIFSettings</code> <p>The settings for the GIF.</p> required <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments to pass to the     save function.</p> <code>{}</code> Zoom Rotation Zoom + Rotation"},{"location":"modules/functions/","title":"Functions","text":"<p>In the field of mathematics, a function refers to a connection between a set of possible inputs and a set of potential outputs. It is essential to note that each input corresponds to one output. Therefore, a function can be regarded as a set of rules that assigns one specific element from the set of potential outputs to each item in the possible inputs. Functions are widely used in various fields such as physics, economics, computer science, chemistry, and spectroscopy to describe the relationship between quantities, represent geometric shapes, and model real-world situations.</p> <p>Sometimes, all that's necessary are functions that can link together inputs and outputs.</p> <pre><code>graph LR\nA[Inputs] --&gt; B[Function]\nB --&gt; C[Outputs]</code></pre>"},{"location":"modules/functions/distributions/continuous_2pi_interval/","title":"2\ud835\uded1 Interval","text":""},{"location":"modules/functions/distributions/continuous_2pi_interval/#von-mises-distribution","title":"Von Mises Distribution","text":"<p>von Mises distribution.</p> <p>The von Mises distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... VonMisesDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n&gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n&gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The von Mises distribution is defined as follows for probability density:</p> \\[ f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution. Defaults to 0.</p> <code>0</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu. Defaults to 1.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class VonMisesDistribution(Continuous2PiInterval):\nr\"\"\"von Mises distribution.\n    The von Mises distribution is a continuous probability distribution on the\n    circle. It is a close approximation to the wrapped normal distribution,\n    which is the circular analogue of the normal distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... VonMisesDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = VonMisesDistribution(x, mu=0, kappa=0.5).__eval__\n        &gt;&gt;&gt; y_07 = VonMisesDistribution(x, mu=0, kappa=0.7).__eval__\n        &gt;&gt;&gt; y_09 = VonMisesDistribution(x, mu=0, kappa=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\kappa=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\kappa=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\kappa=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VonMisesDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The von Mises distribution is defined as follows for probability density:\n        $$\n        f(x;\\mu,\\kappa) = \\frac{e^{\\kappa \\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n        $$\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution. Defaults to 0.\n        kappa (float): The concentration of the distribution around mu.\n            Defaults to 1.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the von Mises distribution.\"\"\"\nreturn np.exp(self.kappa * np.cos(self._x - self.mu)) / (\n2 * np.pi * special.i0(self.kappa)\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the von Mises distribution.\"\"\"\ndef _mode() -&gt; float | tuple[float, float]:\n\"\"\"Mode of the von Mises distribution.\"\"\"\nreturn self.mu\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=1 - special.i1(self.kappa) / special.i0(self.kappa),\nmode=_mode(),\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_2pi_interval/#wrapped-asymmetric-laplace-distribution","title":"Wrapped Asymmetric Laplace Distribution","text":"<p>Wrapped asymmetric Laplace distribution.</p> <p>The wrapped (asymmetric) Laplace distribution is a continuous probability distribution on the circle. It is a close approximation to the wrapped normal distribution, which is the circular analogue of the normal distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n... WrappedAsymLaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n&gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.5,\n... kappa=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.7,\n... kappa=0.7,\n... ).__eval__\n&gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n... x,\n... mu=0,\n... lambda_=0.9,\n... kappa=0.9,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The wrapped Laplace distribution is defined as follows for probability density:</p> \\[ \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;= \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt] &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases} {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }} \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }} {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }} {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned} \\] <p>where \\(x \\in [-\\pi, \\pi]\\) and \\(\\mu \\in [-\\pi, \\pi]\\). The parameter \\(\\kappa \\in [0, \\infty)\\) controls the concentration of the distribution around \\(\\mu\\). The function \\(I_0\\) is the modified Bessel function of the first kind and order zero.<sup>1</sup></p> <ol> <li> <p>Wrapped asymmetric Laplace distribution. (2022, January 24). In Wikipedia. en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>lambda_</code> <code>float</code> <p>The scale parameter of the distribution.</p> <code>1</code> <code>kappa</code> <code>float</code> <p>The concentration of the distribution around mu.</p> <code>1</code> Source code in <code>umf/functions/distributions/continuous_2pi_interval.py</code> Python<pre><code>class WrappedAsymLaplaceDistribution(Continuous2PiInterval):\nr\"\"\"Wrapped asymmetric Laplace distribution.\n    The wrapped (asymmetric) Laplace distribution is a continuous probability\n    distribution on the circle. It is a close approximation to the wrapped normal\n    distribution, which is the circular analogue of the normal distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_2pi_interval import (\n        ... WrappedAsymLaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 1000)\n        &gt;&gt;&gt; y_05 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.5,\n        ... kappa=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_07 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.7,\n        ... kappa=0.7,\n        ... ).__eval__\n        &gt;&gt;&gt; y_09 = WrappedAsymLaplaceDistribution(\n        ... x,\n        ... mu=0,\n        ... lambda_=0.9,\n        ... kappa=0.9,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\lambda=0.5$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=r\"$\\lambda=0.7$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=r\"$\\lambda=0.9$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WrappedAsymLaplaceDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The wrapped Laplace distribution is defined as follows for probability\n        density:\n        $$\n        \\begin{aligned}f_{WAL}(\\theta ;m,\\lambda ,\\kappa )&amp;=\n        \\sum _{k=-\\infty }^{\\infty }f_{AL}(\\theta +2\\pi k,m,\\lambda ,\\kappa )\\\\[10pt]\n        &amp;={\\dfrac {\\kappa \\lambda }{\\kappa ^{2}+1}}{\\begin{cases}\n        {\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {1-e^{-2\\pi \\lambda \\kappa }}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {1-e^{2\\pi \\lambda /\\kappa }}}&amp;{\\text{if }}\n        \\theta \\geq m\\\\[12pt]{\\dfrac {e^{-(\\theta -m)\\lambda \\kappa }}\n        {e^{2\\pi \\lambda \\kappa }-1}}-{\\dfrac {e^{(\\theta -m)\\lambda /\\kappa }}\n        {e^{-2\\pi \\lambda /\\kappa }-1}}&amp;{\\text{if }}\\theta &lt;m\\end{cases}}\\end{aligned}\n        $$\n        where $x \\in [-\\pi, \\pi]$ and $\\mu \\in [-\\pi, \\pi]$. The parameter\n        $\\kappa \\in [0, \\infty)$ controls the concentration of the distribution\n        around $\\mu$. The function $I_0$ is the modified Bessel function of the\n        first kind and order zero.[^1]\n        [^1]: Wrapped asymmetric Laplace distribution. (2022, January 24).\n            _In Wikipedia._\n            https://en.wikipedia.org/wiki/Wrapped_asymmetric_Laplace_distribution\n    Args:\n        x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        lambda_: The scale parameter of the distribution.\n        kappa: The concentration of the distribution around mu.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nlambda_: float = 1,\nkappa: float = 1,\n) -&gt; None:\nr\"\"\"Initialize a wrapped Laplace distribution.\n        Args:\n            *x (UniversalArray): The points at which to evaluate the distribution.\n            mu (float): The mean of the distribution. Defaults to 0.\n            lambda_ (float): The scale parameter of the distribution. Defaults to 1.\n            kappa (float): The concentration of the distribution around mu.\n                Defaults to 1.\n        \"\"\"\nsuper().__init__(*x, mu=mu, kappa=kappa)\nself.lambda_ = lambda_\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the wrapped Laplace distribution.\"\"\"\npart_1 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (1 - np.exp(-2 * np.pi * self.lambda_ * self.kappa))\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (1 - np.exp(2 * np.pi * self.lambda_ / self.kappa))\n)\n)\npart_2 = (\nself.kappa\n* self.lambda_\n/ (self.kappa**2 + 1)\n* (\nnp.exp(-(self._x - self.mu) * self.lambda_ * self.kappa)\n/ (np.exp(2 * np.pi * self.lambda_ * self.kappa) - 1)\n- np.exp((self._x - self.mu) * self.lambda_ / self.kappa)\n/ (np.exp(-2 * np.pi * self.lambda_ / self.kappa) - 1)\n)\n)\n# Combine the two parts\nreturn np.where(self._x &gt;= self.mu, part_1, part_2)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the wrapped Laplace distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=1\n- self.lambda_**2\n/ np.sqrt(\n(1 / self.kappa**2 + self.lambda_**2)\n* (self.kappa**2 + self.lambda_**2),\n),\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_bounded_interval/","title":"Bounded Interval","text":""},{"location":"modules/functions/distributions/continuous_bounded_interval/#kumaraswamy-distribution","title":"Kumaraswamy Distribution","text":"<p>Kumaraswamy distribution.</p> <p>The Kumaraswamy distribution is a continuous probability distribution with support on the interval [0, 1]. It is a generalization of the beta distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n&gt;&gt;&gt; plt.close()\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n... KumaraswamyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n... x,\n... a=1,\n... b=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n... x,\n... a=2,\n... b=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"KumaraswamyDistribution-cml.png\",\n... dpi=300,\n... transparent=True\n... )\n</code></pre> Notes <p>The Kumaraswamy distribution is generally defined for the PDF as:</p> \\[ f(x; a, b) = abx^{a-1}(1-x^a)^{b-1} \\] <p>where \\(a, b &gt; 0\\) and \\(0 \\leq x \\leq 1\\). The CDF is given by:</p> \\[ F(x; a, b) = 1 - (1 - x^a)^b \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>a</code> <code>float</code> <p>The first shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>b</code> <code>float</code> <p>The second shape parameter, which must be positive. Default is 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_bounded_interval.py</code> Python<pre><code>class KumaraswamyDistribution(ContinuousBoundedInterval):\nr\"\"\"Kumaraswamy distribution.\n    The Kumaraswamy distribution is a continuous probability distribution with\n    support on the interval [0, 1]. It is a generalization of the beta\n    distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(x, a=1, b=1).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(x, a=2, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(x, a=1, b=2).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(x, a=2, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"KumaraswamyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; plt.close()\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_bounded_interval import (\n        ... KumaraswamyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; kumaraswamy_a1_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a1_b2 = KumaraswamyDistribution(\n        ... x,\n        ... a=1,\n        ... b=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; kumaraswamy_a2_b1 = KumaraswamyDistribution(\n        ... x,\n        ... a=2,\n        ... b=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b1, label=r\"$a=1, b=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b2, label=r\"$a=2, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a1_b2, label=r\"$a=1, b=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, kumaraswamy_a2_b1, label=r\"$a=2, b=1$\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"KumaraswamyDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True\n        ... )\n    Notes:\n        The Kumaraswamy distribution is generally defined for the PDF as:\n        $$\n        f(x; a, b) = abx^{a-1}(1-x^a)^{b-1}\n        $$\n        where $a, b &gt; 0$ and $0 \\leq x \\leq 1$. The CDF is given by:\n        $$\n        F(x; a, b) = 1 - (1 - x^a)^b\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        a (float): The first shape parameter, which must be positive. Default is 1.\n        b (float): The second shape parameter, which must be positive. Default is 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\na: float = 1,\nb: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the Kumaraswamy distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotAPositiveNumberError(msg, b)\nsuper().__init__(*x, start=0, end=1, cumulative=cumulative)\nself.a = a\nself.b = b\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the probability density function of the Kumaraswamy distribution.\n        Returns:\n            UniversalArray: The value of the probability density function of the\n                Kumaraswamy distribution.\n        \"\"\"\nreturn (\nself.a\n* self.b\n* self._x ** (self.a - 1)\n* (1 - self._x**self.a) ** (self.b - 1)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Calculate the cumulative distribution function of the Kumaraswamy distribution.\n        Returns:\n            UniversalArray: The value of the cumulative distribution function of the\n                Kumaraswamy distribution.\n        \"\"\"  # noqa: E501\nreturn 1 - (1 - self._x**self.a) ** self.b\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Calculate the summary statistics of the Kumaraswamy distribution.\n        Returns:\n            SummaryStatisticsAPI: The summary statistics of the Kumaraswamy\n                distribution.\n        \"\"\"\nmode = (\n(self.a - 1) / (self.a + self.b - 2) if self.a &gt; 1 and self.b &gt; 1 else None\n)\nmean = (self.b * gamma(1 + 1 / self.a) * gamma(self.a - 1)) / (\nself.a * gamma(self.a + self.b)\n)\nreturn SummaryStatisticsAPI(\nmean=mean,\nmode=mode,\nvariance=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/","title":"Semi Infinite Interval","text":""},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#rayleigh-distribution","title":"Rayleigh Distribution","text":"<p>Rayleigh distribution.</p> <p>The Rayleigh distribution is a continuous probability distribution that is commonly used in statistics to model the magnitude of a vector whose components are independent and identically distributed Gaussian random variables with zero mean. It is also used to describe the distribution of the magnitude of the sum of independent, identically distributed Gaussian random variables with zero mean and equal variance.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... RayleighDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rayleigh distribution is generally defined for the PDF as:</p> \\[ f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) \\] <p>where \\(\\sigma\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class RayleighDistribution(SemiContinuousWSigma):\nr\"\"\"Rayleigh distribution.\n    The Rayleigh distribution is a continuous probability distribution that is commonly\n    used in statistics to model the magnitude of a vector whose components are\n    independent and identically distributed Gaussian random variables with zero mean.\n    It is also used to describe the distribution of the magnitude of the sum of\n    independent, identically distributed Gaussian random variables with zero mean\n    and equal variance.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... RayleighDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_sigma_1 = RayleighDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = RayleighDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = RayleighDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"RayleighDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Rayleigh distribution is generally defined for the PDF as:\n        $$\n        f(x | \\sigma) = \\frac{x}{\\sigma^2} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\sigma) = 1 - \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n        $$\n        where $\\sigma$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself._x / self.sigma**2 * np.exp(-(self._x**2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-(self._x**2) / (2 * self.sigma**2))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.sqrt(np.pi / 2) * self.sigma,\nvariance=(4 - np.pi) / 2 * self.sigma**2,\nmode=self.sigma,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#weibull-distribution","title":"Weibull Distribution","text":"<p>Weibull distribution.</p> <p>The Weibull distribution is a continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The Weibull distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... WeibullDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n... x,\n... lambda_=1,\n... k=0.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n... x,\n... lambda_=2,\n... k=1.0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n... x,\n... lambda_=3,\n... k=1.5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Weibull distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}     \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right) \\] <p>where \\(\\lambda\\) is the scale parameter and \\(k\\) is the shape parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> required <code>k</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class WeibullDistribution(SemiContinuous):\nr\"\"\"Weibull distribution.\n    The Weibull distribution is a continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The Weibull distribution has\n    applications in various fields, such as finance, biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(x, lambda_=1, k=0.5).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(x, lambda_=2, k=1.0).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(x, lambda_=3, k=1.5).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... WeibullDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_lambda_1 = WeibullDistribution(\n        ... x,\n        ... lambda_=1,\n        ... k=0.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = WeibullDistribution(\n        ... x,\n        ... lambda_=2,\n        ... k=1.0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = WeibullDistribution(\n        ... x,\n        ... lambda_=3,\n        ... k=1.5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1 and k=0.5\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2 and k=1.0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3 and k=1.5\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"WeibullDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Weibull distribution is generally defined for the PDF as:\n        $$\n        f(x | \\lambda, k) = \\frac{k}{\\lambda} \\left(\\frac{x}{\\lambda}\\right)^{k - 1}\n            \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\lambda, k) = 1 - \\exp\\left(-\\left(\\frac{x}{\\lambda}\\right)^k\\right)\n        $$\n        where $\\lambda$ is the scale parameter and $k$ is the shape parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda (float): Scale parameter. Defaults to 1.\n        k (float): Shape parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nlambda_: float = 1.0,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif lambda_ &lt; 0:\nmsg = \"lambda_\"\nraise NotAPositiveNumberError(msg, lambda_)\nif k &lt;= 0:\nmsg = \"k\"\nraise NotLargerThanZeroError(msg, k)\nsuper().__init__(*x, cumulative=cumulative)\nself.lambda_ = lambda_\nself.k = k\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.k\n/ self.lambda_\n* (self._x / self.lambda_) ** (self.k - 1)\n* np.exp(-((self._x / self.lambda_) ** self.k))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-((self._x / self.lambda_) ** self.k))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.lambda_ * gamma(1 + 1 / self.k),\nvariance=self.lambda_**2\n* (gamma(1 + 2 / self.k) - gamma(1 + 1 / self.k) ** 2),\nmode=self.lambda_ * (self.k - 1) ** (1 / self.k) if self.k &gt; 1 else 0,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#log-normal-distribution","title":"Log-Normal Distribution","text":"<p>Log-normal distribution.</p> <p>The log-normal distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the product of many small, independent factors. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The log-normal distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... LogNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The log-normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class LogNormalDistribution(SemiContinuousWSigma):\nr\"\"\"Log-normal distribution.\n    The log-normal distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the product of many small,\n    independent factors. It is a transformation of the normal distribution, where the\n    logarithm of the variable is normally distributed. The log-normal distribution has\n    applications in various fields, such as finance, biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... LogNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = LogNormalDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = LogNormalDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = LogNormalDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogNormalDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The log-normal distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{x \\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{\\ln x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self._x * self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((np.log(self._x) - self.mu) ** 2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((np.log(self._x) - self.mu) / (self.sigma * np.sqrt(2))))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.exp(self.mu + self.sigma**2 / 2),\nvariance=(np.exp(self.sigma**2) - 1)\n* np.exp(2 * self.mu + self.sigma**2),\nmode=np.exp(self.mu - self.sigma**2),\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#chi-squared-distribution","title":"Chi-Squared Distribution","text":"<p>Chi-square distribution.</p> <p>The chi-square distribution is a semi continuous probability distribution that is commonly used in statistics to model variables that are the sum of the squares of independent standard normal random variables. It is a transformation of the normal distribution, where the logarithm of the variable is normally distributed. The chi-square distribution has applications in various fields, such as finance, biology, and engineering.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... ChiSquaredDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n&gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n... x,\n... k=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n... x,\n... k=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n... x,\n... k=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The chi-square distribution is generally defined for the PDF as:</p> \\[ f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2) \\] <p>and for the CDF as:</p> \\[ F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2) \\] <p>where \\(k\\) is the degrees of freedom.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>k</code> <code>float</code> <p>Degrees of freedom. Defaults to 1.</p> <code>1.0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class ChiSquaredDistribution(SemiContinuous):\nr\"\"\"Chi-square distribution.\n    The chi-square distribution is a semi continuous probability distribution that is\n    commonly used in statistics to model variables that are the sum of the squares of\n    independent standard normal random variables. It is a transformation of the normal\n    distribution, where the logarithm of the variable is normally distributed. The\n    chi-square distribution has applications in various fields, such as finance,\n    biology, and engineering.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(x, k=1).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(x, k=2).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(x, k=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... ChiSquaredDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 15, 1000)\n        &gt;&gt;&gt; y_k_1 = ChiSquaredDistribution(\n        ... x,\n        ... k=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_2 = ChiSquaredDistribution(\n        ... x,\n        ... k=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_k_3 = ChiSquaredDistribution(\n        ... x,\n        ... k=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_1, label=\"k=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_2, label=\"k=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_k_3, label=\"k=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ChiSquaredDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The chi-square distribution is generally defined for the PDF as:\n        $$\n        f(x | k) = \\frac{1}{2^{k/2} \\Gamma(k/2)} x^{k/2 - 1} \\exp(-x/2)\n        $$\n        and for the CDF as:\n        $$\n        F(x | k) = \\frac{1}{\\Gamma(k/2)} \\gamma(k/2, x/2)\n        $$\n        where $k$ is the degrees of freedom.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        k (float): Degrees of freedom. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nk: float = 1.0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif k &lt;= 0:\nraise NotLargerThanZeroError(k)\nsuper().__init__(*x, cumulative=cumulative)\nself.k = k\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (2 ** (self.k / 2) * gamma(self.k / 2))\n* self._x ** (self.k / 2 - 1)\n* np.exp(-self._x / 2)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / gamma(self.k / 2) * gammainc(self.k / 2, self._x / 2)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.k,\nvariance=2 * self.k,\nmode=self.k - 2 if self.k &gt; 2 else 0,  # noqa: PLR2004\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_semi_infinite_interval/#dagum-distribution","title":"Dagum Distribution","text":"<p>Dagum distribution.</p> <p>The Dagum distribution is a continuous probability distribution that is defined on the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is characterized by its shape, scale, and shape parameters. The Dagum distribution is used in various fields, including economics, finance, and engineering, to model data that is non-negative and skewed to the right. It has a probability density function (PDF) and a cumulative distribution function (CDF) that can be used to calculate various statistical measures, such as mean, variance, and mode. \u258c</p> Notes <p>The Dagum distribution is generally defined for the PDF as:</p> \\[ f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{(p+1)/p}} \\] <p>and for the CDF as:</p> \\[ F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p} \\] <p>where \\(p\\) is the shape parameter, \\(a\\) is the scale parameter, and \\(b\\) is the shape parameter.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n... DagumDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n&gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>p</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>a</code> <code>float</code> <p>Scale parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <code>b</code> <code>float</code> <p>Shape parameter. Must be greater than 0. Defaults to 1.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>NotLargerThanZeroError</code> <p>If p, a, or b is not larger than 0.</p> Source code in <code>umf/functions/distributions/continuous_semi_infinite_interval.py</code> Python<pre><code>class DagumDistribution(ContinuousPure):\nr\"\"\"Dagum distribution.\n    The Dagum distribution is a continuous probability distribution that is defined on\n    the semi-infinite interval 0, \u221e). It is a three-parameter distribution that is\n    characterized by its shape, scale, and shape parameters. The Dagum distribution is\n    used in various fields, including economics, finance, and engineering, to model\n    data that is non-negative and skewed to the right. It has a probability density\n    function (PDF) and a cumulative distribution function (CDF) that can be used to\n    calculate various statistical measures, such as mean, variance, and mode. \u258c\n    Notes:\n        The Dagum distribution is generally defined for the PDF as:\n        $$\n        f(x | p, a, b) = \\frac{p a^{p}}{x^{p + 1} \\left[1 + \\left(\\frac{a}{b}\n        x\\right)^{p}\\right]^{(p+1)/p}}\n        $$\n        and for the CDF as:\n        $$\n        F(x | p, a, b) = 1 - \\left[1 + \\left(\\frac{a}{b} x\\right)^{p}\\right]^{-p}\n        $$\n        where $p$ is the shape parameter, $a$ is the scale parameter, and $b$ is the\n        shape parameter.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_semi_infinite_interval import (\n        ... DagumDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y_p_1_a_1_b_1 = DagumDistribution(x, p=1, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_2_a_1_b_1 = DagumDistribution(x, p=2, a=1, b=1).__eval__\n        &gt;&gt;&gt; y_p_3_a_1_b_1 = DagumDistribution(x, p=3, a=1, b=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_1_a_1_b_1, label=\"p=1, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_2_a_1_b_1, label=\"p=2, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_p_3_a_1_b_1, label=\"p=3, a=1, b=1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"DagumDistribution.png\", dpi=300, transparent=True)\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        p (float): Shape parameter. Must be greater than 0. Defaults to 1.\n        a (float): Scale parameter. Must be greater than 0. Defaults to 1.\n        b (float): Shape parameter. Must be greater than 0. Defaults to 1.\n    Raises:\n        NotLargerThanZeroError: If p, a, or b is not larger than 0.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\np: float = 1.0,\na: float = 1.0,\nb: float = 1.0,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif p &lt;= 0:\nmsg = \"p\"\nraise NotLargerThanZeroError(msg, p)\nif a &lt;= 0:\nmsg = \"a\"\nraise NotLargerThanZeroError(msg, a)\nif b &lt;= 0:\nmsg = \"b\"\nraise NotLargerThanZeroError(msg, b)\nsuper().__init__(*x)\nself.p = p\nself.a = a\nself.b = b\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.p\n* self.a**self.p\n/ (\nself._x ** (self.p + 1)\n* (1 + (self.a / self.b) ** self.p * self._x**self.p)\n** ((self.p + 1) / self.p)\n)\n)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - (1 + (self.a / self.b) ** self.p * self._x**self.p) ** (-self.p)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.a\n* gamma((self.p - 1) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p),\nvariance=self.a**2\n* (\ngamma((self.p - 2) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p)\n- (\nself.a\n* gamma((self.p - 1) / self.p)\n* gamma((self.p + 1) / self.p)\n/ gamma(self.p / self.p)\n)\n** 2\n),\nmode=self.a\n* ((self.p / self.b) ** (1 / self.p))\n* ((self.p - 1) / self.p) ** (1 / self.p),\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_variable_support/","title":"Variable Support","text":""},{"location":"modules/functions/distributions/continuous_variable_support/#generalized-extreme-value-distribution","title":"Generalized Extreme-Value Distribution","text":"<p>Generalized extreme value distribution.</p> <p>The generalized extreme value distribution is a family of continuous probability distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet and Weibull families also known as type I, II and III extreme value distributions. The generalized extreme value distribution is also sometimes referred to as the Fisher-Tippett distribution or the extreme value type I distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedExtremeValueDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=0.5,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n... x,\n... mu=0,\n... zeta=1,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedExtremeValueDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized extreme value distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right] \\exp \\left[ - \\exp \\left( - \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized extreme value distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right] \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0.0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedExtremeValueDistribution(ContinuousMixed):\nr\"\"\"Generalized extreme value distribution.\n    The generalized extreme value distribution is a family of continuous probability\n    distributions developed within extreme value theory to combine the Gumbel, Fr\u00e9chet\n    and Weibull families also known as type I, II and III extreme value distributions.\n    The generalized extreme value distribution is also sometimes referred to as the\n    Fisher-Tippett distribution or the extreme value type I distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedExtremeValueDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedExtremeValueDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=0.5,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedExtremeValueDistribution(\n        ... x,\n        ... mu=0,\n        ... zeta=1,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=\"zeta=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=\"zeta=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"zeta=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=\"zeta=1\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedExtremeValueDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized extreme value distribution is defined as follows for probability\n        density function:\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left[ 1 + \\zeta \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right]^{-1/\\zeta - 1} \\exp \\left[ - \\left( 1 + \\zeta\n        \\left( \\frac{x - \\mu}{\\sigma} \\right)\n        \\right)^{-1/\\zeta} \\right] &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left[ - \\left( \\frac{x - \\mu}{\\sigma}\n        \\right) \\right] \\exp \\left[ - \\exp \\left( -\n        \\left( \\frac{x - \\mu}{\\sigma} \\right) \\right) \\right] &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n        The generalized extreme value distribution is defined as follows for cumulative\n        distribution function:\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\exp \\left[ - \\left( 1 + \\zeta \\left( \\frac{x -\n        \\mu}{\\sigma} \\right) \\right)^{-1/\\zeta} \\right]\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        zeta (float): Shape parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\n@property\ndef t_factor(self) -&gt; UniversalArray:\n\"\"\"Factor of the t-distribution.\"\"\"\nif self.zeta == 0:\nreturn np.exp(-self._x - self.mu) / self.sigma\nreturn np.exp(-((1 + self.zeta * self._x) ** (-1 / self.zeta))) / self.sigma\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the gen. extreme value distribution.\"\"\"\nreturn self.t_factor**self.zeta * np.exp(-self.t_factor)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the gen. extreme value distribution.\"\"\"\nreturn np.exp(-self.t_factor)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the gen. extreme value distribution.\"\"\"\nif self.zeta != 0 and self.zeta &lt; 1:\nmean = self.mu + self.sigma * (gamma(1 - self.zeta) - 1) / self.zeta\nelif self.zeta == 0:\nmean = self.mu + self.sigma * np.euler_gamma\nelse:\nmean = np.inf\nif self.zeta != 0 and self.zeta &lt; 0.5:  # noqa: PLR2004\nvariance = (\nself.sigma**2\n* (gamma(1 - 2 * self.zeta) - gamma(1 - self.zeta) ** 2)\n/ self.zeta**2\n)\nelif self.zeta == 0:\nvariance = self.sigma**2 * np.pi**2 / 6\nelse:\nvariance = np.inf\nif self.zeta != 0:\nmode = self.mu + self.sigma * (1 - self.zeta ** (-1)) ** (-1 / self.zeta)\nelse:\nmode = self.mu\nreturn SummaryStatisticsAPI(\nmean=mean,\nvariance=variance,\nmode=mode,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_variable_support/#generalized-pareto-distribution","title":"Generalized Pareto Distribution","text":"<p>Generalized Pareto distribution.</p> <p>The generalized Pareto distribution is a family of continuous probability distributions that includes the exponential, Weibull, and uniform distributions. The generalized Pareto distribution is often used to model the tails of another distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n... GeneralizedParetoDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=0.1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=5,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... zeta=20,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n&gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized Pareto distribution is defined as follows for probability density function:</p> \\[ f(x;\\mu,\\sigma,\\zeta) = \\begin{cases} \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta - 1} &amp; \\text{if } \\zeta \\neq 0 \\\\ \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>The generalized Pareto distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;\\mu,\\sigma,\\zeta) = \\begin{cases} 1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if } \\zeta \\neq 0 \\\\ 1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0 \\end{cases} \\] <p>where \\(\\mu \\in \\mathbb{R}\\), \\(\\sigma &gt; 0\\) and \\(\\zeta \\in \\mathbb{R}\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>zeta</code> <code>float</code> <p>Shape parameter. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_variable_support.py</code> Python<pre><code>class GeneralizedParetoDistribution(ContinuousMixed):\nr\"\"\"Generalized Pareto distribution.\n    The generalized Pareto distribution is a family of continuous probability\n    distributions that includes the exponential, Weibull, and uniform distributions.\n    The generalized Pareto distribution is often used to model the tails of another\n    distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_variable_support import (\n        ... GeneralizedParetoDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_00 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_01 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=0.1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_05 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=5,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_10 = GeneralizedParetoDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... zeta=20,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_00, label=r\"$\\zeta$=0\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_01, label=r\"$\\zeta$=0.1\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=r\"$\\zeta$=5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_10, label=r\"$\\zeta$=20\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedParetoDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized Pareto distribution is defined as follows for probability\n        density function:\n        $$\n        f(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        \\frac{1}{\\sigma} \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta -\n        1} &amp; \\text{if } \\zeta \\neq 0 \\\\\n        \\frac{1}{\\sigma} \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if }\n        \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n        The generalized Pareto distribution is defined as follows for cumulative\n        distribution function:\n        $$\n        F(x;\\mu,\\sigma,\\zeta) = \\begin{cases}\n        1 - \\left( 1 + \\zeta \\frac{x - \\mu}{\\sigma} \\right)^{-1/\\zeta} &amp; \\text{if }\n        \\zeta \\neq 0 \\\\\n        1 - \\exp \\left( - \\frac{x - \\mu}{\\sigma} \\right) &amp; \\text{if } \\zeta = 0\n        \\end{cases}\n        $$\n        where $\\mu \\in \\mathbb{R}$, $\\sigma &gt; 0$ and $\\zeta \\in \\mathbb{R}$.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        sigma (float): Scale parameter. Defaults to 1.\n        zeta (float): Shape parameter. Defaults to 0.\n        cumulative (bool): If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nzeta: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the generalized Pareto distribution.\"\"\"\nif (min_x := np.min(x)) &lt; 0:\nmsg = \"*x\"\nraise NotAPositiveNumberError(msg, number=float(min_x))\nsuper().__init__(*x, mu=mu, sigma=sigma, zeta=zeta, cumulative=cumulative)\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn np.exp(-(self._x - self.mu) / self.sigma)\nreturn (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / (self.zeta + 1)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the generalized Pareto distribution.\"\"\"\nif self.zeta == 0:\nreturn 1 - np.exp(-(self._x - self.mu) / self.sigma)\nreturn 1 - (1 + self.zeta * (self._x - self.mu) / self.sigma) ** (\n-1 / self.zeta\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the generalized Pareto distribution.\"\"\"\nSummaryStatisticsAPI(\nmean=self.mu + self.sigma / (1 - self.zeta) if self.zeta &lt; 1 else np.inf,\nvariance=self.sigma**2 / (1 - self.zeta) ** 2 / (1 - 2 * self.zeta)\nif self.zeta &lt; 0.5  # noqa: PLR2004\nelse np.inf,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/","title":"Whole Line Support","text":""},{"location":"modules/functions/distributions/continuous_whole_line_support/#generalized-normal-distribution","title":"Generalized Normal Distribution","text":"<p>Generalized normal distribution.</p> <p>The generalized normal distribution is a probability distribution that extends the normal distribution to incorporate an additional shape parameter, allowing for greater flexibility in modeling a wider range of data distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GeneralizedNormalDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"GeneralizedNormalDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The generalized normal distribution is generally defined for the PDF as:</p> \\[ f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}   \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2} \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha}, \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma \\left(\\frac{1}{\\alpha}\\right)}\\right) \\] <p>where \\(\\alpha\\) is the shape parameter, \\(\\beta\\) is the scale parameter, and \\(\\mu\\) is the location parameter plus \\(\\Gamma\\) as the gamma function. The PDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha, \\beta &gt; 0\\). The CDF is defined for \\(x \\in \\mathbb{R}\\) and \\(\\alpha &gt; 0\\) and rquires the unnormalized lower incomplete gamma function.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Shape parameter. Defaults to 1.</p> <code>1</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GeneralizedNormalDistribution(ContinuousWBeta):\nr\"\"\"Generalized normal distribution.\n    The generalized normal distribution is a probability distribution that extends the\n    normal distribution to incorporate an additional shape parameter, allowing for\n    greater flexibility in modeling a wider range of data distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GeneralizedNormalDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GeneralizedNormalDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = GeneralizedNormalDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"GeneralizedNormalDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The generalized normal distribution is generally defined for the PDF as:\n        $$\n        f(x | \\beta, \\mu, \\alpha) = \\frac{\\alpha}{2\\beta \\Gamma(1/\\alpha)}\n          \\exp\\left(-\\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\beta, \\mu, \\alpha) = \\frac{1}{2} + \\frac{\\mathrm{sign}(x - \\mu)}{2}\n        \\left(1 - \\frac{\\Gamma\\left(\\frac{1}{\\alpha},\n        \\left|\\frac{x - \\mu}{\\beta}\\right|^\\alpha\\right)}{\\Gamma\n        \\left(\\frac{1}{\\alpha}\\right)}\\right)\n        $$\n        where $\\alpha$ is the shape parameter, $\\beta$ is the scale parameter, and\n        $\\mu$ is the location parameter plus $\\Gamma$ as the gamma function.\n        The PDF is defined for $x \\in \\mathbb{R}$ and $\\alpha, \\beta &gt; 0$.\n        The CDF is defined for $x \\in \\mathbb{R}$ and $\\alpha &gt; 0$ and rquires the\n        unnormalized lower incomplete gamma function.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        alpha (float): Shape parameter. Defaults to 1.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nalpha: float = 1,\nbeta: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif beta &lt; 0:\nmsg = \"beta\"\nraise NotAPositiveNumberError(msg, beta)\nif alpha &lt;= 0:\nmsg = \"alpha\"\nraise NotLargerThanZeroError(msg, alpha)\nsuper().__init__(*x, mu=mu, beta=beta, cumulative=cumulative)\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\nself.beta\n/ (2 * self.alpha * gamma(1.0 / self.beta))\n* np.exp(-np.abs((self._x - self.mu) / self.alpha) ** self.beta)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 + np.sign(self._x - self.mu) * (\n1 / (2 * gamma(1 / self.beta))\n) * gammainc(\n1 / self.beta,\nnp.abs((self._x - self.mu) / self.alpha) ** self.beta,\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.alpha**2 * gamma(3 / self.beta) / gamma(1 / self.beta),\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#gaussian-distribution","title":"Gaussian Distribution","text":"<p>Gaussian distribution.</p> <p>The Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n... x,\n... sigma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n... x,\n... sigma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n... x,\n... sigma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf} \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean and \\(\\sigma\\) is the standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GaussianDistribution(ContinuousWSigma):\nr\"\"\"Gaussian distribution.\n    The Gaussian distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = GaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_2 = GaussianDistribution(\n        ... x,\n        ... sigma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_3 = GaussianDistribution(\n        ... x,\n        ... sigma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GaussianDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gaussian distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma) = \\frac{1}{2} \\left[1 + \\mathrm{erf}\n        \\left(\\frac{x - \\mu}{\\sigma \\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean and $\\sigma$ is the standard deviation.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 0.5 * (1 + erf((self._x - self.mu) / (self.sigma * np.sqrt(2))))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.sigma**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#skew-gaussian-distribution","title":"Skew Gaussian Distribution","text":"<p>Skew Gaussian distribution.</p> <p>The Skew Gaussian distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions with skewness.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... SkewGaussianDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=0,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=1,\n... ).__eval__\n&gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n... x,\n... sigma=1,\n... alpha=-1,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Skew Gaussian distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right] \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation, and \\(\\alpha\\) is the skewness.</p> <p>The CDF is not available in closed form.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>alpha</code> <code>float</code> <p>Skewness. Defaults to 0.</p> <code>0</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class SkewGaussianDistribution(ContinuousWSigma):\nr\"\"\"Skew Gaussian distribution.\n    The Skew Gaussian distribution is a continuous probability distribution that is\n    widely used in statistics to describe the normal distributions with skewness.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... SkewGaussianDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1_alpha_0 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=0,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=1,\n        ... ).__eval__\n        &gt;&gt;&gt; y_sigma_1_alpha_minus_1 = SkewGaussianDistribution(\n        ... x,\n        ... sigma=1,\n        ... alpha=-1,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_0, label=\"sigma=1, alpha=0\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_1, label=\"sigma=1, alpha=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1_alpha_minus_1, label=\"sigma=1, alpha=-1\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"SkewGaussianDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Skew Gaussian distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma, \\alpha) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n        \\exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right)\n        \\left[1 + \\mathrm{erf}\\left(\\frac{\\alpha(x - \\mu)}{\\sigma\\sqrt{2}}\\right)\\right]\n        $$\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation, and $\\alpha$ is the\n        skewness.\n        The CDF is not available in closed form.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        alpha (float): Skewness. Defaults to 0.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nalpha: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ (self.sigma * np.sqrt(2 * np.pi))\n* np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2))\n* (1 + erf(self.alpha * (self._x - self.mu) / (self.sigma * np.sqrt(2))))\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=self.sigma**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#laplace-distribution","title":"Laplace Distribution","text":"<p>Laplace distribution.</p> <p>The Laplace distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LaplaceDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Laplace distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right) \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu) \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right) \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LaplaceDistribution(ContinuousWBeta):\nr\"\"\"Laplace distribution.\n    The Laplace distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LaplaceDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LaplaceDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LaplaceDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LaplaceDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LaplaceDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Laplace distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{2\\beta} \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{2} + \\frac{1}{2}\\mathrm{sign}(x - \\mu)\n        \\left(1 - \\exp\\left(-\\frac{|x - \\mu|}{\\beta}\\right)\\right)\n        $$\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (2 * self.beta) * np.exp(-np.abs((self._x - self.mu) / self.beta))\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.array(\n0.5\n+ 0.5\n* np.sign(self._x - self.mu)\n* (1 - np.exp(-np.abs((self._x - self.mu) / self.beta))),\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=2 * self.beta**2,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#logistic-distribution","title":"Logistic Distribution","text":"<p>Logistic distribution.</p> <p>The logistic distribution is a continuous probability distribution that is widely used in statistics to describe the normal distributions.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... LogisticDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n... x,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n... x,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n... x,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Logistic distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)} \\] <p>where \\(\\mu\\) is the mean and \\(\\beta\\) is the scale parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class LogisticDistribution(ContinuousWBeta):\nr\"\"\"Logistic distribution.\n    The logistic distribution is a continuous probability distribution that is widely\n    used in statistics to describe the normal distributions.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(x, beta=1).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(x, beta=2).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(x, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... LogisticDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_beta_1 = LogisticDistribution(\n        ... x,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_2 = LogisticDistribution(\n        ... x,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_beta_3 = LogisticDistribution(\n        ... x,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_1, label=\"beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_2, label=\"beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_beta_3, label=\"beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"LogisticDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Logistic distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta} \\exp\\left(-\\frac{x -\n        \\mu}{\\beta}\\right)\\left(1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)\\right)^{-2}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\beta) = \\frac{1}{1 + \\exp\\left(-\\frac{x - \\mu}{\\beta}\\right)}\n        $$\n        where $\\mu$ is the mean and $\\beta$ is the scale parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        beta (float): Scale parameter. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nreturn np.array(\n1\n/ self.beta\n* np.exp(-(self._x - self.mu) / self.beta)\n/ (1 + np.exp(-(self._x - self.mu) / self.beta)) ** 2,\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / (1 + np.exp(-(self._x - self.mu) / self.beta))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu,\nvariance=(np.pi**2 * self.beta**2) / 3,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#voigt-distribution","title":"Voigt Distribution","text":"<p>Voigt distribution.</p> <p>The Voigt distribution is a continuous probability distribution that is widely used in physics and spectroscopy to describe the line shape of spectral lines. It is a convolution of a Gaussian distribution and a Lorentzian distribution, and is useful for modeling the effects of both natural and instrumental broadening on spectral lines.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... VoigtDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n&gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n&gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Voigt distribution is generally defined for the PDF as:</p> \\[ f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>which can be further simplified to:</p> \\[ V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}} \\] <p>with \\(\\operatorname {Re} [w(z)\\) as the real part of the Faddeeva function and \\(z\\) as:</p> \\[ z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}} \\] <p>and for the CDF as:</p> \\[ F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}   \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)   \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy \\] <p>where \\(\\mu\\) is the mean, \\(\\sigma\\) is the standard deviation and \\(\\gamma\\) is the Lorentzian width.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>sigma</code> <code>float</code> <p>Standard deviation. Defaults to 1.</p> <code>1</code> <code>gamma</code> <code>float</code> <p>Lorentzian width. Defaults to 1.</p> <code>1</code> <code>mu</code> <code>float</code> <p>Mean. Defaults to 0.</p> <code>0</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class VoigtDistribution(ContinuousWSigma):\nr\"\"\"Voigt distribution.\n    The Voigt distribution is a continuous probability distribution that is widely used\n    in physics and spectroscopy to describe the line shape of spectral lines. It is a\n    convolution of a Gaussian distribution and a Lorentzian distribution, and is useful\n    for modeling the effects of both natural and instrumental broadening on spectral\n    lines.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... VoigtDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_sigma_1 = VoigtDistribution(x, sigma=1).__eval__\n        &gt;&gt;&gt; y_sigma_2 = VoigtDistribution(x, sigma=2).__eval__\n        &gt;&gt;&gt; y_sigma_3 = VoigtDistribution(x, sigma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_1, label=\"sigma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_2, label=\"sigma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_sigma_3, label=\"sigma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"VoigtDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Voigt distribution is generally defined for the PDF as:\n        $$\n        f(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^\\infty \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n        which can be further simplified to:\n        $$\n        V(x;\\sigma ,\\gamma )={\\frac {\\operatorname {Re} [w(z)]}{\\sigma {\\sqrt {2\\pi }}}}\n        $$\n        with $\\operatorname {Re} [w(z)$ as the real part of the Faddeeva function and\n        $z$ as:\n        $$\n        z={\\frac {x+i\\gamma }{\\sigma {\\sqrt {2}}}}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\mu, \\sigma, \\gamma) = \\frac{1}{\\sigma \\sqrt{2\\pi}}\n          \\int_{-\\infty}^x \\exp\\left(-\\frac{(x - y)^2}{2\\sigma^2}\\right)\n          \\frac{\\gamma}{\\pi\\left((x - y)^2 + \\gamma^2\\right)} dy\n        $$\n        where $\\mu$ is the mean, $\\sigma$ is the standard deviation and $\\gamma$ is the\n        Lorentzian width.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        sigma (float): Standard deviation. Defaults to 1.\n        gamma (float): Lorentzian width. Defaults to 1.\n        mu (float): Mean. Defaults to 0.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nsigma: float = 1,\ngamma: float = 1,\nmu: float = 0,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif sigma &lt; 0:\nmsg = \"sigma\"\nraise NotAPositiveNumberError(msg, sigma)\nif gamma &lt; 0:\nmsg = \"gamma\"\nraise NotAPositiveNumberError(msg, gamma)\nsuper().__init__(*x, mu=mu, sigma=sigma, cumulative=cumulative)\nself.gamma = gamma\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Return the probability density function.\"\"\"\nz = (self._x + 1j * self.gamma) / (self.sigma * np.sqrt(2))\nreturn np.real(wofz(z)) / (self.sigma * np.sqrt(2 * np.pi))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=0,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#cauchy-distribution","title":"Cauchy Distribution","text":"<p>Cauchy distribution.</p> <p>The Cauchy distribution is a continuous probability distribution that has no mean or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... CauchyDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n... x,\n... gamma=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n... x,\n... gamma=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n... x,\n... gamma=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cauchy distribution is defined as:</p> \\[ f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 + \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]} \\] <p>where \\(x_0\\) is the location parameter and \\(\\gamma\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Cauchy distribution is:</p> \\[ F(x | x_0, \\gamma) = \\frac{1}{\\pi} \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>gamma</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class CauchyDistribution(ContinuousDistributionBase):\nr\"\"\"Cauchy distribution.\n    The Cauchy distribution is a continuous probability distribution that has no mean\n    or variance. It is also known as the Lorentz distribution, after Hendrik Lorentz.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(x, gamma=1).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(x, gamma=2).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(x, gamma=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... CauchyDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_gamma_1 = CauchyDistribution(\n        ... x,\n        ... gamma=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_2 = CauchyDistribution(\n        ... x,\n        ... gamma=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_gamma_3 = CauchyDistribution(\n        ... x,\n        ... gamma=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_1, label=\"gamma=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_2, label=\"gamma=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_gamma_3, label=\"gamma=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CauchyDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Cauchy distribution is defined as:\n        $$\n        f(x | x_0, \\gamma) = \\frac{1}{\\pi \\gamma \\left[1 +\n        \\left(\\frac{x - x_0}{\\gamma}\\right)^2\\right]}\n        $$\n        where $x_0$ is the location parameter and $\\gamma$ is the scale parameter.\n        The cumulative distribution function (CDF) of the Cauchy distribution is:\n        $$\n        F(x | x_0, \\gamma) = \\frac{1}{\\pi}\n        \\arctan\\left(\\frac{x - x_0}{\\gamma}\\right) + \\frac{1}{2}\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        gamma (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\ngamma: float = 1,\ncumulative: bool = False,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif gamma &lt;= 0:\nmsg = \"gamma must be positive\"\nraise ValueError(msg)\nself.gamma = gamma\nsuper().__init__(*x, mu=mu, cumulative=cumulative)\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn 1 / (np.pi * self.gamma * (1 + ((self._x - self.mu) / self.gamma) ** 2))\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 / np.pi * np.arctan((self._x - self.mu) / self.gamma) + 1 / 2\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.nan,\nvariance=np.nan,\nmode=self.mu,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#gumbel-distribution","title":"Gumbel Distribution","text":"<p>Gumbel distribution.</p> <p>The Gumbel distribution is a continuous probability distribution that is used to model the distribution of the maximum (or the minimum) of a number of samples of various distributions. It is a two-parameter family of curves, with the location parameter \\(\\mu\\) controlling the location of the distribution and the scale parameter \\(\\beta\\) controlling the spread of the distribution.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... GumbelDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n&gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n... x,\n... mu=0,\n... beta=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n... x,\n... mu=5,\n... beta=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n... x,\n... mu=10,\n... beta=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gumbel distribution is defined as:</p> \\[ f(x | \\mu, \\beta) = \\frac{1}{\\beta} e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}} \\] <p>where \\(\\mu\\) is the location parameter and \\(\\beta\\) is the scale parameter.</p> <p>The cumulative distribution function (CDF) of the Gumbel distribution is:</p> \\[ F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}} \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one dimensional.</p> <code>()</code> <code>mu</code> <code>float</code> <p>Location parameter. Defaults to 0.</p> <code>0</code> <code>beta</code> <code>float</code> <p>Scale parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class GumbelDistribution(ContinuousWBeta):\nr\"\"\"Gumbel distribution.\n    The Gumbel distribution is a continuous probability distribution that is used to\n    model the distribution of the maximum (or the minimum) of a number of samples of\n    various distributions. It is a two-parameter family of curves, with the location\n    parameter $\\mu$ controlling the location of the distribution and the scale\n    parameter $\\beta$ controlling the spread of the distribution.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(x, mu=0, beta=1).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(x, mu=5, beta=2).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(x, mu=10, beta=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... GumbelDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-10, 20, 1000)\n        &gt;&gt;&gt; y_mu_0_beta_1 = GumbelDistribution(\n        ... x,\n        ... mu=0,\n        ... beta=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_5_beta_2 = GumbelDistribution(\n        ... x,\n        ... mu=5,\n        ... beta=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_mu_10_beta_3 = GumbelDistribution(\n        ... x,\n        ... mu=10,\n        ... beta=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_0_beta_1, label=\"mu=0, beta=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_5_beta_2, label=\"mu=5, beta=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_mu_10_beta_3, label=\"mu=10, beta=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GumbelDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gumbel distribution is defined as:\n        $$\n        f(x | \\mu, \\beta) = \\frac{1}{\\beta}\n        e^{-\\frac{x - \\mu + e^{-(x - \\mu)/\\beta}}{\\beta}}\n        $$\n        where $\\mu$ is the location parameter and $\\beta$ is the scale parameter.\n        The cumulative distribution function (CDF) of the Gumbel distribution is:\n        $$\n        F(x | \\mu, \\beta) = e^{-e^{-(x - \\mu)/\\beta}}\n        $$\n    Args:\n        *x (UniversalArray): Input data, which can be only one dimensional.\n        mu (float): Location parameter. Defaults to 0.\n        beta (float): Scale parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn (\n1\n/ self.beta\n* np.exp(\n-(self._x - self.mu + np.exp(-(self._x - self.mu) / self.beta))\n/ self.beta,\n)\n)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn np.exp(-np.exp(-(self._x - self.mu) / self.beta))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.mu + self.beta * np.euler_gamma,\nvariance=(np.pi**2 / 6) * self.beta**2,\nmode=self.mu + self.beta * np.log(np.log(3)),\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/continuous_whole_line_support/#exponential-distribution","title":"Exponential Distribution","text":"<p>Exponential distribution.</p> <p>The exponential distribution is a continuous probability distribution that describes the time between events in a Poisson process, where events occur continuously and independently at a constant average rate. It is a one-parameter family of curves, with the rate parameter \\(\\lambda\\) controlling the shape of the distribution. The exponential distribution is widely used in reliability theory, queueing theory, and other fields.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n... ExponentialDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n&gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n... x,\n... lambda_=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n... x,\n... lambda_=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n... x,\n... lambda_=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111)\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n&gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The exponential distribution is generally defined for the PDF as:</p> \\[ f(x | \\lambda) = \\lambda e^{-\\lambda x} \\] <p>and for the CDF as:</p> \\[ F(x | \\lambda) = 1 - e^{-\\lambda x} \\] <p>where \\(\\lambda\\) is the rate parameter.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be only one  dimensional.</p> <code>()</code> <code>lambda_</code> <code>float</code> <p>Rate parameter. Defaults to 1.</p> <code>1</code> <code>cumulative</code> <code>bool</code> <p>If True, the CDF is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/continuous_whole_line_support.py</code> Python<pre><code>class ExponentialDistribution(ContinuousWLambda):\nr\"\"\"Exponential distribution.\n    The exponential distribution is a continuous probability distribution that\n    describes the time between events in a Poisson process, where events occur\n    continuously and independently at a constant average rate. It is a one-parameter\n    family of curves, with the rate parameter $\\lambda$ controlling the shape of the\n    distribution. The exponential distribution is widely used in reliability theory,\n    queueing theory, and other fields.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(x, lambda_=1).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(x, lambda_=2).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(x, lambda_=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.continuous_whole_line_support import (\n        ... ExponentialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 5, 1000)\n        &gt;&gt;&gt; y_lambda_1 = ExponentialDistribution(\n        ... x,\n        ... lambda_=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_2 = ExponentialDistribution(\n        ... x,\n        ... lambda_=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_lambda_3 = ExponentialDistribution(\n        ... x,\n        ... lambda_=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111)\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_1, label=\"lambda=1\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_2, label=\"lambda=2\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_lambda_3, label=\"lambda=3\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"ExponentialDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The exponential distribution is generally defined for the PDF as:\n        $$\n        f(x | \\lambda) = \\lambda e^{-\\lambda x}\n        $$\n        and for the CDF as:\n        $$\n        F(x | \\lambda) = 1 - e^{-\\lambda x}\n        $$\n        where $\\lambda$ is the rate parameter.\n    Args:\n        *x (UniversalArray): Input data, which can be only one  dimensional.\n        lambda_ (float): Rate parameter. Defaults to 1.\n        cumulative (bool): If True, the CDF is returned. Defaults to False.\n    \"\"\"\ndef probability_density_function(self) -&gt; np.ndarray:\n\"\"\"Return the probability density function.\"\"\"\nreturn self.lambda_ * np.exp(-self.lambda_ * self._x)\ndef cumulative_distribution_function(self) -&gt; np.ndarray:\n\"\"\"Return the cumulative distribution function.\"\"\"\nreturn 1 - np.exp(-self.lambda_ * self._x)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Return the summary statistics.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=1 / self.lambda_,\nvariance=1 / self.lambda_**2,\nmode=0,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function Cumulative Distribution Function"},{"location":"modules/functions/distributions/discrete_finite_support/","title":"Finite Support","text":""},{"location":"modules/functions/distributions/discrete_finite_support/#bernoulli-distribution","title":"Bernoulli Distribution","text":"<p>Bernoulli distribution.</p> <p>The Bernoulli distribution is a discrete distribution with two possible outcomes, 0 and 1. It is the simplest discrete distribution. It is a special case of the binomial distribution where a single trial is conducted (n=1).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BernoulliDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n&gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bernoulli distribution is defined as follows:</p> \\[ f(x;p) = p^x (1-p)^{1-x} \\] <p>where \\(x \\in \\{0, 1\\}\\) and \\(p \\in [0, 1]\\).</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> <code>0.5</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BernoulliDistribution(DiscreteP):\nr\"\"\"Bernoulli distribution.\n    The Bernoulli distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is the simplest discrete distribution. It is a\n    special case of the binomial distribution where a single trial is\n    conducted (n=1).\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BernoulliDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0, 1, 1000)\n        &gt;&gt;&gt; y_05 = BernoulliDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BernoulliDistribution(x, p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BernoulliDistribution(x, p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BernoulliDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Bernoulli distribution is defined as follows:\n        $$\n        f(x;p) = p^x (1-p)^{1-x}\n        $$\n        where $x \\in \\{0, 1\\}$ and $p \\in [0, 1]$.\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n    \"\"\"\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Bernoulli distribution.\"\"\"\nreturn self.p**self._x * (self.q) ** (1 - self._x)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Bernoulli distribution.\"\"\"\ndef _mode() -&gt; float | tuple[float, float]:\n\"\"\"Mode of the Bernoulli distribution.\"\"\"\nthreshold = 0.5\nif self.p &gt; threshold:\nreturn 1\nreturn 0 if self.p &lt; threshold else (0, 1)\nreturn SummaryStatisticsAPI(\nmean=self.p,\nvariance=self.p * self.q,\nmode=_mode(),\ndoc=self.__doc__,\n)\n</code></pre> Probability Mass Function"},{"location":"modules/functions/distributions/discrete_finite_support/#binomial-distribution","title":"Binomial Distribution","text":"<p>Binomial distribution.</p> <p>The binomial distribution is a discrete distribution with two possible outcomes, 0 and 1. It is a generalization of the Bernoulli distribution where \\(n\\) trials are conducted.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n&gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n... BinomialDistribution\n... )\n&gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n&gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n&gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n&gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n&gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n&gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The binomial distribution is defined as follows for probability mass function:</p> \\[ f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\).</p> <p>The binomial distribution is defined as follows for cumulative distribution function:</p> \\[ F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k} \\] <p>where \\(k \\in \\{0, 1, ..., n\\}\\), \\(n \\in \\mathbb{N}\\), and \\(p \\in [0, 1]\\) and \\(\\binom{n}{k}\\) is the binomial coefficient. \\(1 - p\\) is also denoted as \\(q\\). This expression is also known as the regularized incomplete beta function.</p> \\[ F(x;n,p) = I_{1-p}(n-k, k+1) \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>p</code> <code>float</code> <p>The probability of success.</p> required <code>cumulative</code> <code>bool</code> <p>If True, the cumulative distribution function is returned. Defaults to False.</p> <code>False</code> Source code in <code>umf/functions/distributions/discrete_finite_support.py</code> Python<pre><code>class BinomialDistribution(DiscreteP):\nr\"\"\"Binomial distribution.\n    The binomial distribution is a discrete distribution with two possible\n    outcomes, 0 and 1. It is a generalization of the Bernoulli distribution\n    where $n$ trials are conducted.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int)\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x, p=0.5).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,p=0.7).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,p=0.9).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_finite_support import (\n        ... BinomialDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(0, 50, dtype=int )\n        &gt;&gt;&gt; y_05 = BinomialDistribution(x,  p=0.5, cumulative=True).__eval__\n        &gt;&gt;&gt; y_07 = BinomialDistribution(x,  p=0.7, cumulative=True).__eval__\n        &gt;&gt;&gt; y_09 = BinomialDistribution(x,  p=0.9, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_05, label=\"p=0.5\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_07, label=\"p=0.7\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_09, label=\"p=0.9\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"F(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BinomialDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The binomial distribution is defined as follows for probability mass function:\n        $$\n        f(x;n,p) = \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        The binomial distribution is defined as follows for cumulative distribution\n        function:\n        $$\n        F(x;n,p) = \\sum_{k=0}^x \\binom{n}{k} p^k (1-p)^{n-k}\n        $$\n        where $k \\in \\{0, 1, ..., n\\}$, $n \\in \\mathbb{N}$, and $p \\in [0, 1]$ and\n        $\\binom{n}{k}$ is the binomial coefficient. $1 - p$ is also denoted as $q$.\n        This expression is also known as the regularized incomplete beta function.\n        $$\n        F(x;n,p) = I_{1-p}(n-k, k+1)\n        $$\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        p (float): The probability of success.\n        cumulative: If True, the cumulative distribution function is returned.\n            Defaults to False.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, p: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Binomial distribution.\"\"\"\nsuper().__init__(*x, p=p, cumulative=cumulative)\nself.n = np.full_like(self._x, self._x[-1])\nself.k = self._x\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Binomial distribution.\"\"\"\nreturn (\ncombinations(self.n, self.k)\n* self.p**self.k\n* self.q ** (self.n - self.k)\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Binomial distribution.\"\"\"\nreturn np.array(\n[\nnp.sum(\n[\ncombinations(self.n[i], k)\n* self.p**k\n* self.q ** (self.n[i] - k)\nfor k in range(self.k[i] + 1)\n],\n)\nfor i in range(len(self._x))\n],\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Binomial distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=self.n.max() * self.p,\nvariance=self.n.max() * self.p * self.q,\nmode=math.ceil((self.n.max() + 1) * self.p) - 1,\ndoc=self.__doc__,\n)\n</code></pre> <code>n = np.full_like(self._x, self._x[-1])</code> <code>instance-attribute</code> \u00b6 Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/discrete_infinite_support/","title":"Infinite Support","text":""},{"location":"modules/functions/distributions/discrete_infinite_support/#boltzmann-distribution","title":"Boltzmann Distribution","text":"<p>Boltzmann distribution.</p> <p>The Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of energy among particles in a system at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... BoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n&gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n&gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n&gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Boltzmann distribution is defined for the probability mass function as:</p> \\[ F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right) \\] <p>where \\(p_i\\) is the probability of a system being in state \\(i\\), \\(p_j\\) is the probability of a system being in state \\(j\\), \\(\\varepsilon_i\\) is the energy of state \\(i\\), \\(\\varepsilon_j\\) is the energy of state \\(j\\), \\(k\\) is the Boltzmann constant, and \\(T\\) is the temperature.</p> Info <p>For simplicity, the exponentianal term of the Boltzmann factor \\(k\\) is simpflified from  \\(1.380649 \\times 10^{-23}\\) to 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>energy_i</code> <code>float</code> <p>The energy of state \\(i\\).</p> required <code>energy_j</code> <code>float</code> <p>The energy of state \\(j\\).</p> required <code>temperature</code> <code>float</code> <p>The temperature of the system.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class BoltzmannDistribution(DiscretePure):\nr\"\"\"Boltzmann distribution.\n    The Boltzmann distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of energy among particles\n    in a system at a given temperature in statistical mechanics and thermodynamics.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... BoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_12 = BoltzmannDistribution(x, energy_i=1, energy_j=2).__eval__\n        &gt;&gt;&gt; y_13 = BoltzmannDistribution(x, energy_i=1, energy_j=3).__eval__\n        &gt;&gt;&gt; y_31 = BoltzmannDistribution(x, energy_i=3, energy_j=1).__eval__\n        &gt;&gt;&gt; y_21 = BoltzmannDistribution(x, energy_i=2, energy_j=1).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_12, label=r\"$\\frac{p_{1}}{p_{2}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_13, label=r\"$\\frac{p_{1}}{p_{3}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_31, label=r\"$\\frac{p_{3}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_21, label=r\"$\\frac{p_{2}}{p_{1}}$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"Temperature (K)\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$\\frac{p_i}{p_j}$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"BoltzmannDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Boltzmann distribution is defined for the probability mass function as:\n        $$\n        F(x; a) = {\\frac {p_{i}}{p_{j}}}=\\exp \\left({\\frac\n        {\\varepsilon _{j}-\\varepsilon _{i}}{kT}}\\right)\n        $$\n        where $p_i$ is the probability of a system being in state $i$, $p_j$ is the\n        probability of a system being in state $j$, $\\varepsilon_i$ is the energy of\n        state $i$, $\\varepsilon_j$ is the energy of state $j$, $k$ is the Boltzmann\n        constant, and $T$ is the temperature.\n    Info:\n        For simplicity, the exponentianal term of the Boltzmann factor $k$ is\n        simpflified from  $1.380649 \\times 10^{-23}$ to 1.\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        energy_i (float): The energy of state $i$.\n        energy_j (float): The energy of state $j$.\n        temperature (float): The temperature of the system.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nenergy_i: float,\nenergy_j: float,\nk: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Boltzmann distribution.\"\"\"\nif energy_i == energy_j:\nmsg = \"'energy_i' and 'energy_j' cannot be equal.\"\nraise ValueError(msg)\nif energy_i &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_i\",\nnumber=energy_i,\n)\nif energy_j &lt; 0:\nraise NotLargerThanZeroError(\nvar_number=\"energy_j\",\nnumber=energy_j,\n)\nif (min_temp := float(np.min(x))) &lt;= 0:\nraise NotLargerThanZeroError(\nvar_number=\"temperature\",\nnumber=min_temp,\n)\nsuper().__init__(*x)\nself.energy_i = energy_i\nself.energy_j = energy_j\nself.temperature = self._x\nself.k = k\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Boltzmann distribution.\"\"\"\nreturn np.exp(-(self.energy_j - self.energy_i) / (self.k * self.temperature))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Boltzmann distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Mass Function"},{"location":"modules/functions/distributions/discrete_infinite_support/#maxwell-boltzmann-distribution","title":"Maxwell-Boltzmann Distribution","text":"<p>Maxwell-Boltzmann distribution.</p> <p>The Maxwell-Boltzmann distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the speeds of particles in a gas at a given temperature in statistical mechanics and thermodynamics.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... MaxwellBoltzmannDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n&gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n... x,\n... a=1,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n... x,\n... a=2,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n... x,\n... a=3,\n... cumulative=True,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"MaxwellBoltzmannDistribution-cml.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Notes <p>The Maxwell-Boltzmann distribution is defined for the PMF as follows:</p> \\[ F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}} \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>where \\(x\\) is the speed of a particle, \\(a\\) is the most probable speed of \\(a\\), \\(\\pi\\) is the constant pi, and \\(a\\) is a parametrization.</p> <p>The Maxwell-Boltzmann distribution is defined for the CDF as follows:</p> \\[ F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right) -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right) \\] <p>For more informtation about the Maxwell-Boltzmann distribution, see also en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> <code>a(float)</code> <p>A parametrization for the Co-Factors of the Maxwell-Boltzmann distribution.</p> required Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class MaxwellBoltzmannDistribution(DiscretePure):\nr\"\"\"Maxwell-Boltzmann distribution.\n    The Maxwell-Boltzmann distribution is a discrete probability distribution with\n    discrete infinite support. It is used to describe the distribution of the speeds of\n    particles in a gas at a given temperature in statistical mechanics and\n    thermodynamics.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(x, a=1).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(x, a=2).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(x, a=3).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"MaxwellBoltzmannDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... MaxwellBoltzmannDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(0.5, 20, 1000)\n        &gt;&gt;&gt; y_1 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=1,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=2,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = MaxwellBoltzmannDistribution(\n        ... x,\n        ... a=3,\n        ... cumulative=True,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y_1, label=r\"$a=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_2, label=r\"$a=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_3, label=r\"$a=3$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"MaxwellBoltzmannDistribution-cml.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Notes:\n        The Maxwell-Boltzmann distribution is defined for the PMF as follows:\n        $$\n        F(x; a) = \\sqrt {\\frac {2}{\\pi }}\\,{\\frac {x^{2}}{a^{3}}}\n        \\,\\exp \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n        where $x$ is the speed of a particle, $a$ is the most probable speed of $a$,\n        $\\pi$ is the constant pi, and $a$ is a parametrization.\n        The Maxwell-Boltzmann distribution is defined for the CDF as follows:\n        $$\n        F(x; a) = \\operatorname {erf} \\left({\\frac {x}{{\\sqrt {2}}a}}\\right)\n        -{\\sqrt {\\frac {2}{\\pi }}}\\,{\\frac {x}{a}}\\,\\exp\n        \\left({\\frac {-x^{2}}{2a^{2}}}\\right)\n        $$\n        For more informtation about the Maxwell-Boltzmann distribution, see also\n        https://en.wikipedia.org/wiki/Maxwell-Boltzmann_distribution\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n        a(float): A parametrization for the Co-Factors of the Maxwell-Boltzmann\n            distribution.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, a: float, cumulative: bool = False) -&gt; None:\n\"\"\"Initialize the Maxwell-Boltzmann distribution.\"\"\"\nif a &lt;= 0:\nmsg = \"a\"\nraise NotAPositiveNumberError(msg, a)\nsuper().__init__(*x, cumulative=cumulative)\nself.a = a\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn (\nnp.sqrt(2 / np.pi)\n* (self._x**2 / self.a**3)\n* np.exp(-self._x**2 / (2 * self.a**2))\n)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Maxwell-Boltzmann distribution.\"\"\"\nreturn erf(self._x / (np.sqrt(2) * self.a)) - np.sqrt(\n2 / np.pi,\n) * self._x / self.a * np.exp(-self._x**2 / (2 * self.a**2))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Maxwell-Boltzmann distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=2 * np.sqrt(2 / np.pi) * self.a,\nvariance=(self.a**2 * (3 * np.pi - 8)) / (np.pi),\nmode=np.sqrt(2) * self.a,\ndoc=self.__doc__,\n)\n</code></pre> Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/discrete_infinite_support/#gaus-kuzmin-distribution","title":"Gaus Kuzmin Distribution","text":"<p>Gaus-Kuzmin distribution.</p> <p>The Gaus-Kuzmin distribution is a discrete probability distribution with discrete infinite support. It is used to describe the distribution of the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PMF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # CDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n... GausKuzminDistribution\n... )\n&gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n&gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot(111)\n&gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Gaus-Kuzmin distribution is defined for the PMF as follows:</p> \\[ F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right] \\] <p>where \\(k\\) is the number of steps taken by a random walker on a line before reaching a given distance from the origin.</p> <p>The Gaus-Kuzmin distribution is defined for the CDF as follows:</p> \\[ F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right) \\] <p>For more information about the Gaus-Kuzmin distribution, see also en.wikipedia.org/wiki/Gauss-Kuzmin_distribution</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> <code>()</code> Source code in <code>umf/functions/distributions/discrete_infinite_support.py</code> Python<pre><code>class GausKuzminDistribution(DiscretePure):\nr\"\"\"Gaus-Kuzmin distribution.\n    The Gaus-Kuzmin distribution is a discrete probability distribution with discrete\n    infinite support. It is used to describe the distribution of the number of steps\n    taken by a random walker on a line before reaching a given distance from the origin.\n    Examples:\n        &gt;&gt;&gt; # PMF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$p$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$p$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution.png\", dpi=300, transparent=True)\n        &gt;&gt;&gt; # CDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.discrete_infinite_support import (\n        ... GausKuzminDistribution\n        ... )\n        &gt;&gt;&gt; x = np.arange(1, 100, dtype=int)\n        &gt;&gt;&gt; y = GausKuzminDistribution(x, cumulative=True).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot(111)\n        &gt;&gt;&gt; _  = ax.plot(x, y, label=r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(r\"$F(x)$\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"GausKuzminDistribution-cml.png\", dpi=300, transparent=True)\n    Notes:\n        The Gaus-Kuzmin distribution is defined for the PMF as\n        follows:\n        $$\n        F(x) = -\\log _{2}\\left[1-{\\frac  {1}{(x+1)^{2}}}\\right]\n        $$\n        where $k$ is the number of steps taken by a random walker on a line before\n        reaching a given distance from the origin.\n        The Gaus-Kuzmin distribution is defined for the CDF as follows:\n        $$\n        F(x) = 1-\\log _{2}\\left({\\frac  {x+2}{x+1}}\\right)\n        $$\n        For more information about the Gaus-Kuzmin distribution, see also\n        &lt;https://en.wikipedia.org/wiki/Gauss-Kuzmin_distribution&gt;\n    Args:\n        *x (UniversalArray): The value(s) at which the function is evaluated.\n    \"\"\"\ndef probability_mass_function(self) -&gt; UniversalArray:\n\"\"\"Probability mass function of the Gaus-Kuzmin distribution.\"\"\"\nreturn -np.log2(1 - 1 / (self._x + 1) ** 2)\ndef cumulative_distribution_function(self) -&gt; UniversalArray:\n\"\"\"Cumulative distribution function of the Gaus-Kuzmin distribution.\"\"\"\nreturn 1 - np.log2((self._x + 2) / (self._x + 1))\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Gaus-Kuzmin distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=np.inf,\nvariance=np.inf,\nmode=1,\ndoc=self.__doc__,\n)\n</code></pre> Probability Mass Function Cumulative Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/","title":"Mixed Distribution","text":""},{"location":"modules/functions/distributions/mixed_discrete_continuous/#crystal-ball-distribution","title":"Crystal Ball Distribution","text":"<p>Crystal Ball distribution.</p> <p>The Crystal Ball distribution, which is sometimes also called the Crystal Ball function, is a continuous but asymmetric probability distribution on the real line.[^1] This type of function is often used in physics to model the invariant mass of a particle or system of particles, especially when there is a known background contribution.[^2]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... CrystalBallDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n&gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n&gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n&gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n&gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n&gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _  = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Crystal Ball distribution is defined as follows for probability density</p> \\[ f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{ \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }} \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha \\end{cases}} \\] <p>with:</p> \\[ A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right| \\] \\[ N={\\frac  {1}{\\sigma (C+D)}} \\] \\[ C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}} \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right) \\] \\[ D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf} \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right) \\] <p>See also: www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/ crystalball.html</p> <p>About the Normalization</p> <p>The normalization constant \\(N\\) might be not correct implemented because for the zero-division case \\(n=1\\) the normalization constant \\(N\\) is set to one to achieve a optical match with the reference figures of <sup>1</sup>.</p> <ol> <li> <p>Crystal Ball function. (2020, November 27). In Wikipedia. en.wikipedia.org/wiki/Crystal_Ball_function \u21a9</p> </li> <li> <p>Tomasz Skwarnicki, A study of the radiative CASCADE transitions between _ the Upsilon-Prime and Upsilon resonances_, PHD-Thesis, DESY-F31-86-02, Apr. 1986\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the Gaussian region.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the Gaussian region.</p> <code>1</code> <code>n</code> <code>float</code> <p>The power of the power-law region.</p> <code>1</code> <code>alpha</code> <code>float</code> <p>: The location of the transition between the Gaussian and power-law regions.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class CrystalBallDistribution(ContinuousWSigma):\nr\"\"\"Crystal Ball distribution.\n    The Crystal Ball distribution, which is sometimes also called the Crystal\n    Ball function, is a continuous but asymmetric probability distribution on the real\n    line.[^1] This type of function is often used in physics to model the invariant\n    mass of a particle or system of particles, especially when there is a known\n    background contribution.[^2]\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... CrystalBallDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-25, 5, 1000)\n        &gt;&gt;&gt; y_111 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_211 = CrystalBallDistribution(x, mu=0, sigma=2, n=1, alpha=1).__eval__\n        &gt;&gt;&gt; y_121 = CrystalBallDistribution(x, mu=0, sigma=1, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_221 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=1).__eval__\n        &gt;&gt;&gt; y_112 = CrystalBallDistribution(x, mu=0, sigma=1, n=1, alpha=2).__eval__\n        &gt;&gt;&gt; y_222 = CrystalBallDistribution(x, mu=0, sigma=2, n=2, alpha=2).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _  = ax.plot(x, y_111, label=r\"$\\sigma=1, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_211, label=r\"$\\sigma=2, n=1, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_121, label=r\"$\\sigma=1, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_221, label=r\"$\\sigma=2, n=2, \\alpha=1$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_112, label=r\"$\\sigma=1, n=1, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.plot(x, y_222, label=r\"$\\sigma=2, n=2, \\alpha=2$\")\n        &gt;&gt;&gt; _  = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _  = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _  = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"CrystalBallDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Crystal Ball distribution is defined as follows for probability density\n        [^2]:\n        $$\n        f(x;\\alpha ,n,{\\bar {x}},\\sigma )=N\\cdot {\\begin{cases}\\exp\n        \\left(-{\\frac {(x-{\\bar {x}})^{2}}{2\\sigma ^{2}}}\\right),&amp;{\\mbox{for }}{\n        \\frac {x-{\\bar {x}}}{\\sigma }}&gt;-\\alpha \\\\A\\cdot\n        \\left(B-{\\frac {x-{\\bar {x}}}{\\sigma }}\n        \\right)^{-n},&amp;{\\mbox{for }}{\\frac {x-{\\bar {x}}}{\\sigma }}\\leqslant -\\alpha\n        \\end{cases}}\n        $$\n        with:\n        $$\n        A=\\left({\\frac  {n}{\\left|\\alpha \\right|}}\\right)^{n}\\cdot \\exp\n        \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n        $$\n        B={\\frac  {n}{\\left|\\alpha \\right|}}-\\left|\\alpha \\right|\n        $$\n        $$\n        N={\\frac  {1}{\\sigma (C+D)}}\n        $$\n        $$\n        C={\\frac  {n}{\\left|\\alpha \\right|}}\\cdot {\\frac  {1}{n-1}}\n        \\cdot \\exp \\left(-{\\frac  {\\left|\\alpha \\right|^{2}}{2}}\\right)\n        $$\n        $$\n        D={\\sqrt  {{\\frac  {\\pi }{2}}}}\\left(1+\\operatorname {erf}\n        \\left({\\frac  {\\left|\\alpha \\right|}{{\\sqrt  2}}}\\right)\\right)\n        $$\n        See also: https://www.jlab.org/primex/weekly_meetings/slides_2009_07_17/dmitry/\n        crystalball.html\n        !!! warning \"About the Normalization\"\n            The normalization constant $N$ might be not correct implemented because\n            for the zero-division case $n=1$ the normalization constant $N$ is set to\n            one to achieve a optical match with the reference figures of [^2].\n        [^1]: Tomasz Skwarnicki, _A study of the radiative CASCADE transitions between_\n            _ the Upsilon-Prime and Upsilon resonances_, **PHD-Thesis**, DESY-F31-86-02,\n            Apr. 1986\n        [^2]: Crystal Ball function. (2020, November 27). _In Wikipedia._\n            https://en.wikipedia.org/wiki/Crystal_Ball_function\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the Gaussian region.\n        sigma (float): The standard deviation of the Gaussian region.\n        n (float): The power of the power-law region.\n        alpha (float):: The location of the transition between the Gaussian and\n            power-law regions.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\nn: float = 1,\nalpha: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Crystal Ball distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nif n &lt;= 0:\nraise NotLargerThanZeroError(number=n)\nif alpha &lt; 0:\nraise NotLargerThanZeroError(number=alpha)\nself.n = n\nself.alpha = alpha\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Crystal Ball distribution.\"\"\"\n_a = (self.n / abs(self.alpha)) ** self.n * np.exp(\n-(self.alpha**2) / 2,\n)\n_b = self.n / abs(self.alpha) - abs(self.alpha)\nif self.n == 1:\n_n = self.n\nelse:\n_c = (\nself.n / abs(self.alpha) / (self.n - 1) * np.exp(-(self.alpha**2) / 2)\n)\n_d = np.sqrt(np.pi / 2) * (1 + erf(x=abs(self.alpha) / np.sqrt(2)))\n_n = 1 / (self.sigma * (_c + _d))\nreturn np.where(\n(self._x - self.mu) / self.sigma &gt; -self.alpha,\n_n * np.exp(-((self._x - self.mu) ** 2) / (2 * self.sigma**2)),\n_n * _a * (_b - (self._x - self.mu) / self.sigma) ** (-self.n),\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Crystal Ball distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> <code>n = n</code> <code>instance-attribute</code> \u00b6 Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#pearson-type-vii-distribution","title":"Pearson Type VII Distribution","text":"<p>Pearson VII distribution.</p> <p>The Pearson VII distribution is a continuous probability distribution on the real line. It is a generalization of the Student's t-distribution and the Cauchy distribution. This function becomes popular for X-ray diffraction data analysis.[^1]</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... PearsonVIIDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n&gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n&gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n&gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n&gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n&gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Pearson VII distribution is defined as follows for probability density</p> \\[ f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)} {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+ \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}} \\] <p><sup>1</sup> Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.     Journal of Applied Crystalography, 31(3), 474-476.     doi.org/10.1107/S0021889897011047</p> <p>See also: en.wikipedia.org/wiki/Pearson_distribution and www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>p</code> <code>float</code> <p>The shape parameter of the distribution.</p> <code>1</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class PearsonVIIDistribution(ContinuousWSigma):\nr\"\"\"Pearson VII distribution.\n    The Pearson VII distribution is a continuous probability distribution on the real\n    line. It is a generalization of the Student's t-distribution and the Cauchy\n    distribution. This function becomes popular for X-ray diffraction data analysis.[^1]\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... PearsonVIIDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = PearsonVIIDistribution(x, mu=0, sigma=1, p=1).__eval__\n        &gt;&gt;&gt; y_2 = PearsonVIIDistribution(x, mu=0, sigma=1, p=2).__eval__\n        &gt;&gt;&gt; y_3 = PearsonVIIDistribution(x, mu=0, sigma=1, p=3).__eval__\n        &gt;&gt;&gt; y_4 = PearsonVIIDistribution(x, mu=0, sigma=1, p=4).__eval__\n        &gt;&gt;&gt; y_5 = PearsonVIIDistribution(x, mu=0, sigma=1, p=5).__eval__\n        &gt;&gt;&gt; y_6 = PearsonVIIDistribution(x, mu=0, sigma=1, p=6).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$p=1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$p=2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$p=3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$p=4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$p=5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$p=6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"PearsonVIIDistribution.png\", dpi=300, transparent=True)\n    Notes:\n        The Pearson VII distribution is defined as follows for probability density\n        [^1]:\n        $$\n        f(x;\\mu ,\\sigma ,p)=\\frac {\\Gamma \\left({\\frac {p}{2}}\\right)}\n        {\\sigma {\\sqrt {\\pi }}\\,\\Gamma \\left({\\frac {p-1}{2}}\\right)}\\left[1+\n        \\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}\\right]^{-{\\frac {p}{2}}}\n        $$\n        [^1] Gupta, S. K. (1998). Peak Decomposition using Pearson Type VII Function.\n            Journal of Applied Crystalography, 31(3), 474-476.\n            https://doi.org/10.1107/S0021889897011047\n        See also: https://en.wikipedia.org/wiki/Pearson_distribution and\n        https://www.originlab.com/doc/Origin-Help/PearsonVII-FitFunc\n    Args:\n        *x (UniversalArray): The points at which to evaluate the distribution.\n        mu (float): The mean of the distribution.\n        sigma (float): The standard deviation of the distribution.\n        p (float): The shape parameter of the distribution.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nmu: float = 0,\nsigma: float = 1,\np: float = 1,\n) -&gt; None:\n\"\"\"Initialize the Pearson VII distribution.\"\"\"\nsuper().__init__(*x, mu=mu, sigma=sigma)\nself.p = p\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Pearson VII distribution.\"\"\"\nreturn (\ngammaln(self.p / 2)\n/ (self.sigma * np.sqrt(np.pi) * gammaln((self.p - 1) / 2))\n* (1 + ((self._x - self.mu) / self.sigma) ** 2) ** (-self.p / 2)\n)\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Pearson VII distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#asymmetric-raman-lineshape-distribution","title":"Asymmetric Raman Lineshape Distribution","text":"<p>Asymmetric Raman lineshape distribution.</p> <p>The Asymmetric Raman lineshape distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for Raman spectroscopy data analysis.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... AsymmetricRamanLineshape\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Asymmetric Raman lineshape distribution is defined as follows for probability density [^1]:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma)) \\] <p>with the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\) and the damped sigmoidal term \\(p(x)\\):</p> \\[ p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right) \\] <p>[^1] Korepanov, V, I.and Sedlovets, D. M. (2018),     An asymmetric fitting function for condensed-phase Raman spectroscopy,     Analyst RSC, 2674-2679 (143)     dx.doi.org/10.1039/C8AN00710A</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class AsymmetricRamanLineshape(ContinousAsymmetricPseudo):\nr\"\"\"Asymmetric Raman lineshape distribution.\n    The Asymmetric Raman lineshape distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for Raman spectroscopy data analysis.\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... AsymmetricRamanLineshape\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = AsymmetricRamanLineshape(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\"AsymmetricRamanLineshape.png\", dpi=300, transparent=True)\n    Notes:\n        The Asymmetric Raman lineshape distribution is defined as follows for\n        probability density [^1]:\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)=(1 - \\eta) \\cdot \\textrm{Gauss}(x \\cdot\n        p(x; \\gamma)) + \\eta \\cdot \\textrm{Lorentzian}(x \\cdot p(x; \\gamma))\n        $$\n        with the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$ and the\n        damped sigmoidal term $p(x)$:\n        $$\n        p(x; \\gamma) = 1 - \\gamma \\cdot \\frac{x-\\mu}{\\sigma} \\cdot\n        \\exp \\left(-\\frac{(x-\\mu)^2}{2 \\sigma^2}\\right)\n        $$\n        [^1] Korepanov, V, I.and Sedlovets, D. M. (2018),\n            An asymmetric fitting function for condensed-phase Raman spectroscopy,\n            Analyst RSC, 2674-2679 (143)\n            http://dx.doi.org/10.1039/C8AN00710A\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Asym. Raman lineshape distribution.\"\"\"\np = 1 - self.gamma * (self._x - self.mu) / self.sigma * np.exp(\n-((self._x - self.mu) ** 2) / (2 * self.sigma**2),\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x * p,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Asym. Raman lineshape distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/distributions/mixed_discrete_continuous/#modified-doniach-sunjic-distribution","title":"Modified Doniach-Sunjic Distribution","text":"<p>Doniach-Sunjic distribution.</p> <p>The Doniach-Sunjic distribution is a continuous probability, which is a modified version of the Pseudo-Voigt distribution. It is a convolution of a Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal term.[^1] This function becomes popular for XPS/AES data analysis. See also: www.casaxps.com</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # PDF Example\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n... ModifiedDoniachSunjicDistribution\n... )\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.1\n... ).__eval__\n&gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.2,\n... gamma=0.2\n... ).__eval__\n&gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.3,\n... ).__eval__\n&gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.3,\n... gamma=0.4,\n... ).__eval__\n&gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.5,\n... ).__eval__\n&gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n... x,\n... mu=0,\n... sigma=1,\n... eta=0.5,\n... gamma=0.6,\n... ).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = plt.subplot()\n&gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n&gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n&gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n&gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n&gt;&gt;&gt; _ = ax.legend()\n&gt;&gt;&gt; plt.savefig(\n... \"ModifiedDoniachSunjicDistribution.png\",\n... dpi=300,\n... transparent=True,\n... )\n</code></pre> Warning <p>The Doniach-Sunjic distribution as defined for casaxps is not the same as used in the current implementation. In the current implementation, the damping factor is included into the lorentzian model.</p> Notes <p>The Doniach-Sunjic distribution is defined as follows for probability density:</p> \\[ f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma)) \\] <p>with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal is defined as:</p> \\[ p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\ 0 &amp; \\text{if } x \\geq \\mu \\end{cases} \\] <p>and the mixing parameter \\(\\eta\\) in the range \\(0 \\leq \\eta \\leq 1\\). See also: www.casaxps.com/help_manual/line_shapes.htm</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>The points at which to evaluate the distribution.</p> <code>()</code> <code>mu</code> <code>float</code> <p>The mean of the distribution.</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The standard deviation of the distribution.</p> <code>1</code> <code>eta</code> <code>float</code> <p>The mixing parameter of the distribution.</p> <code>0.5</code> <code>gamma</code> <code>float</code> <p>The damping parameter of the distribution.</p> <code>0.0</code> Source code in <code>umf/functions/distributions/mixed_discrete_continuous.py</code> Python<pre><code>class ModifiedDoniachSunjicDistribution(ContinousAsymmetricPseudo):\nr\"\"\"Doniach-Sunjic distribution.\n    The Doniach-Sunjic distribution is a continuous probability, which is\n    a modified version of the Pseudo-Voigt distribution. It is a convolution of a\n    Gaussian distribution and a Lorentzian distribution plus a damped sigmoidal\n    term.[^1] This function becomes popular for XPS/AES data analysis. See also:\n    http://www.casaxps.com\n    Examples:\n        &gt;&gt;&gt; # PDF Example\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.distributions.mixed_discrete_continuous import (\n        ... ModifiedDoniachSunjicDistribution\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y_1 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.1\n        ... ).__eval__\n        &gt;&gt;&gt; y_2 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.2,\n        ... gamma=0.2\n        ... ).__eval__\n        &gt;&gt;&gt; y_3 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.3,\n        ... ).__eval__\n        &gt;&gt;&gt; y_4 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.3,\n        ... gamma=0.4,\n        ... ).__eval__\n        &gt;&gt;&gt; y_5 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.5,\n        ... ).__eval__\n        &gt;&gt;&gt; y_6 = ModifiedDoniachSunjicDistribution(\n        ... x,\n        ... mu=0,\n        ... sigma=1,\n        ... eta=0.5,\n        ... gamma=0.6,\n        ... ).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = plt.subplot()\n        &gt;&gt;&gt; _ = ax.plot(x, y_1, label=r\"$\\eta=0.2$, $\\gamma=0.1$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_2, label=r\"$\\eta=0.2$, $\\gamma=0.2$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_3, label=r\"$\\eta=0.3$, $\\gamma=0.3$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_4, label=r\"$\\eta=0.3$, $\\gamma=0.4$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_5, label=r\"$\\eta=0.5$, $\\gamma=0.5$\")\n        &gt;&gt;&gt; _ = ax.plot(x, y_6, label=r\"$\\eta=0.5$, $\\gamma=0.6$\")\n        &gt;&gt;&gt; _ = ax.set_xlabel(\"x\")\n        &gt;&gt;&gt; _ = ax.set_ylabel(\"f(x)\")\n        &gt;&gt;&gt; _ = ax.legend()\n        &gt;&gt;&gt; plt.savefig(\n        ... \"ModifiedDoniachSunjicDistribution.png\",\n        ... dpi=300,\n        ... transparent=True,\n        ... )\n    Warning:\n        The Doniach-Sunjic distribution as defined for **casaxps** is not the same as\n        used in the current implementation. In the current implementation, the damping\n        factor is included into the lorentzian model.\n    Notes:\n        The Doniach-Sunjic distribution is defined as follows for probability density:\n        $$\n        f(x;\\mu ,\\sigma ,\\eta, \\gamma)= GL(x) + (1 - GL(x) \\cdot p(x; \\gamma))\n        $$\n        with GL(x) as the Gaussian-Lorentzian mixture function and the damped sigmoidal\n        is defined as:\n        $$\n        p(x; \\gamma) = \\begin{cases} \\exp \\left(- \\gamma \\cdot\n        \\frac{(x-\\mu)}{2 \\sigma^2}\\right) &amp; \\text{if } x &lt; \\mu \\\\\n        0 &amp; \\text{if } x \\geq \\mu \\end{cases}\n        $$\n        and the mixing parameter $\\eta$ in the range $0 \\leq \\eta \\leq 1$.\n        See also: http://www.casaxps.com/help_manual/line_shapes.htm\n    Args:\n        *x: The points at which to evaluate the distribution.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution.\n        eta: The mixing parameter of the distribution.\n        gamma: The damping parameter of the distribution.\n    \"\"\"\ndef probability_density_function(self) -&gt; UniversalArray:\n\"\"\"Probability density function of the Doniach-Sunjic distribution.\"\"\"\np = np.where(\nself._x &lt; self.mu,\nnp.exp(-self.gamma * (self._x - self.mu) / (2 * self.sigma**2)),\n0,\n)\nreturn (1 - self.eta) * GaussianDistribution(\nself._x,\nmu=self.mu,\nsigma=self.sigma,\n).probability_density_function() + self.eta * LorentzianDistribution(\nself._x * p,\nmu=self.mu,\ngamma=self.sigma,\n).probability_density_function()\n@property\ndef __summary__(self) -&gt; SummaryStatisticsAPI:\n\"\"\"Summary statistics of the Doniach-Sunjic distribution.\"\"\"\nreturn SummaryStatisticsAPI(\nmean=None,\nvariance=None,\nmode=None,\ndoc=self.__doc__,\n)\n</code></pre> Probability Density Function"},{"location":"modules/functions/optimization/bowl_shaped/","title":"Bowl Shaped","text":""},{"location":"modules/functions/optimization/bowl_shaped/#perm-beta-d-function","title":"Perm Beta D function","text":"<p>Perm Beta D function.</p> <p>The Perm Beta D function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Perm Beta D function is defined as:</p> \\[     f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +     \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2 \\] <p>with constant \\(\\beta = 0.5\\) and \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class PermBetaDFunction(OptFunction):\nr\"\"\"Perm Beta D function.\n    The Perm Beta D function is a D-dimensional function with multimodal structure\n    and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import PermBetaDFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PermBetaDFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PermBetaDFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Perm Beta D function is defined as:\n        $$\n            f(x) =  \\sum_{i=1}^D \\left( \\sum_{j=1}^D \\frac{1}{j +\n            \\beta} \\left( \\frac{x_j}{j} \\right)^i  -1 \\right)^2\n        $$\n        with constant $\\beta = 0.5$ and $D$ the dimension of the input. The hypercube\n        of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Perm Beta D function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nbeta = 0.5\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = sum(\n(j**i + beta) * ((self._x[j - 1] / j) ** i - 1)\nfor j in range(1, self.dimension + 1)\n)\nouter_sum += inner_sum**2\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Perm Beta D function.\n        Returns:\n            MinimaAPI: Minima of the Perm Beta D function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.arange(1, self.dimension + 1)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#trid-function","title":"Trid Function","text":"<p>Trid function.</p> <p>The Trid function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Trid function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class TridFunction(OptFunction):\nr\"\"\"Trid function.\n    The Trid function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import TridFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = TridFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"TridFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Trid function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left( x_i - 1 \\right)^2 - \\sum_{i=2}^D x_i x_{i-1}\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/trid.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Trid function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = (self._x[i - 1] - 1) ** 2 - self._x[i - 1] * self._x[i - 2]\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Trid function.\n        Returns:\n            MinimaAPI: Minima of the Trid function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-self.dimension * (self.dimension + 4) * (self.dimension - 1) / 6,\nx=tuple(i * (self.dimension + 1 - i) for i in range(1, self.dimension + 1)),\n)\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sum-squares-function","title":"Sum Squares Function","text":"<p>Sum squares function.</p> <p>The Sum squares function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum squares function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D i x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumSquaresFunction(OptFunction):\nr\"\"\"Sum squares function.\n    The Sum squares function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SumSquaresFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumSquaresFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumSquaresFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sum squares function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D i x_i^2\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/sumsqu.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sum squares function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = i * self._x[i - 1] ** 2\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sum squares function.\n        Returns:\n            MinimaAPI: Minima of the Sum squares function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sum-of-different-power-function","title":"Sum of Different Power Function","text":"<p>Sum of different powers function.</p> <p>The Sum of different powers function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... SumOfDifferentPowersFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sum of different powers function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1} \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>_Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SumOfDifferentPowersFunction(OptFunction):\nr\"\"\"Sum of different powers function.\n    The Sum of different powers function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... SumOfDifferentPowersFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SumOfDifferentPowersFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SumOfDifferentPowersFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sum of different powers function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left| x_i \\right|^{i+1}\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        _Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/sumpow.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sum of different powers function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(1, self.dimension + 1):\ninner_sum = abs(self._x[i - 1]) ** (i + 1)\nouter_sum += inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sum of different powers function.\n        Returns:\n            MinimaAPI: Minima of the Sum of different powers function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#zirilli-function","title":"Zirilli Function","text":"<p>Zirilli function.</p> <p>The Zirilli function is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zirilli function is defined as:</p> \\[     f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2 \\] <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class ZirilliFunction(OptFunction):\nr\"\"\"Zirilli function.\n    The Zirilli function is a 2D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import ZirilliFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZirilliFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZirilliFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zirilli function is defined as:\n        $$\n            f(x) = 0.25 x_1^4 - 0.5 x_1^2 + 0.1 x_1 + 0.5 x_2^2\n        $$\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Zirilli\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Zirilli function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 0.25 * x_1**4 - 0.5 * x_1**2 + 0.1 * x_1 + 0.5 * x_2**2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zirilli function.\n        Returns:\n            MinimaAPI: Minima of the Zirilli function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-0.352386073800034,\nx=(-1.046680576580755, 0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#sphere-function","title":"Sphere Function","text":"<p>Sphere function.</p> <p>The Sphere function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Sphere function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D x_i^2 \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class SphereFunction(OptFunction):\nr\"\"\"Sphere function.\n    The Sphere function is a D-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import SphereFunction\n        &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-2.5, 2.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SphereFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SphereFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Sphere function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D x_i^2\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined as\n        $x_i \\in [-d, d]$ for all $i$.\n        Reference: Original implementation can be found\n        [here](http://www.sfu.ca/~ssurjano/spheref.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Sphere function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn np.sum(np.power(self._x, 2), axis=0)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Sphere function.\n        Returns:\n            MinimaAPI: Minima of the Sphere function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#rotated-hyper-ellipsoid-function","title":"Rotated Hyper-Ellipsoid Function","text":"<p>Rotated hyper-ellipse function.</p> <p>The Rotated hyper-ellipse function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n... RotatedHyperEllipseFunction\n... )\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rotated hyper-ellipse function is defined as:</p> \\[     f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2 \\] <p>with \\(D\\) the dimension of the input and \\(a_{ij}\\) the rotation matrix. The hypercube of the function is defined as \\(x_i \\in [-d, d]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class RotatedHyperEllipseFunction(OptFunction):\nr\"\"\"Rotated hyper-ellipse function.\n    The Rotated hyper-ellipse function is a D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import (\n        ... RotatedHyperEllipseFunction\n        ... )\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RotatedHyperEllipseFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RotatedHyperEllipseFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rotated hyper-ellipse function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^D \\left( \\sum_{j=1}^D a_{ij} x_j^2 \\right)^2\n        $$\n        with $D$ the dimension of the input and $a_{ij}$ the rotation matrix. The\n        hypercube of the function is defined as $x_i \\in [-d, d]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/rothyp.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"RotatedHyperEllipse\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rotated hyper-ellipse function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nouter_sum = np.zeros(self._x[0].shape)\nfor i in range(self.dimension):\ninner_sum = np.zeros(self._x[0].shape)\nfor j in range(i + 1):\ninner_sum += self._x[j] ** 2\nouter_sum = outer_sum + inner_sum\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Rotated hyper-ellipse function.\n        Returns:\n            MinimaAPI: Minima of the Rotated hyper-ellipse function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros(self.dimension)))\n</code></pre> <p>Reference: Original implementation can be found here</p>"},{"location":"modules/functions/optimization/bowl_shaped/#bohachevsky-function-type-1","title":"Bohachevsky Function Type 1","text":"<p>Bohachevsky function type 1.</p> <p>The Bohachevsky function type 1 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 1 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType1(OptFunction):\nr\"\"\"Bohachevsky function type 1.\n    The Bohachevsky function type 1 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType1\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType1(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType1.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 1 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) - 0.4 \\cos(4 \\pi x_2) + 0.7\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType1\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 1 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1)\n- 0.4 * np.cos(4 * np.pi * x_2)\n+ 0.7\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 1.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 1.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#bohachevsky-function-type-2","title":"Bohachevsky Function Type 2","text":"<p>Bohachevsky function tye 2.</p> <p>The Bohachevsky function type 2 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 2 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType2(OptFunction):\nr\"\"\"Bohachevsky function tye 2.\n    The Bohachevsky function type 2 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType2\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType2(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType2.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 2 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1) \\cos(4 \\pi x_2) + 0.3\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 2 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1) * np.cos(4 * np.pi * x_2)\n+ 0.3\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 2.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 2.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/bowl_shaped/#bochachevsky-function-type-3","title":"Bochachevsky Function Type 3","text":"<p>Bohachevsky function type 3.</p> <p>The Bohachevsky function type 3 is a 2D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bohachevsky function type 3 is defined as:</p> \\[     f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3 \\] <p>Reference: Original implementation can be found here</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/bowl_shaped.py</code> Python<pre><code>class BohachevskyFunctionType3(OptFunction):\nr\"\"\"Bohachevsky function type 3.\n    The Bohachevsky function type 3 is a 2D-dimensional function with multimodal\n    structure and sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.bowl_shaped import BohachevskyFunctionType3\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BohachevskyFunctionType3(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BohachevskyFunctionType3.png\", dpi=300, transparent=True)\n    Notes:\n        The Bohachevsky function type 3 is defined as:\n        $$\n            f(x) = x_1^2 + 2 x_2^2 - 0.3 \\cos(3 \\pi x_1 + 4 \\pi x_2) + 0.3\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/boha.html)\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"BohachevskyType3\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bohachevsky function type 3 at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\nx_1**2\n+ 2 * x_2**2\n- 0.3 * np.cos(3 * np.pi * x_1 + 4 * np.pi * x_2)\n+ 0.3\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Bohachevsky function type 3.\n        Returns:\n            MinimaAPI: Minima of the Bohachevsky function type 3.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/","title":"Drops Steps","text":""},{"location":"modules/functions/optimization/drops_steps/#de-jong-n-5-function","title":"De Jong N. 5 Function","text":"<p>De Jong N.5 Function.</p> <p>The De Jong N.5 function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n&gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The De Jong N.5 function is defined as:</p> \\[     f(x, y) = \\left(         0.0002 + \\sum_{i=1}^{25}         \\frac{1}{             i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6         }     \\right)^{-1} \\] <p>where</p> \\[     a = \\left(         \\begin{matrix}         -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\         -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32         \\end{matrix}         \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  adddimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Elements of the matrix a, which has to become are 2-dimensional with shape (2, 25). Defaults to None.</p> <code>None</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class DeJongN5Function(OptFunction):\nr\"\"\"De Jong N.5 Function.\n    The De Jong N.5 function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import DeJongN5Function\n        &gt;&gt;&gt; x = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; y = np.linspace(-65.536, 65.536, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DeJongN5Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DeJongN5Function.png\", dpi=300, transparent=True)\n    Notes:\n        The De Jong N.5 function is defined as:\n        $$\n            f(x, y) = \\left(\n                0.0002 + \\sum_{i=1}^{25}\n                \\frac{1}{\n                    i + \\left(x_1 - a_{1i} \\right)^6 + \\left(x_2 - a_{2i} \\right)^6\n                }\n            \\right)^{-1}\n        $$\n        where\n        $$\n            a = \\left(\n                \\begin{matrix}\n                -32 &amp; -16 &amp; 0   &amp; 16  &amp; 32  &amp; ... &amp; -16 &amp; 0 &amp; 16 &amp; 32 \\\\\n                -32 &amp; -32 &amp; -32 &amp; -32 &amp; -32 &amp; ... &amp; 32 &amp; 32 &amp; 32 &amp; 32\n                \\end{matrix}\n                \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/dejong5.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             adddimensional.\n        A (UniversalArray, optional): Elements of the matrix a, which has to become are\n            2-dimensional with shape (2, 25). Defaults to None.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray | None = None,  # noqa: N803\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"De Jong N.5\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\nif A is None:\nrow_1 = matlib.repmat(np.arange(-32, 33, 16), 1, 5)\nrow_2 = matlib.repmat(np.arange(-32, 33, 16), 5, 1).T.ravel()\nself.a_matrix = np.vstack((row_1, row_2))\nelif A.shape != (2, 25):\nmsg = \"The shape of a has to be (2, 25).\"\nraise ValueError(msg)\nelse:\nself.a_matrix = A\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the De Jong N.5 function.\n        Returns:\n            UniversalArray: The value of the De Jong N.5 function.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\na_1 = self.a_matrix[0, :]\na_2 = self.a_matrix[1, :]\nsum_ = np.zeros_like(x_1)\nfor i in range(25):\nsum_ += 1 / ((i + 1) + (x_1 - a_1[i]) ** 6 + (x_2 - a_2[i]) ** 6)\nreturn (0.0002 + sum_) ** -1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the De Jong N.5 function.\n        Returns:\n            MinimaAPI: The minima of the De Jong N.5 function.\n        \"\"\"\nreturn MinimaAPI(f_x=0.0, x=(0.0, 0.0))\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/#easom-function","title":"Easom Function","text":"<p>Easom Function.</p> <p>The Easom function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Easom function is defined as:</p> \\[     f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2     - \\left(y-\\pi\\right)^2\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class EasomFunction(OptFunction):\nr\"\"\"Easom Function.\n    The Easom function is a two-dimensional function with a single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import EasomFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EasomFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EasomFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Easom function is defined as:\n        $$\n            f(x, y) = -\\cos(x)\\cos(y)\\exp\\left(-\\left(x-\\pi\\right)^2\n            - \\left(y-\\pi\\right)^2\\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/easom.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Easom\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Easom function.\n        Returns:\n            UniversalArray: The value of the Easom function.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.array(\n-np.cos(x_1)\n* np.cos(x_2)\n* np.exp(-((x_1 - np.pi) ** 2) - (x_2 - np.pi) ** 2),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Easom function.\n        Returns:\n            MinimaAPI: The minima of the Easom function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-1.0,\nx=np.array([np.pi, np.pi]),\n)\n</code></pre>"},{"location":"modules/functions/optimization/drops_steps/#michalewicz-function","title":"Michalewicz Function","text":"<p>Michalewicz Function.</p> <p>The Michalewicz function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Michalewicz function is defined as:</p> \\[     f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>m</code> <code>int</code> <p>The m parameter. Defaults to 10.</p> <code>10</code> Source code in <code>umf/functions/optimization/drops_steps.py</code> Python<pre><code>class MichalewiczFunction(OptFunction):\nr\"\"\"Michalewicz Function.\n    The Michalewicz function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.drops_steps import MichalewiczFunction\n        &gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, np.pi, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MichalewiczFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MichalewiczFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Michalewicz function is defined as:\n        $$\n            f(x, y) = -\\sum_{i=1}^{2}\\sin(x_i)\\sin^2\\left(\\frac{i x_i^2}{\\pi}\\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](http://www.sfu.ca/~ssurjano/michal.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        m (int, optional): The m parameter. Defaults to 10.\n    \"\"\"\ndef __init__(self, *x: UniversalArray, m: int = 10) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself.m = m\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Michalewicz function.\n        Returns:\n            UniversalArray: The value of the Michalewicz function.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor i, x_i in enumerate(self._x, start=1):\nsum_ += np.sin(x_i) * np.sin((i * x_i**2) / np.pi) ** (2 * self.m)\nreturn -sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Michalewicz function.\n         The minima of the Michalewicz function is not unique and depends on the\n            m parameter and dimensionality of the function.\n        Returns:\n            MinimaAPI: The minima of the Michalewicz function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-1.8013,\nx=(2.20, 1.57),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/","title":"Many Local Minima","text":""},{"location":"modules/functions/optimization/many_local_minima/#ackley-function","title":"Ackley Function","text":"<p>Ackley function.</p> <p>The Ackley function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Ackley function is defined as:</p> \\[     f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}       \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)       \\right) + e + \\alpha \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which can be one, two, three, or higher  dimensional.</p> <code>()</code> <code>alpha</code> <code>float</code> <p>Scaling factor. Default is 20.0.</p> <code>20.0</code> <code>beta</code> <code>float</code> <p>Scaling factor. Default is 0.2.</p> <code>0.2</code> <code>gamma</code> <code>float</code> <p>Scaling factor. Default is 2.0 * np.pi.</p> <code>2.0 * pi</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class AckleyFunction(OptFunction):\nr\"\"\"Ackley function.\n    The Ackley function is a multi-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import AckleyFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = AckleyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"AckleyFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Ackley function is defined as:\n        $$\n            f(x) = -\\alpha \\exp \\left( -\\beta \\sqrt{\\frac{1}{n} \\sum_{i=1}^n x_i^2}\n              \\right) - \\exp \\left( \\frac{1}{n} \\sum_{i=1}^n \\cos(\\gamma x_i)\n              \\right) + e + \\alpha\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/ackley.html).\n    Args:\n        *x (UniversalArray): Input data, which can be one, two, three, or higher\n             dimensional.\n        alpha (float): Scaling factor. Default is 20.0.\n        beta (float): Scaling factor. Default is 0.2.\n        gamma (float): Scaling factor. Default is 2.0 * np.pi.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nalpha: float = 20.0,\nbeta: float = 0.2,\ngamma: float = 2.0 * np.pi,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nself._alpha = alpha\nself._beta = beta\nself._gamma = gamma\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Ackley function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_1 = np.zeros_like(self._x[0])\nsum_2 = np.zeros_like(self._x[0])\nfor _i, _x in enumerate(self._x, start=1):\n# Calculate sum of squares of x values\nsum_1 += _x**2\n# Calculate sum of cosines of x values\nsum_2 += np.cos(self._gamma * _x)\n# Calculate exponential terms\nterms_1 = -self._alpha * np.exp(-self._beta * np.sqrt(1 / _i * sum_1))\nterms_2 = -np.exp(1 / _i * sum_2)\n# Calculate Ackley function value\nterms_3 = np.e + self._alpha\nreturn terms_1 + terms_2 + terms_3\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Ackley function.\"\"\"\nreturn MinimaAPI(f_x=0.0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#bukin-function-n-6","title":"Bukin Function N. 6","text":"<p>Bukin function number 6.</p> <p>The Bukin function number 6 is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n&gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Bukin function number 6 is defined as:</p> \\[     f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +     0.01 \\left| x + 10 \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class BukinN6Function(OptFunction):\nr\"\"\"Bukin function number 6.\n    The Bukin function number 6 is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import BukinN6Function\n        &gt;&gt;&gt; x = np.linspace(-15, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-3, 3, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BukinN6Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BukinN6Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Bukin function number 6 is defined as:\n        $$\n            f(x) = 100 \\sqrt{\\left| y - 0.01 x^2 \\right|} +\n            0.01 \\left| x + 10 \\right|\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/bukin6.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Bukin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Bukin function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = 100 * np.sqrt(np.abs(x_2 - 0.01 * x_1**2))\nterm_2 = 0.01 * np.abs(x_1 + 10)\nreturn term_1 + term_2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(-10.0, 1.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#cross-in-tray-function","title":"Cross-in-Tray Function","text":"<p>Cross-in-tray function.</p> <p>The Cross-in-tray function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Cross-in-tray function is defined as:</p> \\[     f(x) = -0.0001 \\left| \\sin(x_1) \\sin(x_2) \\exp \\left| 100     - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right| + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class CrossInTrayFunction(OptFunction):\nr\"\"\"Cross-in-tray function.\n    The Cross-in-tray function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import CrossInTrayFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = CrossInTrayFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"CrossInTrayFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Cross-in-tray function is defined as:\n        $$\n            f(x) = -0.0001 \\left| \\sin(x_1) \\sin(x_2) \\exp \\left| 100\n            - \\sqrt{x_1^2 + x_2^2} / \\pi \\right| \\right| + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/crossit.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Cross-in-tray\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Cross-in-tray function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(x_1) * np.sin(x_2)\nterm_2 = np.exp(np.abs(100 - np.sqrt(x_1**2 + x_2**2) / np.pi))\nreturn -0.0001 * np.abs(term_1 * term_2 + 1) ** 0.1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-2.06261,\nx=tuple(\nnp.array([1.34941, 1.34941]),\nnp.array([-1.34941, -1.34941]),\nnp.array([1.34941, -1.34941]),\nnp.array([-1.34941, 1.34941]),\n),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#drop-wave-function","title":"Drop Wave Function","text":"<p>Drop-wave function.</p> <p>The Drop-wave function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Drop-wave function is defined as:</p> \\[     f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)     / (0.5(x_1^2 + x_2^2) + 2) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class DropWaveFunction(OptFunction):\nr\"\"\"Drop-wave function.\n    The Drop-wave function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import DropWaveFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DropWaveFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DropWaveFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Drop-wave function is defined as:\n        $$\n            f(x) = -\\left( 1 + \\cos(12 \\sqrt{x_1^2 + x_2^2}) \\right)\n            / (0.5(x_1^2 + x_2^2) + 2)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/drop.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Drop-wave\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Drop-wave function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = 12 * np.sqrt(x_1**2 + x_2**2)\nterm_2 = 0.5 * (x_1**2 + x_2**2) + 2\nreturn -((1 + np.cos(term_1)) / term_2)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=-1.0, x=tuple(0.0, 0.0))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#egg-holder-function","title":"Egg Holder Function","text":"<p>Egg-holder function.</p> <p>The Egg-holder function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n&gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Egg-holder function is defined as:</p> \\[     f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}     + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1     - (x_2 + 47) \\right|} \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class EggHolderFunction(OptFunction):\nr\"\"\"Egg-holder function.\n    The Egg-holder function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import EggHolderFunction\n        &gt;&gt;&gt; x = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; y = np.linspace(-512, 512, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = EggHolderFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"EggHolderFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Egg-holder function is defined as:\n        $$\n            f(x) = -(x_2 + 47) \\sin \\left( \\sqrt{\\left| x_2 + \\frac{x_1}{2}\n            + 47 \\right|} \\right) - x_1 \\sin \\left( \\sqrt{\\left| x_1\n            - (x_2 + 47) \\right|} \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/egg.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Egg-holder\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Egg-holder function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sqrt(np.abs(x_2 + 47 + x_1 / 2))\nterm_2 = np.sqrt(np.abs(x_1 - (x_2 + 47)))\nreturn -(x_2 + 47) * np.sin(term_1) - x_1 * np.sin(term_2)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=-959.6407, x=tuple(512, 404.2319))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#griewank-function","title":"Griewank Function","text":"<p>Griewank function.</p> <p>The Griewank function is a multi-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n&gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Griewank function is defined as:</p> \\[     f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos     \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class GriewankFunction(OptFunction):\nr\"\"\"Griewank function.\n    The Griewank function is a multi-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import GriewankFunction\n        &gt;&gt;&gt; x = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; y = np.linspace(-50, 50, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GriewankFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GriewankFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Griewank function is defined as:\n        $$\n            f(x) = \\frac{1}{4000} \\sum_{i=1}^n x_i^2 - \\prod_{i=1}^n \\cos\n            \\left( \\frac{x_i}{\\sqrt{i}} \\right) + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/griewank.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Griewank function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor i, x_i in enumerate(self._x, start=1):\nsum_ += 1 / 4000 * x_i**2\nif i == 1:\nprod_ = np.cos(x_i / np.sqrt(i))\nprod_ *= np.cos(x_i / np.sqrt(i))\nreturn sum_ - prod_ + 1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=tuple(np.zeros_like(self._x[0])))\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#holder-table-function","title":"Holder Table Function","text":"<p>Holder table function.</p> <p>The Holder table function is a two-dimensional function with many local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Holder table function is defined as:</p> \\[     f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /     \\pi \\right| \\right| \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class HolderTableFunction(OptFunction):\nr\"\"\"Holder table function.\n    The Holder table function is a two-dimensional function with many local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import HolderTableFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = HolderTableFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"HolderTableFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Holder table function is defined as:\n        $$\n            f(x) = -\\left| \\sin(x_1) \\cos(x_2) \\exp \\left| 1 - \\sqrt{x_1^2 + x_2^2} /\n            \\pi \\right| \\right|\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/holder.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Holder table\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Holder table function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(x_1) * np.cos(x_2)\nterm_2 = np.abs(1 - np.sqrt(x_1**2 + x_2**2) / np.pi)\nterm_3 = np.exp(term_2)\nreturn -np.abs(term_1 * term_3)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-19.2085,\nx=tuple(\nnp.array([8.05502, 9.66459]),\nnp.array([8.05502, -9.66459]),\nnp.array([-8.05502, 9.66459]),\nnp.array([-8.05502, -9.66459]),\n),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#langermann-function","title":"Langermann Function","text":"<p>Langermann function.</p> <p>The Langermann function is a multi-dimensional function with many unevenly distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Langermann function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}     (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi     \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right) \\] <p>with the constants :math:<code>c_i</code> and the :math:<code>a_{ij}</code> given by:</p> \\[     c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =     \\left\\{ 3, 5, 2, 1, 7 \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <code>A</code> <code>UniversalArray</code> <p>Matrix of constants :math:<code>a_{ij}</code>. The numbers of rows has to be equal to the number of input data, respectively, dimensions. Defaults to :math:<code>a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}</code>.</p> <code>None</code> <code>c</code> <code>UniversalArray</code> <p>Vector of constants :math:<code>c_i</code>. Defaults to :math:<code>c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}</code>.</p> <code>None</code> <code>m</code> <code>int</code> <p>Number of local minima. Defaults to 5.</p> <code>5</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LangermannFunction(OptFunction):\nr\"\"\"Langermann function.\n    The Langermann function is a multi-dimensional function with many unevenly\n    distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LangermannFunction\n        &gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(0, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LangermannFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"langermann.png\", dpi=300, transparent=True)\n    Notes:\n        The Langermann function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^{5} c_i \\exp \\left( -\\frac{1}{\\pi} \\sum_{j=1}^{2}\n            (x_j - a_{ij})^2 \\right) \\cos \\left( \\pi\n            \\sum_{j=1}^{2} (x_j - a_{ij})^2 \\right)\n        $$\n        with the constants :math:`c_i` and the :math:`a_{ij}` given by:\n        $$\n            c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}, \\quad a_{ij} =\n            \\left\\{ 3, 5, 2, 1, 7 \\right\\}\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/langer.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n        A (UniversalArray, optional): Matrix of constants :math:`a_{ij}`. The numbers\n            of rows has to be equal to the number of input data, respectively,\n            dimensions. Defaults to :math:`a_{ij} = \\left\\{ 3, 5, 2, 1, 7 \\right\\}`.\n        c (UniversalArray, optional): Vector of constants :math:`c_i`. Defaults to\n            :math:`c_i = \\left\\{ 1, 2, 5, 2, 3 \\right\\}`.\n        m (int, optional): Number of local minima. Defaults to 5.\n    \"\"\"\ndef __init__(\nself,\n*x: UniversalArray,\nA: UniversalArray = None,  # noqa: N803\nc: UniversalArray = None,\nm: int = 5,\n) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\nif A is None:\nA = np.array([[3, 5, 2, 1, 7], [5, 2, 1, 4, 9]], dtype=float)  # noqa: N806\nif c is None:\nc = np.array([1, 2, 5, 2, 3], dtype=float)\nif len(x) != A.shape[0]:\nmsg = \"Dimension of x must match number of rows in A.\"\nraise ValueError(msg)\nif len(A.shape) != __2d__:\nmsg = (\n\"A must be two dimensional array. In case of one input the  \"\n\"array must lool like 'np.array([[...]])'. \"\n)\nraise ValueError(\nmsg,\n)\nif A.shape[1] != m:\nraise MatchLengthError(_object=\"A\", _target=\"m\")\nif len(c) != m:\nraise MatchLengthError(_object=\"C\", _target=\"m\")\nif len(c.shape) != __1d__:\nmsg = \"c must be one dimensional array.\"\nraise ValueError(msg)\nself.a_matrix = A\nself._c = c\nself._m = m\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Langermann function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nouter_sum = np.zeros_like(self._x[0])\nfor i in range(self._m):\ninner_sum = np.zeros_like(self._x[0])\nfor j, _x in enumerate(self._x):\ninner_sum += (_x - self.a_matrix[j, i]) ** 2\nouter_sum += (\nself._c[i] * np.exp(-inner_sum / np.pi) * np.cos(np.pi * inner_sum)\n)\nreturn outer_sum\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(\nnp.array([self.a_matrix[0, i], self.a_matrix[1, i]])\nfor i in range(self._m)\n),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#levy-function","title":"Levy Function","text":"<p>Levy function.</p> <p>The Levy function is a multi-dimensional function with many local and harmonic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy function is defined as:</p> \\[     f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[     1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]     + \\left( w_d - 1 \\right)^2 \\left[     1 + \\sin^2( 2 \\pi w_d ) \\right] \\] <p>with the :math:<code>w_i</code> given by:</p> \\[     w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in     \\left\\{ 1, \\dots, d \\right\\} \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyFunction(OptFunction):\nr\"\"\"Levy function.\n    The Levy function is a multi-dimensional function with many local and harmonic\n    distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Levy function is defined as:\n        $$\n            f(x) = \\sin^2( \\pi w_1 ) + \\sum_{i=1}^{d-1} \\left( w_i - 1 \\right)^2 \\left[\n            1 + 10 \\sin^2( \\pi w_i + 1 ) \\right]\n            + \\left( w_d - 1 \\right)^2 \\left[\n            1 + \\sin^2( 2 \\pi w_d ) \\right]\n        $$\n        with the :math:`w_i` given by:\n        $$\n            w_i = 1 + \\frac{1}{4} (x_i - 1) \\quad \\forall i \\in\n            \\left\\{ 1, \\dots, d \\right\\}\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Levy function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nterm_1 = np.sin(np.pi * (1 + (1 / 4) * (self._x[0] - 1))) ** 2\nif len(self._x) == 1:\nreturn term_1\nfor i in range(1, len(self._x) - 1):\nterm_2 = (1 + (1 / 4) * (self._x[i] - 1)) ** 2\nterm_3 = 1 + 10 * np.sin(np.pi * (1 + (1 / 4) * (self._x[i] - 1)) + 1) ** 2\nsum_ += term_2 * term_3\nterm_4 = (1 + (1 / 4) * (self._x[-1] - 1)) ** 2\nterm_5 = (1 + np.sin(2 * np.pi * (1 + (1 / 4) * (self._x[-1] - 1)))) ** 2\nsum_ += term_4 * term_5\nreturn term_1 + sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([1.0]) for _ in range(len(self._x))),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#levy-function-n-13","title":"Levy Function N. 13","text":"<p>Levy N. 13 function.</p> <p>The Levy N. 13 function is a two-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Levy N. 13 function is defined as:</p> \\[     f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1     + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1     + \\sin^2( 2 \\pi x_2 ) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class LevyN13Function(OptFunction):\nr\"\"\"Levy N. 13 function.\n    The Levy N. 13 function is a two-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import LevyN13Function\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = LevyN13Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"LevyN13Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Levy N. 13 function is defined as:\n        $$\n            f(x) = \\sin^2( 3 \\pi x_1 ) + \\left( x_1 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 3 \\pi x_2) \\right] + \\left( x_2 - 1 \\right)^2 \\left[ 1\n            + \\sin^2( 2 \\pi x_2 ) \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/levy13.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Levy N. 13\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Levy N. 13 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nterm_1 = np.sin(3 * np.pi * x_1) ** 2\nterm_2 = (x_1 - 1) ** 2\nterm_3 = 1 + np.sin(3 * np.pi * x_2) ** 2\nterm_4 = (x_2 - 1) ** 2\nterm_5 = 1 + np.sin(2 * np.pi * x_2) ** 2\nreturn term_1 + term_2 * term_3 + term_4 * term_5\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(1.0, 1.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#rastrigin-function","title":"Rastrigin Function","text":"<p>Rastrigin function.</p> <p>The Rastrigin function is a multi-dimensional function with many local and harmonic and parabolic distributed minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n&gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rastrigin function is defined as:</p> \\[     f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class RastriginFunction(OptFunction):\nr\"\"\"Rastrigin function.\n    The Rastrigin function is a multi-dimensional function with many local and harmonic\n    and parabolic distributed minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import RastriginFunction\n        &gt;&gt;&gt; x = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; y = np.linspace(-5.12, 5.12, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RastriginFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RastriginFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rastrigin function is defined as:\n        $$\n            f(x) = 10 n + \\sum_{i=1}^n \\left[ x_i^2 - 10 \\cos(2 \\pi x_i) \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rastr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rastrigin function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nsum_ = np.zeros_like(self._x[0])\nfor x_i in self._x:\nsum_ += x_i**2 - 10 * np.cos(2 * np.pi * x_i)\nreturn 10 * len(self._x) + sum_\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([0.0]) for _ in range(len(self._x))),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schaffer-function-n-2","title":"Schaffer Function N. 2","text":"<p>Schaffer N. 2 function.</p> <p>The Schaffer N. 2 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 2 function is defined as:</p> \\[     f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|     \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN2Function(OptFunction):\nr\"\"\"Schaffer N. 2 function.\n    The Schaffer N. 2 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN2Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN2Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN2Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Schaffer N. 2 function is defined as:\n        $$\n            f(x) = \\frac{1}{2} + \\frac{ \\sin^2 \\left( \\left| x_1^2 + x_2^2 \\right|\n            \\right) - 0.5 }{ \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer2.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 2\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schaffer N. 2 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n0.5\n+ (np.sin(np.abs(x_1**2 + x_2**2)) ** 2 - 0.5)\n/ (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\n        Returns:\n            MinimaAPI: MinimaAPI object containing the minima of the function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schaffer-function-n-4","title":"Schaffer Function N. 4","text":"<p>Schaffer N. 4 function.</p> <p>The Schaffer N. 4 function is a two-dimensional function with a single global minimum and radial distributed local minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schaffer N. 4 function is defined as:</p> \\[     f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }     { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 } \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchafferN4Function(OptFunction):\nr\"\"\"Schaffer N. 4 function.\n    The Schaffer N. 4 function is a two-dimensional function with a\n    single global minimum and radial distributed local minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchafferN4Function\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchafferN4Function(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchafferN4Function.png\", dpi=300, transparent=True)\n    Notes:\n        The Schaffer N. 4 function is defined as:\n        $$\n            f(x) = 0.5 + \\frac{ \\sin^2 \\left( \\sqrt{ x_1^2 + x_2^2 } \\right) - 0.5 }\n            { \\left( 1 + 0.001 \\left( x_1^2 + x_2^2 \\right) \\right)^2 }\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schaffer4.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Schaffer N. 4\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schaffer N. 4 function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n0.5\n+ (np.sin(np.sqrt(x_1**2 + x_2**2)) ** 2 - 0.5)\n/ (1 + 0.001 * (x_1**2 + x_2**2)) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#schwefel-function","title":"Schwefel Function","text":"<p>Schwefel function.</p> <p>The Schwefel function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n&gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Schwefel function is defined as:</p> \\[     f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin     \\left( \\sqrt{ \\left| x_i \\right| } \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class SchwefelFunction(OptFunction):\nr\"\"\"Schwefel function.\n    The Schwefel function is a multi-dimensional function with a\n    single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import SchwefelFunction\n        &gt;&gt;&gt; x = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; y = np.linspace(-100, 100, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SchwefelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SchwefelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Schwefel function is defined as:\n        $$\n            f(x) = 418.9829 n - \\sum_{i=1}^{n} x_i \\sin\n            \\left( \\sqrt{ \\left| x_i \\right| } \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/schwef.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Schwefel function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nreturn 418.9829 * len(self._x) - np.sum(\nself._x * np.sin(np.sqrt(np.abs(self._x))),\naxis=0,\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(420.968746, 420.968746),\n)\n</code></pre>"},{"location":"modules/functions/optimization/many_local_minima/#shubert-function","title":"Shubert Function","text":"<p>Shubert function.</p> <p>The Shubert function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Shubert function is defined as:</p> \\[     f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +     \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/many_local_minima.py</code> Python<pre><code>class ShubertFunction(OptFunction):\nr\"\"\"Shubert function.\n    The Shubert function is a two-dimensional function with a\n    single global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.many_local_minima import ShubertFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 1000)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ShubertFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ShubertFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Shubert function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_1 + i \\right) +\n            \\sum_{i=1}^{5} i \\cos \\left( \\left( i + 1 \\right) x_2 + i \\right)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/shubert.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Shubert\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Shubert function at x.\n        Returns:\n            UniversalArray: Function values as numpy arrays.\n        \"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.sum(\nnp.array(\n[\ni * np.cos((i + 1) * x_1 + i) + i * np.cos((i + 1) * x_2 + i)\nfor i in range(1, 6)\n],\n),\naxis=0,\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the function.\"\"\"\nreturn MinimaAPI(f_x=-186.7309, x=(-7.708309818, -0.800371886))\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/","title":"Plate Shaped","text":""},{"location":"modules/functions/optimization/plate_shaped/#booth-function","title":"Booth Function","text":"<p>Booth Function.</p> <p>The Booth function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Booth function is defined as:</p> \\[     f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class BoothFunction(OptFunction):\nr\"\"\"Booth Function.\n    The Booth function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import BoothFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BoothFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BoothFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Booth function is defined as:\n        $$\n            f(x) = (x_1 + 2x_2 - 7)^2 + (2x_1 + x_2 - 5)^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/booth.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Booth function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (x_1 + 2 * x_2 - 7) ** 2 + (2 * x_1 + x_2 - 5) ** 2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Booth function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(1.0, 3.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#matyas-function","title":"Matyas Function","text":"<p>Matyas Function.</p> <p>The Matyas function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Matyas function is defined as:</p> \\[     f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class MatyasFunction(OptFunction):\nr\"\"\"Matyas Function.\n    The Matyas function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import MatyasFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = MatyasFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"MatyasFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Matyas function is defined as:\n        $$\n            f(x) = 0.26(x_1^2 + x_2^2) - 0.48x_1 x_2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/matya.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Matyas\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the Matyas function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 0.26 * (x_1**2 + x_2**2) - 0.48 * x_1 * x_2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Matyas function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#mccormick-function","title":"McCormick Function","text":"<p>McCormick Function.</p> <p>The McCormick function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n&gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n&gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The McCormick function is defined as:</p> \\[     f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class McCormickFunction(OptFunction):\nr\"\"\"McCormick Function.\n    The McCormick function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import McCormickFunction\n        &gt;&gt;&gt; x = np.linspace(-1.5, 4, 100)\n        &gt;&gt;&gt; y = np.linspace(-3, 4, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = McCormickFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"McCormickFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The McCormick function is defined as:\n        $$\n            f(x) = \\sin(x_1 + x_2) + (x_1 - x_2)^2 - 1.5x_1 + 2.5x_2 + 1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/mccorm.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the McCormick function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn np.sin(x_1 + x_2) + (x_1 - x_2) ** 2 - 1.5 * x_1 + 2.5 * x_2 + 1\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the McCormick function.\"\"\"\nreturn MinimaAPI(\nf_x=-1.9133,\nx=(-0.54719, -1.54719),\n)\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#power-sum-function","title":"Power Sum Function","text":"<p>Power Sum Function.</p> <p>The Power Sum function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n&gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Power Sum function is defined as:</p> \\[     f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class PowerSumFunction(OptFunction):\nr\"\"\"Power Sum Function.\n    The Power Sum function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import PowerSumFunction\n        &gt;&gt;&gt; x = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 1, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = PowerSumFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"PowerSumFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Power Sum function is defined as:\n        $$\n            f(x) = x_1^2 + x_2^2 + x_1^4 + x_2^4\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/powersum.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Power Sum\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArrayTuple:\n\"\"\"Evaluate the Power Sum function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn x_1**2 + x_2**2 + x_1**4 + x_2**4\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Power Sum function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=(0.0, 0.0),\n)\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#zakharov-function","title":"Zakharov Function","text":"<p>Zakharov Function.</p> <p>The Zakharov function is a two-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zakharov function is defined as:</p> \\[     f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2     + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZakharovFunction(OptFunction):\nr\"\"\"Zakharov Function.\n    The Zakharov function is a two-dimensional function with a single global\n    minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZakharovFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZakharovFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZakharovFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zakharov function is defined as:\n        $$\n            f(x) = \\sum_{i=1}^2 x_i^2 + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^2\n            + \\left(\\sum_{i=1}^2 0.5ix_i\\right)^4\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zakharov.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArrayTuple:\n\"\"\"Evaluate the Zakharov function at x.\"\"\"\nsum_1 = np.zeros_like(self._x[0])\nsum_2 = np.zeros_like(self._x[0])\nfor i in range(self.dimension):\nsum_1 += self._x[i] ** 2\nsum_2 += 0.5 * (i + 1) * self._x[i]\nreturn sum_1 + sum_2**2 + sum_2**4\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zakharov function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.zeros_like(self.dimension)),\n)\n</code></pre>"},{"location":"modules/functions/optimization/plate_shaped/#zettl-function","title":"Zettl Function","text":"<p>Zettl function.</p> <p>The Zettl function is a D-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Zettl function is defined as:</p> \\[     f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/plate_shaped.py</code> Python<pre><code>class ZettlFunction(OptFunction):\nr\"\"\"Zettl function.\n    The Zettl function is a D-dimensional function with multimodal structure and sharp\n    peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.plate_shaped import ZettlFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ZettlFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ZettlFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Zettl function is defined as:\n        $$\n            f(x) = (x_1^2 + x_2^2 - 2 x_1)^2 + \\frac{1}{4} x_1\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/zettl.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nmsg = f\"Expected 2 arguments, but got {len(x)}.\"\nraise ValueError(msg)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Zettl function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn (\nself._x[0] ** 2 + self._x[1] ** 2 - 2 * self._x[0]\n) ** 2 + 0.25 * self._x[0]\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Zettl function.\n        Returns:\n            MinimaAPI: Minima of the Zettl function.\n        \"\"\"\nreturn MinimaAPI(f_x=0, x=(0, 0))\n</code></pre>"},{"location":"modules/functions/optimization/special/","title":"Special","text":""},{"location":"modules/functions/optimization/special/#beale-function","title":"Beale Function","text":"<p>Beale function.</p> <p>The Beale function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n&gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Beale function is defined as:</p> \\[     f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BealeFunction(OptFunction):\nr\"\"\"Beale function.\n    The Beale function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BealeFunction\n        &gt;&gt;&gt; x = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; y = np.linspace(-4.5, 4.5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BealeFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BealeFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Beale function is defined as:\n        $$\n            f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 + (2.625 - x + xy^3)^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/beale.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Beale\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Beale function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx, y = self._x[0], self._x[1]\nreturn (\n(1.5 - x + x * y) ** 2\n+ (2.25 - x + x * y**2) ** 2\n+ (2.625 - x + x * y**3) ** 2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Beale function.\n        Returns:\n            MinimaAPI: Minima of the Beale function.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=(0.5))\n</code></pre> <p></p>"},{"location":"modules/functions/optimization/special/#branin-function","title":"Branin Function","text":"<p>Branin function.</p> <p>The Branin function is a two-dimensional function with multimodal structure and sharp peaks.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n&gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n&gt;&gt;&gt; y = np.linspace(0, 15, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Branin function is defined as:</p> \\[     f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s \\] <p>where</p> \\[     a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi) \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class BraninFunction(OptFunction):\nr\"\"\"Branin function.\n    The Branin function is a two-dimensional function with multimodal structure and\n    sharp peaks.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import BraninFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(0, 15, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = BraninFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"BraninFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Branin function is defined as:\n        $$\n            f(x, y) = a(y - bx^2 + cx - r)^2 + s(1 - t) \\cos(y) + s\n        $$\n        where\n        $$\n            a = 1, b = 5.1/(4\\pi^2), c = 5/\\pi, r = 6, s = 10, t = 1/(8\\pi)\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/branin.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Branin\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Branin function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx, y = self._x[0], self._x[1]\na = 1\nb = 5.1 / (4 * np.pi**2)\nc = 5 / np.pi\nr = 6\ns = 10\nt = 1 / (8 * np.pi)\nreturn a * (y - b * x**2 + c * x - r) ** 2 + s * (1 - t) * np.cos(y) + s\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Branin function.\n        Returns:\n            MinimaAPI: Minima of the Branin function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=0.397887,\nx=tuple(\nnp.array([-np.pi, 12.275]),\nnp.array([np.pi, 2.275]),\nnp.array([np.pi, 9.42478]),\nnp.array([9.42478, 2.475]),\n),\n)\n</code></pre> <p></p>"},{"location":"modules/functions/optimization/special/#styblinski-tang-function","title":"Styblinski-Tang Function","text":"<p>Styblinski-Tang function.</p> <p>The Styblinski-Tang function is a D-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Styblinski-Tang function is defined as:</p> \\[     f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right) \\] <p>with \\(D\\) the dimension of the input. The hypercube of the function is defined as \\(x_i \\in [-5, 5]\\) for all \\(i\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class StyblinskiTangFunction(OptFunction):\nr\"\"\"Styblinski-Tang function.\n    The Styblinski-Tang function is a D-dimensional function.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import StyblinskiTangFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = StyblinskiTangFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"StyblinskiTangFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Styblinski-Tang function is defined as:\n        $$\n            f(x) = \\frac{1}{2} \\sum_{i=1}^D \\left( x_i^4 - 16 x_i^2 + 5 x_i \\right)\n        $$\n        with $D$ the dimension of the input. The hypercube of the function is defined\n        as $x_i \\in [-5, 5]$ for all $i$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/stybtang.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Styblinski-Tang function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn np.array(\n0.5\n* sum(\n(self._x[i - 1] ** 4 - 16 * self._x[i - 1] ** 2 + 5 * self._x[i - 1])\nfor i in range(1, self.dimension + 1)\n),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Styblinski-Tang function.\n        Returns:\n            MinimaAPI: Minima of the Styblinski-Tang function.\n        \"\"\"\nreturn MinimaAPI(\nf_x=-39.16616570377142,\nx=tuple(np.ones(self.dimension) * -2.903534),\n)\n</code></pre>"},{"location":"modules/functions/optimization/special/#goldstein-price-function","title":"Goldstein-Price Function","text":"<p>Goldstein-Price function.</p> <p>The Goldstein-Price function is a two-dimensional function.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function is defined as:</p> \\[     f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2     \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)     \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2     \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right) \\] <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceFunction(OptFunction):\nr\"\"\"Goldstein-Price function.\n    The Goldstein-Price function is a two-dimensional function.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Goldstein-Price function is defined as:\n        $$\n            f(x) = \\left( 1 + \\left( x_1 + x_2 + 1 \\right)^2\n            \\left( 19 - 14 x_1 + 3 x_1^2 - 14 x_2 + 6 x_1 x_2 + 3 x_2^2 \\right) \\right)\n            \\left( 30 + \\left( 2 x - 3 x_2 \\right)^2\n            \\left( 18 - 32 x_1 + 12 x^2 + 48 x_2 - 36 x_1 x_2 + 27 x_2^2 \\right) \\right)\n        $$\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Goldstein-Price function at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nreturn (\n1\n+ (self._x[0] + self._x[1] + 1) ** 2\n* (\n19\n- 14 * self._x[0]\n+ 3 * self._x[0] ** 2\n- 14 * self._x[1]\n+ 6 * self._x[0] * self._x[1]\n+ 3 * self._x[1] ** 2\n)\n) * (\n30\n+ (2 * self._x[0] - 3 * self._x[1]) ** 2\n* (\n18\n- 32 * self._x[0]\n+ 12 * self._x[0] ** 2\n+ 48 * self._x[1]\n- 36 * self._x[0] * self._x[1]\n+ 27 * self._x[1] ** 2\n)\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Goldstein-Price function.\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/functions/optimization/special/#goldstein-price-log-function","title":"Goldstein-Price Log Function","text":"<p>Goldstein-Price function in logarithmic form.</p> <p>The Goldstein-Price function in logarithmic form is a two-dimensional function. In this form, the function offers a better conditioning by using the logarithm.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Goldstein-Price function in logarithmic form is defined as:</p> <p>$$     f(x, y) = frac{1}{2.427} left[     log left( 1 + left( bar{x}_1 + bar{x}_2 + 1 right)^2     left( 19 - 14 x + 3 bar{x}_1^2 - 14 bar{x}_2 + 6 bar{x}_1 bar{x}_2     + 3 bar{x}_2^2 right) right) + log left( 30 + left( 2 bar{x}_1 - 3     bar{x}_2 right)^2 left( 18 - 32 bar{x}_1 + 12 bar{x}_1^2 + 48     bar{x}_2 - 36 bar{x}_1 bar{x}_2 + 27 y^2 right) right) - 8.683 right]</p> Scdoc<pre><code>\\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n</code></pre> <p>$$</p> <p>The hypercube of the function is defined as \\(x_1, x_2 \\in [-2, 2]\\).</p> <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two dimensional.</p> <code>()</code> Source code in <code>umf/functions/optimization/special.py</code> Python<pre><code>class GoldsteinPriceLogFunction(OptFunction):\nr\"\"\"Goldstein-Price function in logarithmic form.\n    The Goldstein-Price function in logarithmic form is a two-dimensional function.\n    In this form, the function offers a better conditioning by using the logarithm.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.special import GoldsteinPriceLogFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = GoldsteinPriceLogFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"GoldsteinPriceLogFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Goldstein-Price function in logarithmic form is defined as:\n        $$\n            f(x, y) = \\frac{1}{2.427} \\left[\n            \\log \\left( 1 + \\left( \\bar{x}_1 + \\bar{x}_2 + 1 \\right)^2\n            \\left( 19 - 14 x + 3 \\bar{x}_1^2 - 14 \\bar{x}_2 + 6 \\bar{x}_1 \\bar{x}_2\n            + 3 \\bar{x}_2^2 \\right) \\right) + \\log \\left( 30 + \\left( 2 \\bar{x}_1 - 3\n            \\bar{x}_2 \\right)^2 \\left( 18 - 32 \\bar{x}_1 + 12 \\bar{x}_1^2 + 48\n            \\bar{x}_2 - 36 \\bar{x}_1 \\bar{x}_2 + 27 y^2 \\right) \\right) - 8.683 \\right]\n            \\text{with } \\bar{x}_{1,2} = 4 x_{1,2} - 2\n        $$\n        The hypercube of the function is defined as $x_1, x_2 \\in [-2, 2]$.\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/goldpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two dimensional.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"Goldstein-Price\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Goldstein-Price function in logarithmic form at x.\n        Returns:\n            UniversalArray: Evaluated function value.\n        \"\"\"\nx_1 = 4 * self._x[0] - 2\nx_2 = 4 * self._x[1] - 2\nreturn (\n1\n/ 2.427\n* (\nnp.log(\n1\n+ (x_1 + x_2 + 1) ** 2\n* (\n19\n- 14 * x_1\n+ 3 * x_1**2\n- 14 * x_2\n+ 6 * x_1 * x_2\n+ 3 * x_2**2\n),\n)\n+ np.log(\n30\n+ (2 * x_1 - 3 * x_2) ** 2\n* (\n18\n- 32 * x_1\n+ 12 * x_1**2\n+ 48 * x_2\n- 36 * x_1 * x_2\n+ 27 * x_2**2\n),\n)\n- 8.683\n)\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the Goldstein-Price function in logarithmic form.\n        Returns:\n            MinimaAPI: Minima of the Goldstein-Price function in logarithmic form.\n        \"\"\"\nreturn MinimaAPI(f_x=3, x=tuple(np.array([0, -1])))\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/","title":"Valley Shaped","text":""},{"location":"modules/functions/optimization/valley_shaped/#three-hump-camel-function","title":"Three Hump Camel Function","text":"<p>Three-hump camel function.</p> <p>The three-hump camel function is a two-dimensional function with three minima, where one of the minima is a global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The three-hump camel function is defined as:</p> \\[ f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class ThreeHumpCamelFunction(OptFunction):\nr\"\"\"Three-hump camel function.\n    The three-hump camel function is a two-dimensional function with three\n    minima, where one of the minima is a global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import ThreeHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; y = np.linspace(-5, 5, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = ThreeHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"ThreeHumpCamelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The three-hump camel function is defined as:\n        $$\n        f(x) = 2x_1^2 - 1.05x_1^4 + \\frac{x_1^6}{6} + x_1x_2 + x_2^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel3.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the three-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"ThreeHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the three-hump camel function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn 2 * x_1**2 - 1.05 * x_1**4 + (x_1**6) / 6 + x_1 * x_2 + x_2**2\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the three-hump camel function.\"\"\"\nreturn MinimaAPI(\nf_x=np.array([0.0, 0.0]),\nx=tuple(np.array([0.0])),\n)\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#six-hump-camel-function","title":"Six Hump Camel Function","text":"<p>Six-hump camel function.</p> <p>The six-hump camel function is a two-dimensional function with six minima, where two of them are global minima.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n&gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n&gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The six-hump camel function is defined as:</p> \\[ f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2 \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>OutOfDimensionError</code> <p>If the dimension of the input data is not 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class SixHumpCamelFunction(OptFunction):\nr\"\"\"Six-hump camel function.\n    The six-hump camel function is a two-dimensional function with six\n    minima, where two of them are global minima.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import SixHumpCamelFunction\n        &gt;&gt;&gt; x = np.linspace(-3, 3, 100)\n        &gt;&gt;&gt; y = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = SixHumpCamelFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"SixHumpCamelFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The six-hump camel function is defined as:\n        $$\n        f(x) = (4 - 2.1x_1^2 + \\frac{x_1^4}{3})x_1^2 + x_1x_2 + (-4 + 4x_2^2)x_2^2\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/camel6.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        OutOfDimensionError: If the dimension of the input data is not 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the six-hump camel function.\"\"\"\nif len(x) != __2d__:\nraise OutOfDimensionError(\nfunction_name=\"SixHumpCamel\",\ndimension=__2d__,\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate the six-hump camel function at x.\"\"\"\nx_1 = self._x[0]\nx_2 = self._x[1]\nreturn (\n(4 - 2.1 * x_1**2 + (x_1**4) / 3) * x_1**2\n+ x_1 * x_2\n+ (-4 + 4 * x_2**2) * x_2**2\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the minima of the six-hump camel function.\"\"\"\nreturn MinimaAPI(\nf_x=-1.031628453489877,\nx=tuple(np.array([0.0898, -0.7126], [-0.0898, 0.7126])),\n)\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#dixon-price-function","title":"Dixon-Price Function","text":"<p>Dixon-Price function.</p> <p>The Dixon-Price function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n&gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Dixon-Price function is defined as:</p> \\[ f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class DixonPriceFunction(OptFunction):\nr\"\"\"Dixon-Price function.\n    The Dixon-Price function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import DixonPriceFunction\n        &gt;&gt;&gt; x = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; y = np.linspace(-10, 10, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = DixonPriceFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"DixonPriceFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Dixon-Price function is defined as:\n        $$\n        f(x) = (x_1 - 1)^2 + \\sum_{i=2}^n \\left[ i(x_i - x_{i-1}^2)^2 \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/dixonpr.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Dixon-Price function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"DixonPrice\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Dixon-Price function at x.\"\"\"\nx = self._x\nreturn (x[0] - 1) ** 2 + sum(\n(i + 1) * (x[i] - x[i - 1] ** 2) ** 2 for i in range(1, len(x))\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the zero function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([2 ** (-i) for i in range(1, len(self._x) + 1)])),\n)\n</code></pre>"},{"location":"modules/functions/optimization/valley_shaped/#rosenbrock-function","title":"Rosenbrock Function","text":"<p>Rosenbrock function.</p> <p>The Rosenbrock function is a multi-dimensional function with a single global minimum.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n&gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n&gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n&gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n&gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n&gt;&gt;&gt; fig = plt.figure()\n&gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n&gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n&gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n</code></pre> Notes <p>The Rosenbrock function is defined as:</p> \\[ f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right] \\] <p>Reference: Original implementation can be found here.</p> <p>Parameters:</p> Name Type Description Default <code>*x</code> <code>UniversalArray</code> <p>Input data, which has to be two-dimensional.</p> <code>()</code> <p>Raises:</p> Type Description <code>TooSmallDimensionError</code> <p>If the dimension of the input data is smaller than 2.</p> Source code in <code>umf/functions/optimization/valley_shaped.py</code> Python<pre><code>class RosenbrockFunction(OptFunction):\nr\"\"\"Rosenbrock function.\n    The Rosenbrock function is a multi-dimensional function with a single\n    global minimum.\n    Examples:\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from umf.functions.optimization.valley_shaped import RosenbrockFunction\n        &gt;&gt;&gt; x = np.linspace(-2, 2, 100)\n        &gt;&gt;&gt; y = np.linspace(-1, 3, 100)\n        &gt;&gt;&gt; X, Y = np.meshgrid(x, y)\n        &gt;&gt;&gt; Z = RosenbrockFunction(X, Y).__eval__\n        &gt;&gt;&gt; fig = plt.figure()\n        &gt;&gt;&gt; ax = fig.add_subplot(111, projection=\"3d\")\n        &gt;&gt;&gt; _ = ax.plot_surface(X, Y, Z, cmap=\"viridis\")\n        &gt;&gt;&gt; plt.savefig(\"RosenbrockFunction.png\", dpi=300, transparent=True)\n    Notes:\n        The Rosenbrock function is defined as:\n        $$\n        f(x) = \\sum_{i=1}^{n-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2 \\right]\n        $$\n        &gt; Reference: Original implementation can be found\n        &gt; [here](https://www.sfu.ca/~ssurjano/rosen.html).\n    Args:\n        *x (UniversalArray): Input data, which has to be two-dimensional.\n    Raises:\n        TooSmallDimensionError: If the dimension of the input data is smaller than 2.\n    \"\"\"\ndef __init__(self, *x: UniversalArray) -&gt; None:\n\"\"\"Initialize the Rosenbrock function.\"\"\"\nif len(x) &lt; __2d__:\nraise TooSmallDimensionError(\nfunction_name=\"Rosenbrock\",\ndimension=__2d__,\nlen_x=len(x),\n)\nsuper().__init__(*x)\n@property\ndef __eval__(self) -&gt; UniversalArray:\n\"\"\"Evaluate Rosenbrock function at x.\"\"\"\nx = self._x\nreturn np.array(\nsum(\n100 * (x[i + 1] - x[i] ** 2) ** 2 + (1 - x[i]) ** 2\nfor i in range(len(x) - 1)\n),\n)\n@property\ndef __minima__(self) -&gt; MinimaAPI:\n\"\"\"Return the zero function.\"\"\"\nreturn MinimaAPI(\nf_x=0.0,\nx=tuple(np.array([1.0 for _ in range(len(self._x))])),\n)\n</code></pre>"},{"location":"modules/functions/others/support_functions/","title":"Supporting Functions","text":""},{"location":"modules/functions/others/support_functions/#support-functions","title":"Support Functions","text":"<p>Info</p> <p>Please note that the following functions in the module are not meant to be used directly, as they are used by other functions within the module. The goal of <code>useful-math-functions</code> is to minimize the use of third-party dependencies in its functions. However, certain functions are utilized by multiple other functions, and are therefore implemented in the <code>support_functions</code> module to avoid duplicating code. Additionally, some functions still require the <code>scipy</code> package in order to be fully executed.</p> <p>Compute the Faddeeva function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def wofz(z: UniversalArray) -&gt; UniversalArray:\n\"\"\"Compute the Faddeeva function for a given complex argument.\"\"\"\nreturn np.exp(-(z**2)) * numeric_erfc(-1j * z)\n</code></pre> <p>Compute the complementary error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def erfc(z: UniversalArray) -&gt; UniversalArray:\n\"\"\"Compute the complementary error function for a given complex argument.\"\"\"\nreturn 1 - erf(z)\n</code></pre> <p>Compute the complementary error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def numeric_erfc(z: UniversalArray) -&gt; UniversalArray:\n\"\"\"Compute the complementary error function for a given complex argument.\"\"\"\nreturn 1 - numeric_erf(z)\n</code></pre> <p>Return the error function of x.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def erf(x: UniversalArray) -&gt; UniversalArray:\n\"\"\"Return the error function of x.\"\"\"\nreturn np.vectorize(math.erf)(x)\n</code></pre> <p>Compute the error function for a given complex argument.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def numeric_erf(z: UniversalArray) -&gt; UniversalArray:\n\"\"\"Compute the error function for a given complex argument.\"\"\"\nz = np.asarray(z)\nsign: UniversalArray = np.sign(z)\nz = sign * z\nt = 1 / (1 + 0.5 * z)\nresult = 1 - t * np.exp(\n-(z**2)\n- 1.26551223\n+ 1.00002368 * t\n+ 0.37409196 * t**2\n+ 0.09678418 * t**3\n- 0.18628806 * t**4\n+ 0.27886807 * t**5\n- 1.13520398 * t**6\n+ 1.48851587 * t**7\n- 0.82215223 * t**8\n+ 0.17087277 * t**9,\n)\nreturn sign * result\n</code></pre> <p>Return the gamma function of x using the Lanczos approximation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>UniversalArray</code> <p>The value(s) at which the function is evaluated.</p> required <code>batch_size</code> <code>int</code> <p>The batch size for the Lanczos approximation. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>UniversalArray</code> <code>UniversalArray</code> <p>The gamma function of x using the Lanczos approximation.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def gamma(x: UniversalArray, batch_size: int = 100) -&gt; UniversalArray:\n\"\"\"Return the gamma function of x using the Lanczos approximation.\n    Args:\n        x (UniversalArray): The value(s) at which the function is evaluated.\n        batch_size (int): The batch size for the Lanczos approximation. Defaults to 100.\n    Returns:\n        UniversalArray: The gamma function of x using the Lanczos approximation.\n    \"\"\"\n# Define the coefficients of the Lanczos approximation\ndef _gamma(x: UniversalArray) -&gt; UniversalArray:\n\"\"\"Return the gamma function of x using the Lanczos approximation.\"\"\"\ng = 7\np: list[float] = [\n0.99999999999980993,\n676.5203681218851,\n-1259.1392167224028,\n771.32342877765313,\n-176.61502916214059,\n12.507343278686905,\n-0.13857109526572012,\n9.9843695780195716e-6,\n1.5056327351493116e-7,\n]\nif np.any(np.less(x, 0.5)):\nreturn np.pi / (np.sin(np.pi * x) * _gamma(1 - x))\nx = x - 1\na = p[0] + np.sum([p[i] / (x + i) for i in range(1, len(p))], axis=0)\nt = x + g + 0.5\nreturn np.sqrt(2 * np.pi) * np.power(t, x + 0.5) * np.exp(-t) * a\ny: UniversalArray = np.zeros_like(x)\nfor i in range(0, len(x), batch_size):\ny[i : i + batch_size] = _gamma(x[i : i + batch_size])\nreturn y\n</code></pre> <p>Return the number of combinations of n things taken k at a time.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | ndarray</code> <p>The number of things.</p> required <code>k</code> <code>int | ndarray</code> <p>The number of things taken at a time.</p> required <p>Returns:</p> Type Description <code>int | ndarray</code> <p>int | np.ndarray: The number of combinations of n things taken k at a time.</p> Source code in <code>umf/functions/other/support_functions.py</code> Python<pre><code>def combinations(n: int | np.ndarray, k: int | np.ndarray) -&gt; int | np.ndarray:\n\"\"\"Return the number of combinations of n things taken k at a time.\n    Args:\n        n (int | np.ndarray): The number of things.\n        k (int | np.ndarray): The number of things taken at a time.\n    Returns:\n        int | np.ndarray: The number of combinations of n things taken k at a time.\n    \"\"\"\nn = np.array(n, dtype=int)\nk = np.array(k, dtype=int)\nif n.ndim == 0:\nreturn math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\nc: np.ndarray = np.zeros_like(n)\nfor i in np.ndindex(n.shape):\nc[i] = math.factorial(n[i]) // (\nmath.factorial(k[i]) * math.factorial(n[i] - k[i])\n)\nreturn c\n</code></pre>"}]}