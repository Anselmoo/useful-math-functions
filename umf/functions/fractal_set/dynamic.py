"""Dynamic system fractals for the UMF package."""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

from umf.constants.dimensions import __2d__, __3d__
from umf.constants.exceptions import OutOfDimensionError
from umf.meta.functions import DynamicFractalFunction

if TYPE_CHECKING:
    from umf.types.static_types import UniversalArray


__all__ = [
    "CurlicueFractal",
    "LorenzAttractor",
    "PercolationModel",
    "RandomWalkFractal",
]


class LorenzAttractor(DynamicFractalFunction):
    r"""Implementation of the Lorenz attractor fractal.

    The Lorenz attractor is a set of chaotic solutions of the Lorenz system:
    
    Notes:
        The Lorenz attractor has a fractal dimension of approximately 2.06 (Hausdorff 
        dimension). It exhibits chaotic behavior for certain parameter values, 
        meaning that small  changes in initial conditions lead to dramatically different 
        trajectories,  while still being confined to the same strange attractor. 

        $$
            \begin{align}
            \frac{dx}{dt} &= \sigma(y - x) \\
            \frac{dy}{dt} &= x(\rho - z) - y \\
            \frac{dz}{dt} &= xy - \beta z
            \end{align}
        $$
        
        This is one of the most famous examples of deterministic chaos and was 
        discovered by Edward Lorenz in 1963 while studying simplified models of 
        atmospheric convection.

    Examples:
        >>> import numpy as np
        >>> import matplotlib.pyplot as plt
        >>> from mpl_toolkits.mplot3d import Axes3D
        >>> from umf.functions.fractal_set.dynamic import LorenzAttractor
        >>> # Generate Lorenz attractor
        >>> x, y, z = np.array([0.0]), np.array([1.0]), np.array([1.05])
        >>> lorenz = LorenzAttractor(x, y, z, max_iter=10000)()
        >>> points = lorenz.result

        >>> # Visualization
        >>> fig = plt.figure(figsize=(10, 10))
        >>> ax = fig.add_subplot(111, projection='3d')
        >>> _ = ax.plot(points[:, 0], points[:, 1], points[:, 2], 'b-', linewidth=0.5)
        >>> _ = plt.title("Lorenz Attractor")
        >>> plt.savefig("LorenzAttractor.png", dpi=300, transparent=True)

    Args:
        initial_state (UniversalArray): Initial point [x, y, z]
        max_iter (int, optional): Number of iterations. Defaults to 10000.
        sigma (float, optional): σ parameter. Defaults to 10.0.
        rho (float, optional): ρ parameter. Defaults to 28.0.
        beta (float, optional): β parameter. Defaults to 8/3.
    """

    def __init__(
        self,
        *initial_state: UniversalArray,
        max_iter: int = 10000,
        sigma: float = 10.0,
        rho: float = 28.0,
        beta: float = 8 / 3,
    ) -> None:
        """Initialize the Lorenz attractor."""
        self.sigma = sigma
        self.rho = rho
        self.beta = beta
        self.fractal_dimension = 2.06  # Approximate Hausdorff dimension

        if len(initial_state) != __3d__:
            raise OutOfDimensionError(
                function_name=self.__class__.__name__,
                dimension=__3d__,
            )

        super().__init__(*initial_state, max_iter=max_iter)

    def iterate_system(self, state: np.ndarray) -> np.ndarray:
        """Iterate the Lorenz system.

        Args:
            state (np.ndarray): Current state [x, y, z]

        Returns:
            np.ndarray: Next state
        """
        x, y, z = state
        dx = self.sigma * (y - x)
        dy = x * (self.rho - z) - y
        dz = x * y - self.beta * z
        dt = 0.01  # Time step
        return state + dt * np.array([dx, dy, dz])

    @property
    def __eval__(self) -> np.ndarray:
        """Generate the Lorenz attractor points.

        Returns:
            np.ndarray: Array of points on the attractor
        """
        state = np.array([self._x[0], self._x[1], self._x[2]])
        points = [state]

        # Skip transient steps
        for _ in range(self.transient_steps):
            state = self.iterate_system(state)

        # Generate attractor points
        for _ in range(self.max_iter):
            state = self.iterate_system(state)
            points.append(state.copy())

        return np.array(points)


class CurlicueFractal(DynamicFractalFunction):
    r"""Implementation of the Curlicue fractal.

    The Curlicue fractal is generated by repeatedly rotating a vector by a fixed angle
    and connecting the endpoints.

    Notes:
        The Curlicue fractal is a visual representation of the sum of unit vectors with
        angles that form an arithmetic sequence. For a given angle $\theta$, the pattern
        is created by the sequence:

        $$
        z_n = \sum_{k=0}^{n} e^{i\theta k^2}
        $$

        When $\theta$ is an irrational multiple of $\pi$, the pattern never repeats and
        creates intricate fractal-like structures. The Golden angle $\theta = \pi(3-\sqrt{5})$
        produces particularly beautiful patterns.

    Examples:
        >>> import numpy as np
        >>> import matplotlib.pyplot as plt
        >>> from umf.functions.fractal_set.dynamic import CurlicueFractal
        >>> # Generate Curlicue fractal
        >>> angle = np.pi * (1 + 5**0.5) / 2  # Golden angle
        >>> curlicue = CurlicueFractal(
        ...     np.array([0.]),
        ...     np.array([0.]),
        ...     angle=angle,
        ...     max_iter=1000)()
        >>> points = curlicue.result

        >>> # Visualization
        >>> _ = plt.figure(figsize=(10, 10))
        >>> _ = plt.plot(points[:, 0], points[:, 1], 'b-', linewidth=0.5)
        >>> _ = plt.axis('equal')
        >>> _ = plt.title("Curlicue Fractal")
        >>> plt.savefig("CurlicueFractal.png", dpi=300, transparent=True)

    Args:
        start (UniversalArray): Starting point [x, y]
        angle (float): Rotation angle in radians
        max_iter (int, optional): Number of iterations. Defaults to 1000.
        step_size (float, optional): Length of each step. Defaults to 1.0.
    """

    def __init__(
        self,
        *start: UniversalArray,
        angle: float,
        max_iter: int = 1000,
        step_size: float = 1.0,
    ) -> None:
        """Initialize the Curlicue fractal."""
        self.angle = angle
        self.step_size = step_size
        self.fractal_dimension = 1.5  # Approximate dimension
        if len(start) != __2d__:
            raise OutOfDimensionError(
                function_name=self.__class__.__name__,
                dimension=__2d__,
            )
        super().__init__(*start, max_iter=max_iter)

    def iterate_system(self, state: UniversalArray) -> np.ndarray:
        """Generate next point in the Curlicue pattern.

        Args:
            state (np.ndarray): Current point and cumulative angle

        Returns:
            np.ndarray: Next point and updated angle
        """
        x, y = state
        # Calculate new position
        new_x = x + self.step_size * np.cos(self.angle * len(self._points))
        new_y = y + self.step_size * np.sin(self.angle * len(self._points))
        return np.array([new_x, new_y])

    @property
    def __eval__(self) -> np.ndarray:
        """Generate the Curlicue fractal points.

        Returns:
            np.ndarray: Array of points defining the curve
        """
        state = np.array([self._x[0], self._x[1]])
        self._points = [state]

        for _ in range(self.max_iter):
            state = self.iterate_system(state)
            self._points.append(state.copy())

        return np.array(self._points)


class PercolationModel(DynamicFractalFunction):
    r"""Implementation of a percolation model fractal.

    The percolation model creates a fractal pattern by randomly filling cells
    according to certain rules.

    Notes:
        Percolation theory describes the behavior of connected clusters in random
        graphs or lattices. At the critical probability threshold $p_c$ (approximately
        0.59275 for a 2D square lattice), the system undergoes a phase transition
        where an infinite spanning cluster emerges.

        The resulting cluster has a fractal dimension of approximately
        $\frac{91}{48} \approx 1.895$.

        The percolation process follows these mathematical rules:
        1. Each site is independently occupied with probability $p$
        2. Adjacent occupied sites form clusters
        3. At the critical threshold, the largest cluster exhibits fractal properties

    Examples:
        >>> import numpy as np
        >>> import matplotlib.pyplot as plt
        >>> from matplotlib.animation import FuncAnimation
        >>> from umf.functions.fractal_set.dynamic import PercolationModel
        >>> # Generate percolation pattern
        >>> height, width = np.array([100]), np.array([100])
        >>> # Note: Use a tuple for input parameters
        >>> size_tuple = (height, width)
        >>> model = PercolationModel(*size_tuple, p=0.59, max_iter=1000)
        >>>
        >>> # For static visualization of final state
        >>> final_grid = model()
        >>> _ = plt.figure(figsize=(10, 10))
        >>> im = plt.imshow(final_grid.result, cmap='inferno', interpolation='nearest')
        >>> _ = plt.colorbar(label='Cluster value')
        >>> _ = plt.title("Percolation Model (Final State)")
        >>> plt.savefig("PercolationModel.png", dpi=300, transparent=True)
        >>>
        >>> # For GIF visualization of the percolation process
        >>> fig, ax = plt.subplots(figsize=(10, 10))
        >>> grid = np.zeros((height[0], width[0]), dtype=float)
        >>> im = ax.imshow(grid, cmap='inferno', interpolation='nearest', animated=True)
        >>> _ = plt.colorbar(im, label='Cluster value')
        >>> _ = plt.title("Percolation Model Evolution")
        >>>
        >>> def update(frame):
        ...     global grid
        ...     grid = model.iterate_system(grid)
        ...     im.set_array(grid)
        ...     return [im]
        >>>
        >>> # Create animation (50 frames is usually enough to see the pattern)
        >>> ani = FuncAnimation(fig, update, frames=150, interval=50, blit=True)
        >>> ani.save("PercolationModel.gif", writer='pillow', dpi=100)

    Args:
        size (UniversalArray): Grid dimensions [height, width]
        p (float, optional): Occupation probability. Defaults to 0.59.
        max_iter (int, optional): Number of iterations. Defaults to 1000.
    """

    def __init__(
        self, *size: UniversalArray, p: float = 0.59, max_iter: int = 1000
    ) -> None:
        """Initialize the percolation model."""
        self.p = p
        self.fractal_dimension = float(91 / 48)  # At critical probability (91/48)
        self.rng = np.random.default_rng()
        if len(size) != __2d__:
            raise OutOfDimensionError(
                function_name=self.__class__.__name__,
                dimension=__2d__,
            )
        super().__init__(*size, max_iter=max_iter)

    def iterate_system(self, initial_state: np.ndarray) -> np.ndarray:
        """Update the percolation grid.

        Args:
            initial_state: Current grid state

        Returns:
            np.ndarray: Updated grid
        """
        height, width = initial_state.shape
        new_cells = self.rng.random(initial_state.shape) < self.p

        # Combine existing occupied cells with new ones
        state = np.logical_or(initial_state, new_cells).astype(float)

        # Update clusters - mark cells with value 5.0 for better visibility
        for i in range(1, height - 1):
            for j in range(1, width - 1):
                if state[i, j] == 1:
                    # Connect to neighboring clusters
                    neighbors = state[i - 1 : i + 2, j - 1 : j + 2]
                    if np.sum(neighbors) > 1:
                        state[i, j] = 5.0  # Higher value for better contrast

        return state

    @property
    def __eval__(self) -> np.ndarray:
        """Generate the percolation pattern.

        Returns:
            np.ndarray: Final grid state
        """
        # Initialize grid with zeros
        try:
            height = int(self._x[0][0])
            width = int(self._x[1][0])
            state = np.zeros((height, width), dtype=float)
        except (IndexError, ValueError, TypeError):
            # Fallback if dimensions are not properly specified
            state = np.zeros((100, 100), dtype=float)

        # Run simulation
        for _ in range(self.max_iter):
            state = self.iterate_system(state)

        return state


class RandomWalkFractal(DynamicFractalFunction):
    r"""Implementation of a random walk fractal.

    A random walk fractal is generated by taking random steps in a bounded space,
    creating patterns that exhibit fractal properties.

    Notes:
        The random walk is a mathematical formalization of a path consisting of
        successive random steps. In two dimensions, it follows the equation:

        $$
        \vec{r}_{n+1} = \vec{r}_n + \delta \hat{e}(\theta_n)
        $$

        where $\vec{r}_n$ is the position at step $n$, $\delta$ is the step size,
        $\theta_n$ is a random angle uniformly distributed over $[0, 2\pi)$, and
        $\hat{e}(\theta_n)$ is the unit vector in the direction of $\theta_n$.

        Random walks have a fractal dimension of 2 in free space, but bounded
        walks exhibit a smaller dimension of approximately 1.5. They are related
        to Brownian motion and diffusion processes in physics.

    Examples:
        >>> import numpy as np
        >>> import matplotlib.pyplot as plt
        >>> from umf.functions.fractal_set.dynamic import RandomWalkFractal
        >>> # Generate random walk
        >>> start = np.array([0.]), np.array([0.])
        >>> bounds = np.array([[-10, 10], [-10, 10]])
        >>> walk = RandomWalkFractal(*start, bounds=bounds, max_iter=10000)()
        >>> points = walk.result

        >>> # Visualization
        >>> _ = plt.figure(figsize=(10, 10))
        >>> _ = plt.plot(points[:, 0], points[:, 1], 'b-', linewidth=0.5)
        >>> _ = plt.axis('equal')
        >>> _ = plt.title("Random Walk Fractal")
        >>> plt.savefig("RandomWalkFractal.png", dpi=300, transparent=True)

    Args:
        walk_data (Tuple[UniversalArray, UniversalArray]): Tuple containing:
            - start: Starting point [x, y]
            - bounds: Boundary limits [[xmin, xmax], [ymin, ymax]]
        max_iter (int, optional): Number of steps. Defaults to 10000.
        step_size (float, optional): Size of each step. Defaults to 1.0.
        dimension (int, optional): Dimensionality of the walk. Defaults to 2.
    """

    def __init__(
        self,
        *walk_data: UniversalArray,
        bounds: UniversalArray | None = None,
        max_iter: int = 10000,
        step_size: float = 1.0,
        dimension: int = 2,
    ) -> None:
        """Initialize the random walk fractal."""
        self.step_size = step_size
        self.dimension = dimension
        if bounds is not None:
            self.bounds = np.array(bounds)
        else:
            self.bounds = np.array([[-10, 10], [-10, 10]])
        # For bounded random walks in 2D
        self.fractal_dimension = 1.5 if self.dimension == 2 else 2.0

        if len(walk_data) != __2d__:
            raise OutOfDimensionError(
                function_name=self.__class__.__name__,
                dimension=__2d__,
            )
        super().__init__(*walk_data, max_iter=max_iter)

    def iterate_system(self, state: np.ndarray) -> np.ndarray:
        """Take a random step from current position.

        Args:
            state (np.ndarray): Current position

        Returns:
            np.ndarray: New position
        """
        if self.dimension == 2:
            # Generate random angle
            angle = np.random.uniform(0, 2 * np.pi)
            # Take step in random direction
            new_state = state + self.step_size * np.array(
                [np.cos(angle), np.sin(angle)]
            )

            # Enforce boundaries
            bounds = np.asarray(self.bounds)
            for i in range(self.dimension):
                new_state[i] = np.clip(new_state[i], bounds[i, 0], bounds[i, 1])
        else:
            # Handle higher dimensions with normalized random steps
            step = np.random.normal(0, 1, self.dimension)
            step = step / np.linalg.norm(step) * self.step_size
            new_state = state + step

            # Apply bounds if provided (assuming bounds is properly dimensioned)
            if self.bounds is not None:
                if self.bounds.shape[0] == self.dimension:
                    for i in range(self.dimension):
                        new_state[i] = np.clip(
                            new_state[i], self.bounds[i, 0], self.bounds[i, 1]
                        )

        return new_state

    @property
    def __eval__(self) -> np.ndarray:
        """Generate the random walk points.

        Returns:
            np.ndarray: Array of points visited by the walk
        """
        state = np.array(
            [self._x[0][0], self._x[1][0]]
        )  # Extract scalar values from arrays
        points = [state]

        for _ in range(self.max_iter):
            state = self.iterate_system(state)
            points.append(state.copy())

        return np.array(points)
